---
title: "George_Tofaris_iPSC_pooled_ALL_treatments_NSC version 3"
author: "Devika Agarwal"
date: 'Last update: `r date()`'
output:
  html_document:
    theme: cerulean
    number_sections: true
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: yes
      toc_depth: 8
---
<style type="text/css">

body{ /* Normal  */
      font-size: 12px;
  }
td {  /* Table  */
  font-size: 12px;
}
h1.title {
  font-size: 18px;
  color: DarkRed;
}
h1 { /* Header 1 */
  font-size: 16px;
  color: DarkBlue;
}
h2 { /* Header 2 */
    font-size: 14px;
  color: DarkBlue;
}
h3 { /* Header 3 */
  font-size: 12px;
  font-family: "Times New Roman", Times, serif;
  color: DarkBlue;
}

h4 { /* Header 4 */
  font-size: 12px;
  font-family: "Times New Roman", Times, serif;
  color: DarkBlue;
}
code.r{ /* Code block */
    font-size: 12px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 14px;
}
</style>
```{r setup, include=F, message=F, warning=FALSE}
knitr::opts_chunk$set(echo=FALSE,message=FALSE,warning=FALSE, cache=TRUE)
#rm(list=ls())
#biocLite("sva") #install sva
#install.packages("DT")
#install.packages("png")
library(knitr)
library(sva)
library(DT)
library(png)
library(grid)
library(plyr)
#biocLite("biomaRt")
library(biomaRt)
library(tidyverse)
library(corrr)
#install.packages("gplots")
library(gplots)
#install.packages("dendextend")
library(dendextend)
library(ggplot2)
#biocLite("oligo")
#library(oligo)
#install.packages("data.table")
library(data.table)
#source("https://bioconductor.org/biocLite.R")
#biocLite("limma")
#library(limma)
#source("https://bioconductor.org/biocLite.R")
#biocLite("DESeq2")
library(DESeq2)
#install.packages("stringr")
library(stringr)
#install.packages("RColorBrewer")
library(RColorBrewer)
#library(scater)
library(tximport) # here only needed to get and report effective gene lengths
library(readr) # used by tximport for faster import
library(VennDiagram)
library(ggrepel)
library(org.Hs.eg.db)
library(AnnotationDbi)
library(clusterProfiler)
library(gprofiler2)
library(GeneTonic)
library(viridis)
library(splitstackshape) 
library(RUVSeq)
# for splitting data table columns
#library(tximeta)


futile.logger::flog.threshold(futile.logger::ERROR, name = "VennDiagramLogger")

## white background theme for all plots
theme_set(theme_bw())
multicoreParam <- MulticoreParam(workers = 6)
multicoreParam
```


```{r functions}
# Vector to colours
Vector2Colour <- function(clase, ucol2 = c("red", "blue"), alfa = .8, Pal = "Blues"){
  colores <- vector(length = length(clase))
  if(is.numeric(clase)){
    pal1 <- colorRampPalette(brewer.pal(n = 9, name = Pal)[3:9], space = "Lab")
    ucol <- pal1(length(unique(clase)))
    rk <- rank(clase)
    rku <- unique(rk)
    rku <- rku[order(rku)]
    for (i in c(1:length(ucol))){
      colores[which(rank(clase) == rku[i])] <- ucol[i]    
    }
  } else {
    if(length(unique(clase)) == 2){
      ucol <- ucol2
      for (i in c(1:length(ucol))){
        colores[which(clase == unique(clase)[i])] <- ucol[i]    
      }
    } else {
      if(length(unique(clase)) < 9){
        pal1 <- brewer.pal(9, "Set1")[-6] # Remove yellow
        ucol <- pal1[1:length(unique(clase))]
        for (i in c(1:length(ucol))){
          colores[which(clase == unique(clase)[i])] <- ucol[i]    
        }
      } else {
        if(length(unique(clase)) > 8){
          pal1 <- colorRampPalette(brewer.pal(n = 7, name = "Dark2"), space = "Lab")
          ucol <- pal1(length(unique(clase)))
          for (i in c(1:length(ucol))){
            colores[which(clase == unique(clase)[i])] <- ucol[i]    
          }
        }
      }
    }  
  }
  colores <- alpha(colores, alpha = alfa)
  return(colores)
}


# From_Jimena
# Hyperlinks to ensembl 
ens_links <- function(geneids){
  genelinks <- vector()
  for (i in c(1:length(geneids))){
  genelinks[i] <- paste('<a href="', paste("http://www.ensembl.org/Mus_musculus/Gene/Summary?g=", geneids[i], sep = ""),'">', geneids[i], '</a>', sep = "")   }
  return(genelinks)
}  

ensembl_url <- "<a href=\"http://www.ensembl.org/Homo_sapiens/Gene/Summary?g="

# From_Frank
# create hyperlinks in tables printed with the DT package
set_hyperlinks <- function(DT, col_names, url_strings) {
  DT_out <- copy(DT)  
  for (i in 1:length(col_names)){
    ## DT_out[, (col_names[i]) := paste0(url_strings[i], get(col_names[i]),"\">", get(col_names[i]),"</a>")]
    DT_out[(col_names[i]) != '', (col_names[i]) := paste0(url_strings[i], get(col_names[i]),"\">", get(col_names[i]),"</a>")]
  }
  DT_out
}

# From Jimena
# TPM_matrix from tx object #
TPM_from_tx <- function(tx_import_object){
  countsbylength <- tx_import_object$counts/tx_import_object$length
  total_countsbylength <- colSums(countsbylength)
  data_TPM <- t(apply(countsbylength, 1, function(x) x / total_countsbylength * 1000000))
  colnames(data_TPM) <- colnames(tx_import_object$counts)
  return(data_TPM)
}

## re-format DESeq2 results table


print_DESeq_table <- function(A, alpha_level = 0.05, t2g_info = t2g_genes, merge_column = "gene", logfcthreshold=0){
  
  A_2 <- as.data.table(A)
  A_2 <- A_2[, target_id := rownames(A)]
  A_2 <- A_2[order(pvalue)]
  A_2 <- A_2[log2FoldChange < (-logfcthreshold), fc := "down"]
  A_2[log2FoldChange < (-logfcthreshold) & !is.na(padj), rank := 1:sum(log2FoldChange < (-logfcthreshold))]
  A_2 <- A_2[log2FoldChange > logfcthreshold, fc := "up"]
  A_2[log2FoldChange > logfcthreshold & !is.na(padj), rank := 1:sum(log2FoldChange > logfcthreshold)]
  
  A_2 <- A_2[padj < alpha_level, ]
  
  A_2[,c("lfcSE") := NULL]
  
  C <- merge(A_2, t2g_info[, .(gene, ens_gene, gene_type, ext_gene, desc)], by.x="target_id", by.y=merge_column, all.x=T)
  ### C <- C[, target_id := NULL] ## keep for now, for look-up
  
  setcolorder(C, c("target_id", "ext_gene", "ens_gene", "log2FoldChange","pvalue", "padj", "fc", "rank", "baseMean", "gene_type", "desc"))
  
  C[, c("log2FoldChange","pvalue","padj") := list(signif(log2FoldChange, 3), signif(pvalue, 3), signif(padj, 3))]
  C[, baseMean := round(baseMean, digits=1)]
  setnames(C, c("log2FoldChange"), c("log2FC"))
  C[order(pvalue)]
}




## create table to combine results from 3 concentrations
print_DESeq_union_table <- function(L, M, H, alpha_level = 0.05, t2g_info = t2g_genes, merge_column = "target_id"){
  
  setnames(L, c("target_id", paste0(colnames(L)[-1], "_L")))
  setnames(M, c("target_id", paste0(colnames(M)[-1], "_M")))
  setnames(H, c("target_id", paste0(colnames(H)[-1], "_H")))
  
  C <- merge(L[, .(target_id, log2FoldChange_L, padj_L)], M[, .(target_id, log2FoldChange_M, padj_M)], by="target_id")
  C <- merge(C, H[, .(target_id, log2FoldChange_H, padj_H)], by="target_id")
  
  C <- C[log2FoldChange_L < 0, fc_L := "down"]
  C <- C[log2FoldChange_L > 0, fc_L := "up"]
  C <- C[log2FoldChange_M < 0, fc_M := "down"]
  C <- C[log2FoldChange_M > 0, fc_M := "up"]
  C <- C[log2FoldChange_H < 0, fc_H := "down"]
  C <- C[log2FoldChange_H > 0, fc_H := "up"]
  
  C <- C[, sig_num := sum(padj_L < alpha_cutoff, padj_M < alpha_cutoff, padj_H < alpha_cutoff, na.rm = T), by="target_id"]
  C <- C[padj_L < alpha_cutoff, L := "L"]
  C <- C[padj_M < alpha_cutoff, M := "M"]
  C <- C[padj_H < alpha_cutoff, H := "H"]
  
  C <- merge(C, t2g_info[, .(target_id, ens_gene, ext_gene, desc)], by.x="target_id", by.y=merge_column, all.x=T)
  C <- C[, target_id := NULL]
  
  setcolorder(C, c("ext_gene", "ens_gene", "sig_num", c("L","M","H"), paste0("fc_", c("L","M","H")), paste0("log2FoldChange_", c("L","M","H")), paste0("padj_", c("L","M","H")), "desc"))
  
  C[, c(paste0("log2FoldChange_", c("L","M","H")), paste0("padj_", c("L","M","H"))) := list(signif(log2FoldChange_L, 3), signif(log2FoldChange_M, 3), signif(log2FoldChange_H, 3), signif(padj_L, 3), signif(padj_M, 3), signif(padj_H, 3))]
  
  setnames(C, paste0("log2FoldChange_", c("L","M","H")), paste0("l2fc_", c("L","M","H")))
  C[order(-sig_num)]
}


## print top DEGs
# get data from DESeq2 plotCounts function
# counts data is normalized 
# from `DESeq2::counts`: normalized: logical indicating whether or not to divide the counts by the size factors or normalization factors before returning (normalization factors always preempt size factors)
my_plot_counts <- function(obj, plot_genes=NULL, intgroup_vec=c("Treatment_time", "Group"), t2g_info=NULL, n_ncol=4, n_nrow =6, title=NULL){

  # collect data for each gene
  plot_data_all <- as.data.table(plotCounts(obj, gene = plot_genes[1], intgroup_vec, returnData=TRUE,transform = F))
  plot_data_all[, gene := plot_genes[1]]
  plot_data_all[, gene_idx := formatC(1,width=2,flag='0')]
  
  if (length(plot_genes) >= 2){
    for (i in 2:length(plot_genes)){
      
      plot_data <- as.data.table(plotCounts(obj, gene = plot_genes[i], intgroup_vec, returnData=TRUE,transform = F))
      plot_data[, gene := plot_genes[i]]
      plot_data[, gene_idx := formatC(i,width=2,flag='0')]
      plot_data_all <- rbind(plot_data_all, plot_data)
    }
  }
  
  plot_data_all <- merge(plot_data_all, t2g_info[, .(gene, ext_gene)], by.x="gene", by.y="gene")
  # plot_data_all[, gene_print := paste0(gene_idx, "  ", gene, "  ", ext_gene)]
  # plot_data_all[, gene_print := paste0(gene_idx, "  ", gene)]
  plot_data_all[, gene_print := paste0(gene_idx, "  ", ext_gene)] ## use only gene symbol as facet title
  
  p <- ggplot(data = plot_data_all, aes(x=Group, y=log2(count+1), colour=Treatment_time))
  p <- p + geom_violin(aes(group=Group), alpha = 0, colour = "gray60", scale="width")
  ## p <- p + ggbeeswarm::geom_quasirandom(alpha = 0.6, size = 3, groupOnX = TRUE)
  p <- p + geom_point(position = position_jitterdodge(), size=5, alpha=0.6)
  p <- p + xlab(NULL)
  p <- p + facet_wrap(~gene_print, ncol=n_ncol, scales="free_y",nrow = n_nrow)
  p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
  p <- p + ylab("log2(normalised count + 1)") + theme(legend.position="top")
  p <- p + theme(axis.text.x=element_text(angle=90, hjust=1, size=10)) + theme(axis.text.y = element_text(size=8))
  p <- p + ggtitle(title)
  p
}


getZScore <- function(geneIDs, DEGs) {
  pathgenes <- str_split(geneIDs, "/") %>% unlist()
  deRes <- as.data.frame(DEGs)
  deRes <- subset(deRes,deRes$symbol %in% pathgenes)
  up <- deRes %>% dplyr::filter(log2FoldChange > 0) %>% nrow()
  down <- deRes %>% dplyr::filter(log2FoldChange < 0) %>% nrow()
  
  #score <- (up - down) / nrow(deRes)
  score <- (up - down) /sqrt(up + down)
  
  return(score)
}

getZScore_v2 <- function(geneIDs, DEGs) {
  pathgenes <- str_split(geneIDs, "/") %>% unlist()
  deRes <- as.data.frame(DEGs)
  deRes <- subset(deRes,deRes$entrez %in% pathgenes)
  up <- deRes %>% dplyr::filter(log2FoldChange > 0) %>% nrow()
  down <- deRes %>% dplyr::filter(log2FoldChange < 0) %>% nrow()
  
  #score <- (up - down) / nrow(deRes)
  score <- (up - down) /sqrt(up + down)
  
  return(score)
}
RScorePlot <- function(enrichObj, DESeqRes, showCategory = 25, textSize = 10, title = NULL) {
  df <- enrichObj@result %>% 
    separate(GeneRatio, c("obs_hits", "obs_total"), "/") %>% 
    separate(BgRatio, c("exp_hits", "exp_total"), "/")
  df$zscore <- map_dbl(enrichObj@result$geneID, getZScore, DESeqRes)
  df <- df %>% 
    mutate_at(3:6, as.numeric) %>% 
    dplyr::mutate(enrichScore = (obs_hits/obs_total)/(exp_hits/exp_total)) %>% 
    as.data.frame() %>% 
    dplyr::arrange(p.adjust) %>% 
    dplyr::slice(1:showCategory)

  p <- df %>% 
    ggplot(aes(x = reorder(Description, -log10(p.adjust)), y = -log10(p.adjust))) +
    geom_point(aes(col = zscore, size = enrichScore)) +
    coord_flip() +
    scale_color_distiller(limits = c(-1, 1), type = "div", palette = "RdBu", direction = 1 ) +
    ylab("adjusted p-value (-log10)") +
    xlab(NULL) +
    ggtitle(title) +
    theme_bw() +
    theme(text = element_text(size = textSize))
  return(p)
}


RScorePlot_v2 <- function(enrichObj, DESeqRes, showCategory = 25, textSize = 10, title = NULL) {
  df <- enrichObj@result %>% 
    separate(GeneRatio, c("obs_hits", "obs_total"), "/") %>% 
    separate(BgRatio, c("exp_hits", "exp_total"), "/")
  df$zscore <- map_dbl(enrichObj@result$geneID, getZScore, DESeqRes)
  df <- df %>% 
    dplyr::filter(Count >=10 & pvalue < 0.05) %>%
    mutate_at(3:6, as.numeric) %>% 
    dplyr::mutate(enrichScore = (obs_hits/obs_total)/(exp_hits/exp_total)) %>% 
    as.data.frame() %>% 
    dplyr::arrange(p.adjust) %>% 
    dplyr::slice(1:showCategory)

  p <- df %>% 
    ggplot(aes(x = reorder(Description, -log10(p.adjust)), y = -log10(p.adjust))) +
    geom_point(aes(fill = zscore, size =Count), stroke=0.5, shape=21) +
    coord_flip() +
    scale_fill_gradient2(low=("darkblue"),mid="white",high =("darkred")) +
    #scale_color_distiller(limits = c(-1, 1), type = "div", palette = "RdBu", direction = -1 ) +
    ylab("adjusted pvalue (-log10)") +
    xlab(NULL) +
    ggtitle(title) +
    theme_bw() +
    theme(text = element_text(size = textSize))
  return(p)
}

RScorePlot_v3 <- function(enrichObj, DESeqRes, showCategory = 25, textSize = 10, title = NULL, p_val="p.adjust") {
  df <- enrichObj@result %>% 
    separate(GeneRatio, c("obs_hits", "obs_total"), "/") %>% 
    separate(BgRatio, c("exp_hits", "exp_total"), "/")
  df$zscore <- map_dbl(enrichObj@result$geneID, getZScore, DESeqRes)
  df <- df %>% 
    mutate_at(3:6, as.numeric) %>% 
    dplyr::mutate(enrichScore = (obs_hits/obs_total)/(exp_hits/exp_total)) %>% 
    as.data.frame() %>% 
    dplyr::arrange(p_val) %>% 
    dplyr::slice(1:showCategory)

  p <- df %>% 
    ggplot(aes(x = reorder(Description, -log10(p_val)), y = -log10(p_val))) +
    geom_point(aes(fill = zscore, size =Count),stroke=0.5, shape=21) +
    coord_flip() +
    scale_fill_gradient2(low=("darkblue"),mid="white",high =("darkred")) +
   # scale_color_distiller(limits = c(-1, 1), type = "div", palette = "RdBu", direction = 1 ) +
    ylab(paste0(p_val, "(-log10)")) +
    xlab(NULL) +
    ggtitle(title) +
    theme_bw() +
    theme(text = element_text(size = textSize))
  return(p)
}

RScorePlot_v4 <- function(enrichObj, DESeqRes, showCategory = 25, textSize = 10, title = NULL) {
  df <- enrichObj@result %>% 
    separate(GeneRatio, c("obs_hits", "obs_total"), "/") %>% 
    separate(BgRatio, c("exp_hits", "exp_total"), "/")
  df$zscore <- map_dbl(enrichObj@result$geneID, getZScore_v2, DESeqRes)
  df <- df %>% 
    dplyr::filter(Count >=10 & pvalue < 0.05) %>%
    mutate_at(3:6, as.numeric) %>% 
    dplyr::mutate(enrichScore = (obs_hits/obs_total)/(exp_hits/exp_total)) %>% 
    as.data.frame() %>% 
    dplyr::arrange(p.adjust) %>% 
    dplyr::slice(1:showCategory)

  p <- df %>% 
    ggplot(aes(x = reorder(Description, -log10(p.adjust)), y = -log10(p.adjust))) +
    geom_point(aes(fill = zscore, size =Count), stroke=0.5, shape=21) +
    coord_flip() +
    scale_fill_gradient2(low=("darkblue"),mid="white",high =("darkred")) +
    #scale_color_distiller(limits = c(-1, 1), type = "div", palette = "RdBu", direction = -1 ) +
    ylab(" adjusted pvalue (-log10)") +
    xlab(NULL) +
    ggtitle(title) +
    theme_bw() +
    theme(text = element_text(size = textSize))
  return(p)
}


pcaCorrPlot <- function(counts, ntop = 2000, metadata, returnData = FALSE) {
  #pca
  rv <- rowVars(assay(counts))
  rowSel <- order(rv, decreasing = T)[seq_len(ntop)]
  pca <- prcomp(t(assay(counts)[rowSel, ]))
  percentVar <- pca$sdev^2 / sum(pca$sdev^2)

  #attach PCs to metadata
  pc.df <- pca$x %>% 
    as.data.frame() %>% 
    rownames_to_column(var = "sample")
  meta <- metadata %>% 
    mutate(joinName = paste(sample, treatment, sep = "."))
  meta <- inner_join(meta, pc.df, by = c( "joinName" = "sample"))
  meta <- meta %>% 
    dplyr::select(-disease, -joinName, -fastq, -mapped)

  #column names by variable type
  facCols <- meta %>% 
    dplyr::select_if(is.factor) %>%
    colnames()

  pcCols <- meta %>%
    dplyr::select(starts_with("PC")) %>%
    colnames()

  #factor correlations
  facCor.df <- expand.grid(pcCols, facCols) 

  rsquared <- facCor.df %>%
    apply(1, function(x) reformulate(x[2], x[1])) %>%
    lapply(., lm, data = meta) %>%
    map(summary) %>%
    map_dbl("r.squared")

  facCor.df$corr <- sqrt(rsquared)

  facCor.df <- facCor.df %>%
    dplyr::rename(PC = Var1, covariate = Var2) %>%
    mutate(type = "lm")

  #numeric correlations
  numCor.df <- meta %>%
    dplyr::select_if(is.numeric) %>%
    correlate(method = "kendall") %>%
    focus(-matches("^PC")) %>%
    gather(variable, corr, 2:7) %>%
    mutate(type = "kendall") %>%
    dplyr::rename(PC = rowname, covariate = variable)

  #combine
  pcaBar <- bind_rows(numCor.df, facCor.df)

  #filter sample and sex
  pcaBar <- pcaBar %>%
    filter( ! (covariate %in% c("sample", "sex")))

  #add percent variation
  pcs <- paste("PC", 1:8, sep = "")
  pvar <- data.frame( PC = pcs, perVar = paste(pcs, " (", sprintf("%.2f", percentVar * 100), "%)", sep = ""))
  pcaBar <- inner_join(pcaBar, pvar)

  #arrange
  pcaBar <- pcaBar %>%
    group_by(PC) %>%
    arrange(corr) %>%
    unite("pcvar", PC, covariate, sep = "_", remove = F) %>%
    data.frame() %>%
    mutate(pcvar = factor(pcvar, levels = pcvar))

  #return data
  if (returnData) {
    return(pcaBar)
  }

  #plot
  pcaBar %>%
    group_by(PC) %>%
    ggplot(aes(x = pcvar, y = corr)) +
    geom_col(aes(fill = type)) +
    coord_flip() + 
    facet_wrap( ~ perVar, scale = "free_y") +
    xlab("metadata") +
    ylab("correlation") +
    scale_x_discrete(breaks = pcaBar$pcvar, labels = pcaBar$covariate) +
    scale_y_continuous(limits = c(-1, 1)) +
    scale_fill_manual(values = c("darkorange", "dodgerblue")) +
    theme_bw()

}

plotPCA_higher_2_3 <- function(object, intgroup = "condition", ntop=1000, returnData = FALSE) {
        rv <- rowVars(assay(object))
        select <- order(rv, decreasing = TRUE)[seq_len(min(ntop,
            length(rv)))]
        pca <- prcomp(t(assay(object)[select, ]))
        percentVar <- pca$sdev^2/sum(pca$sdev^2)
        if (!all(intgroup %in% names(colData(object)))) {
            stop("the argument 'intgroup' should specify columns of colData(dds)")
        }
        intgroup.df <- as.data.frame(colData(object)[, intgroup,
            drop = FALSE])
        group <- if (length(intgroup) > 1) {
            factor(apply(intgroup.df, 1, paste, collapse = ":"))
        }
        else {
            colData(object)[[intgroup]]
        } 
        d <- data.frame(PC2 = pca$x[, 2], PC3 = pca$x[, 3], group = group,
            intgroup.df, name = colnames(object))
        if (returnData) {
            attr(d, "percentVar") <- percentVar[2:3]
            return(d)
        }
        g<-ggplot(data = d, aes_string(x = "PC2", y = "PC3", color = "group")) +
            geom_point(size = 3) + xlab(paste0("PC2: ", round(percentVar[2] *
            100,2), "%")) + ylab(paste0("PC3: ", round(percentVar[3] *
            100,2), "%")) + coord_fixed()
        return(g)
}


plotPCA_higher_3_4 <- function(object, intgroup = "condition", ntop=1000, returnData = FALSE) {
        rv <- rowVars(assay(object))
        select <- order(rv, decreasing = TRUE)[seq_len(min(ntop,
            length(rv)))]
        pca <- prcomp(t(assay(object)[select, ]))
        percentVar <- pca$sdev^2/sum(pca$sdev^2)
        if (!all(intgroup %in% names(colData(object)))) {
            stop("the argument 'intgroup' should specify columns of colData(dds)")
        }
        intgroup.df <- as.data.frame(colData(object)[, intgroup,
            drop = FALSE])
        group <- if (length(intgroup) > 1) {
            factor(apply(intgroup.df, 1, paste, collapse = ":"))
        }
        else {
            colData(object)[[intgroup]]
        } 
        d <- data.frame(PC3 = pca$x[, 3], PC4 = pca$x[, 4], group = group,
            intgroup.df, name = colnames(object))
        if (returnData) {
            attr(d, "percentVar") <- percentVar[3:4]
            return(d)
        }
        g<-ggplot(data = d, aes_string(x = "PC3", y = "PC4", color = "group")) +
            geom_point(size = 3) + xlab(paste0("PC3: ", round(percentVar[3] *
            100,2), "%")) + ylab(paste0("PC4: ", round(percentVar[4] *
            100,2), "%")) + coord_fixed()
        return(g)
}

plotPCA_higher_4_5 <- function(object, intgroup = "condition", ntop=1000, returnData = FALSE) {
        rv <- rowVars(assay(object))
        select <- order(rv, decreasing = TRUE)[seq_len(min(ntop,
            length(rv)))]
        pca <- prcomp(t(assay(object)[select, ]))
        percentVar <- pca$sdev^2/sum(pca$sdev^2)
        if (!all(intgroup %in% names(colData(object)))) {
            stop("the argument 'intgroup' should specify columns of colData(dds)")
        }
        intgroup.df <- as.data.frame(colData(object)[, intgroup,
            drop = FALSE])
        group <- if (length(intgroup) > 1) {
            factor(apply(intgroup.df, 1, paste, collapse = ":"))
        }
        else {
            colData(object)[[intgroup]]
        } 
        d <- data.frame(PC4 = pca$x[, 4], PC5 = pca$x[, 5], group = group,
            intgroup.df, name = colnames(object))
        if (returnData) {
            attr(d, "percentVar") <- percentVar[4:5]
            return(d)
        }
        g<-ggplot(data = d, aes_string(x = "PC4", y = "PC5", color = "group")) +
            geom_point(size = 3) + xlab(paste0("PC4: ", round(percentVar[4] *
            100,2), "%")) + ylab(paste0("PC5: ", round(percentVar[5] *
            100,2), "%")) + coord_fixed()
        return(g)
}

plotPCA_higher_5_6 <- function(object, intgroup = "condition", ntop=1000, returnData = FALSE) {
        rv <- rowVars(assay(object))
        select <- order(rv, decreasing = TRUE)[seq_len(min(ntop,
            length(rv)))]
        pca <- prcomp(t(assay(object)[select, ]))
        percentVar <- pca$sdev^2/sum(pca$sdev^2)
        if (!all(intgroup %in% names(colData(object)))) {
            stop("the argument 'intgroup' should specify columns of colData(dds)")
        }
        intgroup.df <- as.data.frame(colData(object)[, intgroup,
            drop = FALSE])
        group <- if (length(intgroup) > 1) {
            factor(apply(intgroup.df, 1, paste, collapse = ":"))
        }
        else {
            colData(object)[[intgroup]]
        } 
        d <- data.frame(PC5 = pca$x[, 5], PC6 = pca$x[, 6], group = group,
            intgroup.df, name = colnames(object))
        if (returnData) {
            attr(d, "percentVar") <- percentVar[5:6]
            return(d)
        }
        g<-ggplot(data = d, aes_string(x = "PC5", y = "PC6", color = "group")) +
            geom_point(size = 3) + xlab(paste0("PC5: ", round(percentVar[5] *
            100,2), "%")) + ylab(paste0("PC6: ", round(percentVar[6] *
            100,2), "%")) + coord_fixed()
        return(g)
}

test_enrich_two_sets_avi <- function(input_net, input_cds, input_list_1, input_list_2, input_universe, n_rand){
  ## restrict to universe
  input_net <- input_net[gene1 %in% input_universe & gene2 %in% input_universe, ]
  cat("  \n* Links in PPI network within gene universe: ", nrow(input_net), fill=T)
  ## sum of scores for each gene in network
  ## for PPI this is equivalent to the number of PPIs/links to other genes
  net_melt <- melt(input_net, id.vars = c("score"))
  net_genes_scores <- net_melt[, sum(score), by = "value"]
  setnames(net_genes_scores, c("gene", "score"))
  
  ## consider only those genes that are in the network AND have CDS length info
  info_table <- merge(net_genes_scores, input_cds, by="gene")
  
  ## consider only genes from input lists that are in input network and have CDS length info
  input_list_1 <- intersect(input_list_1, info_table[, gene])
  input_list_2 <- intersect(input_list_2, info_table[, gene])

  ## 'Avi'-like binning approach
  ## the same as in GeneNet Toolbox using 'scott' method
  n_bins_score <- nclass.scott(info_table[, score])
  n_bins_cds <-  nclass.scott(info_table[, max_length])
  
  ## print(n_bins_score)
  ## print(n_bins_cds)
  
  ## prepare data: get unique overall bins/groups based on score AND cds and number of input genes within each of those bins
  ## this will determine how many genes to pick from each bin/group
  
  x <- copy(info_table)
  x$group_score <- as.factor(cut(x$score, n_bins_score, labels=F))
  x$group_cds <- as.factor(cut(x$max_length, n_bins_cds, labels=F))
  ## combine the two bins to get 'unique bins' for both gene attributes
  x <- x[, group := as.numeric(as.factor(paste0(group_score, "_", group_cds)))]
  
  ## in which bins/groups do the input genes fall:
  x <- x[, n_list_1 := 0]
  x <- x[gene %in% input_list_1, n_list_1 := 1]
  x <- x[, n_list_2 := 0]
  x <- x[gene %in% input_list_2, n_list_2 := 1]
  
  ## number of genes to draw per group i.e. number of input genes in each group
  n_list_1_per_group <- x[n_list_1 == 1, list(n_list_1 = .N), by="group"]
  n_list_2_per_group <- x[n_list_2 == 1, list(n_list_2 = .N), by="group"]
  
  ## number of candidate genes per group, across all groups
  n_size_per_group <- x[, list(bin_size = .N),by="group"]
  
  ## 2 look-up tables: list all genes within the unique bins
  ## 1 table for each input gene list
  
  bin_table_1 <- merge(n_list_1_per_group, n_size_per_group, by="group")
  bin_table_1 <- bin_table_1[, idx_in_group := paste(1:bin_size, collapse = ','), by="group"]
  genes_bins_table_1 <- cSplit(bin_table_1, splitCols = "idx_in_group", sep = ",", direction = "long")[order(group, idx_in_group)]
  bin_table_1 <- bin_table_1[, idx_in_group := NULL]
  genes_bins_table_1 <- cbind(genes_bins_table_1[, group := NULL], x[group %in% bin_table_1[, group], .(gene, group, score, max_length)][order(group, gene)])
  
  bin_table_2 <- merge(n_list_2_per_group, n_size_per_group, by="group")
  bin_table_2 <- bin_table_2[, idx_in_group := paste(1:bin_size, collapse = ','), by="group"]
  genes_bins_table_2 <- cSplit(bin_table_2, splitCols = "idx_in_group", sep = ",", direction = "long")[order(group, idx_in_group)]
  bin_table_2 <- bin_table_2[, idx_in_group := NULL]
  genes_bins_table_2 <- cbind(genes_bins_table_2[, group := NULL], x[group %in% bin_table_2[, group], .(gene, group, score, max_length)][order(group, gene)])

  ### scores_rand <- data.table(overlap_with_list_1 = numeric(length=n_rand), overlap_with_list_2 = numeric(length=n_rand), score = numeric(length=n_rand))
  scores_rand <- matrix(nrow = n_rand + 1, ncol = 3)

  ## create reverse table, speed up  
  input_net_reverse <- copy(input_net)
  setnames(input_net_reverse, c("gene2", "gene1", "score"))
  setcolorder(input_net_reverse, c("gene1", "gene2", "score"))
  input_net_reverse <- rbind(input_net, input_net_reverse)
  keycols = c("gene1", "gene2")
  setkeyv(input_net_reverse, keycols)
  
  for (k in 1:n_rand) {
    
    ## from each bin/group get random genes
    rand_set_1 <- bin_table_1[, sample(1:bin_size, n_list_1), by="group"] ## get random index set
    setnames(rand_set_1, "V1", "idx_in_group")
    rand_set_1 <- merge(genes_bins_table_1, rand_set_1, by=c("group", "idx_in_group"))
    
    rand_set_2 <- bin_table_2[, sample(1:bin_size, n_list_2), by="group"] ## get random index set
    setnames(rand_set_2, "V1", "idx_in_group")
    rand_set_2 <- merge(genes_bins_table_2, rand_set_2, by=c("group", "idx_in_group"))
    
    links_across <- input_net_reverse[(gene1 %chin% rand_set_1[, gene] & gene2 %chin% rand_set_2[, gene]), ] ## rather slow
    scores_rand[k,] <- c(length(intersect(rand_set_1[, gene], input_list_1)), length(intersect(rand_set_2[, gene], input_list_2)), sum(links_across[, score]))
  }
  
  ## sum of scores for original two gene sets
  links_across <- input_net_reverse[(gene1 %chin% input_list_1 & gene2 %chin% input_list_2), ]
  scores_rand[n_rand + 1, ] <- c(length(input_list_1), length(input_list_2), sum(links_across[, score]))
  
  scores_rand <- as.data.table(scores_rand)
  setnames(scores_rand, c("Overlap_1", "Overlap_2", "Score"))

  ## write summary
  ## average length of randomised sets
  # cat("Length of list 1: ", scores_rand[n_rand+1, Overlap_1], fill=T)
  # cat("Average overlap of random sets with list 1: ", round(mean(scores_rand[1:n_rand, Overlap_1])), fill=T)
  # cat("Length of list 2: ", scores_rand[n_rand+1, Overlap_2], fill=T)
  # cat("Average overlap of random sets with list 2: ", round(mean(scores_rand[1:n_rand, Overlap_2])), fill=T)
  # 
  # cat("Number of simulations: ", n_rand, fill=T)
  # cat("Score for gene lists tested: ", scores_rand[n_rand+1, Score], fill=T)
  # cat("Average score for random gene lists: ", round(mean(scores_rand[1:n_rand, Score])), fill=T)
  # 
  # n_as_good <- sum(scores_rand[1:n_rand, Score] >= scores_rand[n_rand+1, Score])
  # cat("Number of times random sets have the same or higher score: ", n_as_good, fill=T)
  # if (n_as_good == 0){
  #   cat("Empirical p-value: <", 1/n_rand, fill=T)
  # } else {
  #   cat("Empirical p-value: ", n_as_good/n_rand, fill=T)
  # }
  
  
  cat("  \n* Length of list 1: ", scores_rand[n_rand+1, Overlap_1], fill=T)
  cat("  \n* Average overlap of random sets with list 1: ", round(mean(scores_rand[1:n_rand, Overlap_1])), fill=T)
  cat("  \n* Length of list 2: ", scores_rand[n_rand+1, Overlap_2], fill=T)
  cat("  \n* Average overlap of random sets with list 2: ", round(mean(scores_rand[1:n_rand, Overlap_2])), fill=T)
  
  cat("  \n* Number of simulations: ", n_rand, fill=T)
  cat("  \n* Score for gene lists tested: ", scores_rand[n_rand+1, Score], fill=T)
  cat("  \n* Average score for random gene lists: ", round(mean(scores_rand[1:n_rand, Score])), fill=T)
  
  n_as_good <- sum(scores_rand[1:n_rand, Score] >= scores_rand[n_rand+1, Score])
  cat("  \n* Number of times random sets have the same or higher score: ", n_as_good, fill=T)
  if (n_as_good == 0){
    cat("  \n* Empirical p-value: <", 1/n_rand, fill=T)
  } else {
    cat("  \n* Empirical p-value: ", n_as_good/n_rand, fill=T)
  }
  
  scores_rand
}


```



+ Samples: 48 samples in total
+ Genotype : SNCA triplication (clone 3)
+ Stimulation : Non-seeded control(NSC),PD , FIB and MSA, n= 9 each for PD and NSC and n=3 for MSA and FIB
+ Stimulation time : Week1, Week2
+ Differentiation Age post treatment : DIV 52 (Week1) , DIV 59 (Week 2)
+ generate cDNA : Novaseq 6000 and PolyA library prep
+ generate libraries : 
+ Organism: Homo_sapiens
+ Tissue & Cell: iPSC-derived dopinamergic neurons
+ read_type : paired, 150 bp
+ Fragment Library type :IU (Inward Unstranded, an unstranded paired-end library where the reads face each other)
+ Pseudoalignment : Kallisto (v0.46.2)
+ Reference Genome: Ensemble  Release 102
+ Pooled differential analysis for 15 treated samples and 9 NSC iPSC DaN samples
+ DEG comparisons : WK2 Aggregated vs WK1 Aggregated , WK2 NSC vs WK1 NSC , WK1 Aggregated vs WK1 NSC, WK2 Aggregated vs WK2 NSC using an interaction model and account for batch in the design 
+ using ComBaT for batch correction for PCA

```{r files, include=FALSE}
setwd("~/Documents/George_tofaris_manuscripts/2021_June_DaNs_coC_mic/DaNs_treated_PD/")
## Salmon using Mouse ensembl GRCm38 reference
#quant_dir <- "./kallisto3/abundance/"


# Salmon or Kallisto for abundance data
# in_type <- "Kallisto"
in_type <- "kallisto"

# samples metadata
samples_file <- "./June_Jan_21_DaN_treated_metadata_alltreated_aggregated.csv"

# transcript to gene mapping
# generated from headers of fasta file used as transcriptome reference
# contains version numbers for ensembl transcript and gene IDs (v102)
ens_annot_file <- "../genome_v102/Homo_sapiens.GRCh38.cdna.all_genemap.txt"

#salmon_duplicates_file <- "~/Documents//Hazel_ipsc/Homo_sapiens.GRCh38.v95.cdna.all.ncrna_index/duplicate_clusters.tsv"
## number of components for plots e.g. PCA
n_comp <- 6

# n_comp <- 4

## theme size for scater plots
t_size <- 14

## seed to make some plots reproducible
n_seed <- 12

## DESeq2 settings

pre_filter_type <- "counts"
# pre_filter_type <- "tpm"

# minimum expression of a gene - pre-filtering step
# if counts are used: a rowsum-threshold 
# expression_cutoff <- 0 # at least one sample has to have an estimated count of 1
expression_cutoff <- 10 # at least 2 counts across all samples, i.e. remove genes with only 0 or 1 read across all samples
#expression_cutoff <- 15 # at 10 counts across all samples , 
# expression_cutoff <- -1 # no filtering
# if fpkms are used: each gene has at least 1 sample with FPKM > expression_cutoff

# adjusted alpha value
alpha_cutoff <- 0.05

# how many genes with lowest adjusted pvalue to print
top_genes <- 20


## make use of multiple cores
register(MulticoreParam(6))
```

```{r print_setting}

cat("Quantification data from: ", in_type, fill=T)

```

```{r set_annotation}
t2g <- fread(ens_annot_file, header=F)
setnames(t2g, c("target_id", "seqtype", "location", "ens_gene", "gene_type", "tx_type", "ext_gene", "desc"))

# remove version number from ensembl gene IDs
t2g <- t2g[, ens_gene := gsub('\\..*', '', ens_gene, perl=T)]

# combine external gene symbol with ensembl ID
t2g <- t2g[, gene := paste0(ext_gene, ' - ', ens_gene)]

# remove duplicates identified by Salmon index
#salmon_duplicates <- fread(salmon_duplicates_file)
#t2g <- t2g[!(target_id %in% salmon_duplicates[, DuplicateTxp]), ]

###############################################
## consider only protein coding genes
t2g <- t2g[gene_type == "protein_coding", ]
###############################################

# unique ensembl gene IDs
t2g_genes <- unique(t2g, by="ens_gene")
# setnames(t2g_genes, c("target_id", "ens_gene"), c("tx_id", "target_id")) # ensembl ID as target_id
setnames(t2g_genes, c("target_id", "gene"), c("tx_id", "target_id")) # gene symbol + esnembl ID as new target_id


# unique ensembl gene IDs
t2g_genes <- unique(t2g, by="ens_gene")
## setnames(t2g_genes, c("target_id", "ens_gene"), c("tx_id", "target_id"))
## setnames(t2g_genes, c("target_id", "gene"), c("tx_id", "target_id"))

```

```{r setup_samples}

samples_meta <- read_csv(file = samples_file, locale = locale(encoding = "Latin1"))

#samples_meta <- samples_meta[, Condition := factor(Condition, levels=c( "ND", "AD","PD"))]
#samples_meta <- samples_meta[, sample.time := factor(sample.time, levels=c(2,4,6,8))]
samples_meta$Sample_ID <- as.character(samples_meta$Sample_ID)
#samples_meta$Sample_name  <- as.factor(samples_meta$Sample_name)
samples_meta$Replicate <- as.factor(samples_meta$Replicate)
samples_meta$Replicate_2 <- as.factor(samples_meta$Replicate_2)
samples_meta$Treatment_time <- as.factor(samples_meta$Treatment_time)
samples_meta$Treatment_time <- relevel(samples_meta$Treatment_time, ref ="WK1")
samples_meta$Batch <- as.factor(samples_meta$Batch)
samples_meta$Treatment <- as.factor(samples_meta$Treatment)
samples_meta$Treatment <- relevel(samples_meta$Treatment, ref="NSC")
samples_meta$Group <- paste(samples_meta$Treatment_time,"_",samples_meta$Treatment,sep="")
#samples_meta$Differentiation_Age <- as.factor(samples_meta$Differentiation_Age)
samples_meta$Stimulation <- as.factor(samples_meta$Stimulation)
samples_meta$Stimulation <- relevel(samples_meta$Stimulation, ref="NSC")
samples_meta$Group_2 <- as.factor(samples_meta$Group_2)#
samples_meta$Group_2 <- relevel(samples_meta$Group_2, ref="WK1_NSC")

#quant_dirs <- list.dirs(quant_dir, full.names = TRUE, recursive = FALSE)
#quant_dirs_short <- list.dirs(quant_dir, full.names = FALSE, recursive = FALSE)

#quant_dirs_table <- data.table(Sample=quant_dirs_short, path=quant_dirs)
#quant_files_table <- data.table(Sample=quant_dirs_short, path=file_path)

#samples_meta_merged <- merge(samples_meta, quant_dirs_table, by.x="Sample_name", by.y= "Sample", all.x=T)

#samples_meta <- samples_meta_merged

```

-------------------------------

# Samples metadata

---------------------------------
```{r samples_overview, echo=FALSE, cache=T}
#samples_meta_merged <- as.data.frame(samples_meta_merged)
samples_meta_print <- subset.data.frame(samples_meta,select = c(Sample_ID,Replicate_2,Batch,Group,Group_2, Stimulation, Treatment_time))
#samples_meta_print <- samples_meta_print[, .(sample.id, sample.group_name,sample.genotype, sample.time,sample.gender, sample.rin, sample.3pbias)]
samples_meta_print %>% DT::datatable(caption="iPSC DaNS", escape=F)
#kable(samples_meta_print, caption =" LCM microglia and astrocytes SN of Control, AD and PD patients", escape = T, format="markdown", padding=2)
```

# Import Expression Data

* use tximport to import Kallisto counts for transcripts summarised as genes in to DESEQ2

* after aggregation of transcripts to genes, remove those genes with zero variance - i.e. no expression at all across samples


```{r test_t2g, eval=FALSE}

cat("Unique ensembl genes provided in transcript to gene mapping file: ", length(unique(t2g[, ens_gene])), fill=T)

```

```{r tximport_setup_1, include=F, eval=F}

if (in_type == "kallisto"){
  files_tximport <- paste0(samples_meta$path, "/", "abundance.h5")
} else {
  files_tximport <- paste0(samples_meta$path, "/", "quant.sf")
}
#only included protein coding genes
names(files_tximport) <- samples_meta[, "Sample_name"]
## txi <- tximport(files_tximport, type = tolower(in_type), tx2gene = t2g[, .(target_id, ens_gene)], reader = read_tsv)
txi <- tximport(files_tximport, type = in_type, tx2gene = t2g_genes[, .(target_id, gene)], txOut = F, countsFromAbundance = "no", ignoreTxVersion = F)

#txi_2 <- tximport(files_tximport, type = "salmon", tx2gene = t2g[, .(target_id, gene)], txOut = T, countsFromAbundance = "no")
#saveRDS(txi, file="tximport_kallisto3.rds")
```


# Import data into DESeq2

* Remove genes with less than 10 counts across atleast 3 samples (the total number of replicates per group)

```{r tximport_merge, echo=FALSE, eval=FALSE}
txi_1 = readRDS(file="./tximport_kallisto.rds")
txi_1$infReps <- NULL
txi_2 = readRDS(file="./tximport_kallisto3.rds")

abundance_temp <- txi_2$abundance
#keep <- c("WK1_R1_NSC","WK1_R2_NSC","WK1_R3_NSC", "WK1_R1_PD","WK1_R2_PD","WK1_R3_PD","WK2_R1_NSC","WK2_R2_NSC","WK2_R3_NSC","WK2_R1_PD","WK2_R2_PD","WK2_R3_PD")

#abundance_temp <- abundance_temp[,keep]
abundance_temp <- as.data.frame(abundance_temp)
setnames(abundance_temp, c("WK1_R1_NSC","WK1_R2_NSC","WK1_R3_NSC", "WK1_R1_PD","WK1_R2_PD","WK1_R3_PD","WK2_R1_NSC","WK2_R2_NSC","WK2_R3_NSC","WK2_R1_PD","WK2_R2_PD","WK2_R3_PD"), c("WK1_R7_NSC","WK1_R8_NSC","WK1_R9_NSC", "WK1_R7_PD","WK1_R8_PD","WK1_R9_PD","WK2_R7_NSC","WK2_R8_NSC","WK2_R9_NSC","WK2_R7_PD","WK2_R8_PD","WK2_R9_PD"))

abundance_temp <- as.matrix(abundance_temp)

txi_2$abundance <- abundance_temp

counts_temp <- txi_2$counts
#keep <- c("WK1_R1_NSC","WK1_R2_NSC","WK1_R3_NSC", "WK1_R1_PD","WK1_R2_PD","WK1_R3_PD","WK2_R1_NSC","WK2_R2_NSC","WK2_R3_NSC","WK2_R1_PD","WK2_R2_PD","WK2_R3_PD")

#counts_temp <- counts_temp[,keep]
counts_temp <- as.data.frame(counts_temp)
setnames(counts_temp, c("WK1_R1_NSC","WK1_R2_NSC","WK1_R3_NSC", "WK1_R1_PD","WK1_R2_PD","WK1_R3_PD","WK2_R1_NSC","WK2_R2_NSC","WK2_R3_NSC","WK2_R1_PD","WK2_R2_PD","WK2_R3_PD"), c("WK1_R7_NSC","WK1_R8_NSC","WK1_R9_NSC", "WK1_R7_PD","WK1_R8_PD","WK1_R9_PD","WK2_R7_NSC","WK2_R8_NSC","WK2_R9_NSC","WK2_R7_PD","WK2_R8_PD","WK2_R9_PD"))

counts_temp <- as.matrix(counts_temp)

txi_2$counts <- counts_temp


length_temp <- txi_2$length
#keep <- c("WK1_R1_NSC","WK1_R2_NSC","WK1_R3_NSC", "WK1_R1_PD","WK1_R2_PD","WK1_R3_PD","WK2_R1_NSC","WK2_R2_NSC","WK2_R3_NSC","WK2_R1_PD","WK2_R2_PD","WK2_R3_PD")

#length_temp <- length_temp[,keep]
length_temp <- as.data.frame(length_temp)
setnames(length_temp, c("WK1_R1_NSC","WK1_R2_NSC","WK1_R3_NSC", "WK1_R1_PD","WK1_R2_PD","WK1_R3_PD","WK2_R1_NSC","WK2_R2_NSC","WK2_R3_NSC","WK2_R1_PD","WK2_R2_PD","WK2_R3_PD"), c("WK1_R7_NSC","WK1_R8_NSC","WK1_R9_NSC", "WK1_R7_PD","WK1_R8_PD","WK1_R9_PD","WK2_R7_NSC","WK2_R8_NSC","WK2_R9_NSC","WK2_R7_PD","WK2_R8_PD","WK2_R9_PD"))

length_temp <- as.matrix(length_temp)

txi_2$length <- length_temp

txi_all <- Map(cbind,txi_1,txi_2)
rm(abundance_temp,length_temp,counts_temp,txi_1,txi_2)

saveRDS(txi_all, file = "Jan_Jun_21_NSC_all_treatment_tximport_kallisto.rds")


txi_all <- readRDS(file="./Jan_Jun_21_NSC_all_treatment_tximport_kallisto.rds")
samples_meta <- as.data.frame(samples_meta)
rownames(samples_meta) <- (samples_meta$Sample_ID)
samples_meta[ order(match(rownames(samples_meta), colnames(txi_all$counts))), ]

counts <- as.data.frame(txi_all$counts)


setcolorder(counts, rownames(samples_meta))

txi_all$counts <- as.matrix(counts)

abundance <- as.data.frame(txi_all$abundance)
setcolorder(abundance, rownames(samples_meta))

txi_all$abundance <- as.matrix(abundance)

length <- as.data.frame(txi_all$length)
setcolorder(length, rownames(samples_meta))
txi_all$length <- as.matrix(length)
saveRDS(txi_all, file = "Jan_Jun_21_NSC_all_treatment_tximport_kallisto.rds")

rm(abundance,length)
```


```{r deseq_setup, echo=FALSE}


txi_all <- readRDS(file="./Jan_Jun_21_NSC_all_treatment_tximport_kallisto.rds")


## if only protein coding genes are used:
## "transcripts missing genes: 56393"
stopifnot(all.equal(colnames(txi_all$counts), rownames(samples_meta)))
samples_meta$Batch <- as.factor(samples_meta$Batch)
samples_meta$Group_2 <- as.factor(samples_meta$Group_2)
samples_meta$Stimulation <- as.factor(samples_meta$Stimulation)
samples_meta$Treatment_time <- as.factor(samples_meta$Treatment_time)
dds <- DESeqDataSetFromTximport(txi_all, samples_meta, design = ~ Batch + Treatment_time + Stimulation + Treatment_time:Stimulation )
# using counts and average transcript lengths from tximport
# dds is now ready for DESeq() see DESeq2 vignette
# stores the rounded integers from txi$counts and tx lengths
# 2 assays: counts and avgTxLength
# NOTE: if tximport was run with countsFromAbundance as "scaledTPM" or "lengthScaledTPM", then only the counts are imported

cat("Assay names of DESeq dataset: ", assayNames(dds), fill=T)
cat("Number of genes and samples: ", dim(dds), fill=T)
cat("Number of genes with no read (estimated count) in any sample: ", sum(rowSums(counts(dds)) == 0), fill=T)
cat("Number of genes with exactly a count of 1 in a single sample (genes with row sum of 1): ", sum(rowSums(counts(dds)) == 1), fill=T)

## pre-filtering for low expression
cat("Expression threshold for exclusion of genes: ", expression_cutoff, fill=T)

if (pre_filter_type == "counts"){
  cat("Number of genes excluded: ", sum(rowSums(counts(dds) <= expression_cutoff ) <= 3), fill=T)
  keep <- rowSums(counts(dds) >= expression_cutoff) >= 3
  dds <- dds[keep, ]
} else if (pre_filter_type == "fpkm"){
  # Robust normalization is not used if average transcript lengths are present, which is the case here!
  # hence, raw counts are used here, and this is the basic calculation performed in fpm function:
  ## k <- counts(dds)
  ## library.sizes <- colSums(k)
  ## fpm_my <- 1e+06 * sweep(k, 2, library.sizes, "/")
  ## all.equal(fpm_test, fpm_my) # TRUE
  fpkm_robust <- DESeq2::fpkm(dds)
  cat("Number of genes excluded with less than 10 reads across a minimum of 3 samples: ", rowSums(fpkm_robust > expression_cutoff) < 3, fill=T)
  dds <- dds[rowSums(fpkm_robust > expression_cutoff) >= 3, ]
} else { stop("Unknown pre-filter type!")}


cat("Number of genes and samples after filtering: ", dim(dds), fill=T)

#expression_cutoff value =1 and to filter genes based on that based on RNA_seq workflow
# removing rows of the DESeqDataSet that have no counts, or only a single count across all samples
# DESEQ2 vignette suggests to use rowsums of counts >= 10 to keep

#dds <- dds[ rowSums(counts(dds)) >= 10, ]
#dim(dds)


dds <- estimateSizeFactors(dds)
sample_counts_norm <- counts(dds, normalized=T)
#colnames(sample_counts_norm) <- samples_meta$Sample_geo_accession
write.table(sample_counts_norm, file="Tofaris_Jan_June21_iPSC_DaNS_DESEQ2_counts_normalised_allsamples.txt", sep="\t", quote=F)
#sample_fpkm_robust <- DESeq2::fpkm(dds, robust = T)
#sample_fpkm_robust_log2_1 <- (log2(sample_fpkm_robust+1))
#write.table(sample_fpkm_robust_log2_1, file= "All_dis_chall_RNAseq_DESEQ2_microglia_fpkm_log2_1.txt", sep="\t",quote=F)
#write.table(samples_meta, file="GSE75431_sample_microglia_metadata.txt", sep="\t", quote=F)

```

# Exploratory Data analysis 1

+ Rlog transformation tends to works well on small datasets (n<30) and for datasets with veyr different sequencing depth across samples, using Blind=FALSE 
+ Corrected for Batch effect (June vs Jan study ) by usingComBat, with reference batch 
+ plot heatmaps and PCA plots on ComBat batch corrected rld data and preserving changes between samples by including Group as variable in the design matrix

```{r rlog_transform, include=FALSE}
# The function rlog returns an object based on the SummarizedExperiment class that contains the rlog-transformed values in its assay slot.
## slow
 rld <- rlogTransformation(dds, blind=FALSE)

# correct for batch effect

mm <- model.matrix(~ (Group) , colData(rld))
#limma_rld <- limma::removeBatchEffect(rlog_matrix, batch = rld$Batch,design = mm)

rlog_matrix <- assay(rld)

#mm <- model.matrix(~Group , colData(rld))
combat_rld <- sva::ComBat(rlog_matrix, batch = rld$Batch, mod =  mm, par.prior = T, prior.plots = F, ref.batch = 1)

assay(rld) <-combat_rld


#assay(rld) <-limma_rld
```

## Sample Clustering


```{r sample_distances, echo=FALSE}
sampleDists <- dist(t(combat_rld))
#sampleDists
```

### Heatmap (Rlog transformation)

 

```{r sample_clustering_1, echo=FALSE, fig.height=6}
library("pheatmap")
library("RColorBrewer")
sampleDistMatrix <- as.matrix( sampleDists )
rownames(sampleDistMatrix) <- paste(rld$Group_2,"_", rld$Batch, sep="")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         col = colors,clustering_method = "ward.D2")
```

### Heatmap (Poisson Distance)

* This measure of dissimilarity between counts also takes the inherent variance structure of counts into consideration when calculating the distances between samples. 
```{r poison_distance, echo=FALSE}
library("PoiClaClu")
poisd <- PoissonDistance(t(combat_rld))
```


```{r Poisson_clustering_2, echo=FALSE, fig.height=5}
samplePoisDistMatrix <- as.matrix( poisd$dd )
rownames(samplePoisDistMatrix) <- paste( dds$Group_2,"_",dds$Batch, sep="" )
colnames(samplePoisDistMatrix) <- NULL
pheatmap(samplePoisDistMatrix,
         clustering_distance_rows = poisd$dd,
         clustering_distance_cols = poisd$dd,
         col = colors, clustering_method = "ward.D2")
```

## PCA plots with Rlog transformation 

+ ComBat corrected data for Batch effect
+ Top 500 & Top 100 most variable genes and all genes


```{r PCA_rlog, fig.height=5,fig.width=8}

plot_data <- DESeq2::plotPCA(rld, intgroup =c("Replicate_2", "Group_2","Batch","Stimulation","Sample_ID"), returnData = T,ntop=500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by RLog transformation + ComBat corrected data:")
p <- ggplot(data = plot_data, aes(x=PC1, y=PC2, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC1 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC2 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p


col_vector <-  c("WK1" ="#7FBFF5","WK2"="#061B29" )

#rld$Group <- factor(rld$Group, levels = c("WK1_NSC", "WK1_PD", "WK1_MSA","WK1_Fibrils", "WK2_NSC","WK2_PD","WK2_MSA","WK2_Fibrils"))
plot_data <- DESeq2::plotPCA(rld, intgroup =c("Replicate_2", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T,ntop=1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by RLog transformation + ComBat corrected data :")
p <- ggplot(data = plot_data, aes(x=PC1, y=PC2, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.9, size=6, position = "jitter")  + scale_shape(solid = FALSE)
#p <- p + scale_color_manual(values = col_vector) + scale_shape_manual(values=c(1, 0, 2,5))
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5, point.padding = 0.5)
p <- p + xlab(paste0("PC1 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC2 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by RLog transformation") 
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p <- p + theme(axis.title = element_text(size=12, face="bold"))
p
#ggsave(filename = "PCA_1_2_top1000_HVG_v3.pdf",width = 5, height = 4)



cat("all genes by Rlog + Combat correction: ", dim(dds)[1])
plot_data <- DESeq2::plotPCA(rld, intgroup =c("Replicate", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

p <- ggplot(data = plot_data, aes(x=PC1, y=PC2, color=Group_2, shape= Batch))
p <- p + geom_point(alpha = 0.6, size=8, position = "jitter") 
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5, point.padding = 0.5)
p <- p + xlab(paste0("PC1 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC2 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p



```

## PCA plots PC 2-3

+ Top 500 & Top 100 most variable genes and all genes

```{r}
 plot_data <- plotPCA_higher_2_3(object = rld, intgroup =c("Replicate_2", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T, ntop = 500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC2, y=PC3, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=6)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC2 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC3 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p


col_vector <-  c("WK1" ="#7FBFF5","WK2"="#061B29" )

plot_data <- plotPCA_higher_2_3(object = rld, intgroup =c("Replicate", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T, ntop = 1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC2, y=PC3, color= Group_2, shape= Batch )) ## size = ?
p <- p + geom_point(alpha = 0.9, size=6, position="jitter") 
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5, point.padding = 0.5) 
#+ scale_shape_manual(values=c(1, 0, 2,5))
#p <- p + scale_color_manual(values = col_vector)
p <- p + xlab(paste0("PC2 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC3 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p <- p + theme(axis.title = element_text(size=12, face="bold"))
p
#ggsave(filename = "PCA_2_3_top1000_HVG_v3.pdf",width = 5, height = 4)




plot_data <- plotPCA_higher_2_3(object = rld, intgroup =c("Replicate", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("All genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC2, y=PC3, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=6)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC2 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC3 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p
```


## PCA plots PC 3-4


```{r}
 plot_data <- plotPCA_higher_3_4(object = rld, intgroup =c("Replicate_2", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T, ntop = 500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC3, y=PC4, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=6)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC3 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC4 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_3_4(object = rld, intgroup =c("Replicate_2", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T, ntop = 1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC3, y=PC4, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=6)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC3 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC4 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_3_4(object = rld, intgroup =c("Replicate_2", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("All genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC3, y=PC4, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=6)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC3 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC4 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p
```


## PCA plots PC 5-6


```{r}
plot_data <- plotPCA_higher_5_6(object = rld, intgroup =c("Replicate_2", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T, ntop = 500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC5, y=PC6, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=6)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC5 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC6 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_5_6(object = rld, intgroup =c("Replicate_2", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T, ntop = 1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC5, y=PC6, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=6)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC5 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC6 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_5_6(object = rld, intgroup =c("Replicate_2", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("All genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC5, y=PC6, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=6)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC5 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC6 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p
```



# Exploratory Data analysis 2

+ VST transformation tends to works well on large datasets (n>30) 
+ Corrected for Batch effect (June vs Jan study ) by using ComBat from the sva package witth Group_2 in the design matrix and reference batch as group 1
+ plot heatmaps and PCA plots on ComBat batch corrected rlog transformed data as vst transformation doesnt correct for batch as well as rlog does

```{r , include=T}
library(sva)
# The function rlog returns an object based on the SummarizedExperiment class that contains the rlog-transformed values in its assay slot.
## slow
#design(dds) <- formula(~Batch + Group)
 vsd <- vst(dds, blind= FALSE)

# correct for batch effect
vst_matrix <- assay(vsd)
mm <- model.matrix(~Group_2 , colData(vsd))
combat_vsd <- sva::ComBat(vst_matrix, batch = vsd$Batch, mod =  mm, ref.batch = 1)

assay(vsd) <-combat_vsd
```

## Sample Clustering


```{r , echo=FALSE}
sampleDists <- dist(t(combat_vsd))
#sampleDists
```

### Heatmap (vst transformation)

 

```{r sample_clustering_2, echo=FALSE, fig.height=6}
library("pheatmap")
library("RColorBrewer")
sampleDistMatrix <- as.matrix( sampleDists )
rownames(sampleDistMatrix) <- paste(vsd$Group_2,"_", vsd$Batch, sep="")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         col = colors,clustering_method = "ward.D2")
```

### Heatmap (Poisson Distance)

* This measure of dissimilarity between counts also takes the inherent variance structure of counts into consideration when calculating the distances between samples. 
```{r poison_distance_2, echo=FALSE}
library("PoiClaClu")
poisd <- PoissonDistance(t(combat_vsd))
```


```{r Poisson_clustering_3, echo=FALSE, fig.height=5}
samplePoisDistMatrix <- as.matrix( poisd$dd )
rownames(samplePoisDistMatrix) <- paste( dds$Group_2,"_",dds$Batch, sep="" )
colnames(samplePoisDistMatrix) <- NULL
pheatmap(samplePoisDistMatrix,
         clustering_distance_rows = poisd$dd,
         clustering_distance_cols = poisd$dd,
         col = colors, clustering_method = "ward.D2")
```

## PCA plots with vst transformation 

+ sva::Combat corrected data for Batch effect

+ Top 500 & Top 100 most variable genes and all genes


```{r PCA_vst, fig.height=5,fig.width=8}

plot_data <- DESeq2::plotPCA(vsd, intgroup =c("Replicate", "Group_2","Batch","Stimulation","Sample_ID"), returnData = T,ntop=500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by VST transformation:")
p <- ggplot(data = plot_data, aes(x=PC1, y=PC2, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC1 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC2 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by VST transformation + Combat correction ")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p


col_vector <-  c("WK1" ="#7FBFF5","WK2"="#061B29" )

#rld$Group <- factor(rld$Group, levels = c("WK1_NSC", "WK1_PD", "WK1_MSA","WK1_Fibrils", "WK2_NSC","WK2_PD","WK2_MSA","WK2_Fibrils"))
plot_data <- DESeq2::plotPCA(vsd, intgroup =c("Replicate", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T,ntop=1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by VST transformation:")
p <- ggplot(data = plot_data, aes(x=PC1, y=PC2, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.9, size=6, position = "jitter")  + scale_shape(solid = FALSE)
#p <- p + scale_color_manual(values = col_vector) + scale_shape_manual(values=c(1, 0, 2,5))
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5, point.padding = 0.5)
p <- p + xlab(paste0("PC1 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC2 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by VST transformation + Combat Correction") 
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p <- p + theme(axis.title = element_text(size=12, face="bold"))
p
#ggsave(filename = "PCA_1_2_top1000_HVG_v3.pdf",width = 5, height = 4)



cat("all genes: ", dim(dds)[1])
plot_data <- DESeq2::plotPCA(vsd, intgroup =c("Replicate", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

p <- ggplot(data = plot_data, aes(x=PC1, y=PC2, color=Group_2, shape= Batch))
p <- p + geom_point(alpha = 0.6, size=8, position = "jitter") 
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC1 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC2 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by VST transformation + Combat correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p



```



## PCA plots PC 2-3

+ Top 500 & Top 100 most variable genes and all genes

```{r}
 plot_data <- plotPCA_higher_2_3(object = vsd, intgroup =c("Replicate", "Group_2","Sample_ID","Treatment","Batch"), returnData = T, ntop = 500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by vst transformation + ComBat correction :")
p <- ggplot(data = plot_data, aes(x=PC2, y=PC3, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC2 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC3 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by vst transformation + Combat Correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p


col_vector <-  c("WK1" ="#7FBFF5","WK2"="#061B29" )

plot_data <- plotPCA_higher_2_3(object = vsd, intgroup =c("Replicate", "Group_2","Sample_ID","Treatment","Batch"), returnData = T, ntop = 1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by vst transformation + ComBat correction:")
p <- ggplot(data = plot_data, aes(x=PC2, y=PC3, color= Group_2, shape= Batch )) ## size = ?
p <- p + geom_point(alpha = 0.9, size=6, position="jitter") 
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5, point.padding = 0.5) 
#+ scale_shape_manual(values=c(1, 0, 2,5))
#p <- p + scale_color_manual(values = col_vector)
p <- p + xlab(paste0("PC2 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC3 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by vst transformation + ComBat correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p <- p + theme(axis.title = element_text(size=12, face="bold"))
p
#ggsave(filename = "PCA_2_3_top1000_HVG_v3.pdf",width = 5, height = 4)




plot_data <- plotPCA_higher_2_3(object = vsd, intgroup =c("Replicate", "Group_2","Sample_ID","Treatment","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("All genes by vsd transformation + ComBat correction:")
p <- ggplot(data = plot_data, aes(x=PC2, y=PC3, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC2 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC3 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by vst transformation + ComBat Correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p
```


## PCA plots PC 3-4


```{r}
 plot_data <- plotPCA_higher_3_4(object = vsd, intgroup =c("Replicate", "Group_2","Sample_ID","Treatment","Batch"), returnData = T, ntop = 500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by vst transformation + ComBat correction:")
p <- ggplot(data = plot_data, aes(x=PC3, y=PC4, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC3 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC4 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_3_4(object = vsd, intgroup =c("Replicate", "Group_2","Sample_ID","Treatment","Batch"), returnData = T, ntop = 1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by vst transformation + ComBat Correction:")
p <- ggplot(data = plot_data, aes(x=PC3, y=PC4, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC3 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC4 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by vst transformation + Combat correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_3_4(object = vsd, intgroup =c("Replicate", "Group_2","Sample_ID","Treatment","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("All genes by vst transformation + ComBat correction:")
p <- ggplot(data = plot_data, aes(x=PC3, y=PC4, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC3 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC4 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by vst transformation + ComBat correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p
```


## PCA plots PC 5-6


```{r}
plot_data <- plotPCA_higher_5_6(object = vsd, intgroup =c("Replicate", "Group_2","Sample_ID","Treatment","Batch"), returnData = T, ntop = 500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by vst transformation + ComBat correction:")
p <- ggplot(data = plot_data, aes(x=PC5, y=PC6, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC5 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC6 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by vst transformation + Combat Correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_5_6(object = vsd, intgroup =c("Replicate", "Group_2","Sample_ID","Treatment","Batch"), returnData = T, ntop = 1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by vst transformation + ComBat correction:")
p <- ggplot(data = plot_data, aes(x=PC5, y=PC6, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC5 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC6 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by vst transformation + ComBat correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_5_6(object = vsd, intgroup =c("Replicate", "Group_2","Sample_ID","Treatment","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("All genes by vst transformation + ComBat Correction:")
p <- ggplot(data = plot_data, aes(x=PC5, y=PC6, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC5 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC6 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by vst transformation + ComBat Correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p
```

## PCA correlation with covariates 

 + correlation of PCAs with multiple metadata covariates
 + using  ComBat batch corrected Rlog transformed data (as better in correcting batche effect than vst)  and top 1000 HVG
 
```{r, fig.height=6, fig.width=10}



  ntop = 1000
  rv <- rowVars(assay(rld))
  rowSel <- order(rv, decreasing = T)[seq_len(ntop)]
  pca <- prcomp(t(assay(rld)[rowSel, ]))
  percentVar <- pca$sdev^2 / sum(pca$sdev^2)
   #attach PCs to metadata
  pc.df <- pca$x %>% 
    as.data.frame() %>% 
    rownames_to_column(var = "sample")
  samples_meta <- inner_join(samples_meta, pc.df, by = c( "Sample_ID" = "sample"))
  meta <- samples_meta %>% 
    dplyr::select( -Clone, -Species, -Tissue_type,-Group, -Group_2,-Replicate_2)
  
  #column names by variable type
  facCols <- meta %>% 
    dplyr::select_if(is.factor) %>%
    colnames()

  pcCols <- meta %>%
    dplyr::select(starts_with("PC")) %>%
    colnames()

  #factor correlations
  facCor.df <- expand.grid(pcCols, facCols) 

  rsquared <- facCor.df %>%
    apply(1, function(x) reformulate(x[2], x[1])) %>%
    lapply(., lm, data = meta) %>%
    map(summary) %>%
    map_dbl("r.squared")

  facCor.df$corr <- sqrt(rsquared)

  facCor.df <- facCor.df %>%
    dplyr::rename(PC = Var1, covariate = Var2) %>%
    mutate(type = "lm")

  #numeric correlations
  numCor.df <- meta %>%
    dplyr::select_if(is.numeric) %>%
    correlate(method = "kendall") %>%
    focus(-matches("^PC")) %>%
    gather(variable, corr, 2:4) %>%
    mutate(type = "kendall") %>%
    dplyr::rename(PC = term, covariate = variable)

   #combine
  pcaBar <- bind_rows(numCor.df, facCor.df)

  #filter sample and sex
  #pcaBar <- pcaBar %>%
   # filter( ! (covariate %in% c("sample", "sex")))

  #add percent variation
  pcs <- paste("PC", 1:6, sep = "")
  percentVar <- percentVar[1:6]
  pvar <- data.frame( PC = pcs, perVar = paste(pcs, " (", sprintf("%.2f", percentVar * 100), "%)", sep = ""))
  pcaBar <- inner_join(pcaBar, pvar)

  #arrange
  pcaBar <- pcaBar %>%
    group_by(PC) %>%
    arrange(corr) %>%
    unite("pcvar", PC, covariate, sep = "_", remove = F) %>%
    data.frame() %>%
    mutate(pcvar = factor(pcvar))

```
 

### PCA correlation bar plot

 
```{r, fig.height= 5, fig.width=9 }
 # PCA correlation barplot
  pcaBar %>%
    group_by(PC) %>%
    ggplot(aes(x = pcvar, y = corr)) +
    geom_col(aes(fill = type)) +
    coord_flip() + 
    facet_wrap( ~ perVar, scale = "free_y") +
    xlab("metadata") +
    ylab("correlation") +
    scale_x_discrete(breaks = pcaBar$pcvar, labels = pcaBar$covariate) +
    scale_y_continuous(limits = c(-1, 1)) +
    scale_fill_manual(values = c("darkorange", "dodgerblue")) 
```

### PCA correlation heatmap

```{r,fig.height=4, fig.width=6}
pcaBar %>%
    ggplot(aes(x = covariate, y = perVar, fill=corr)) +
    geom_tile() + scale_fill_distiller(direction=-1, palette = "RdYlBu", limits= c(min(pcaBar$corr),1))+theme(axis.text.x =  element_text(angle = 45, vjust = 1, hjust = 1)) + ylab("") + xlab("") +  labs(fill='correlation') 
#ggsave(filename="PCA_covariates_corrleation_heatmap.tiff", width=6,height = 4, units = "in", dpi = 300)
```


## PCA plot using Generalised PCA
+ takes raw count matrix and number of latent dimensions (2 dimensions)
+ We can see that without ComBat batch correction, the PCA is driven by batch seperation

```{r}
library(glmpca)
gpca <- glmpca(counts(dds), L=2)
gpca.dat <- gpca$factors
gpca.dat$Treatment <- dds$Treatment
gpca.dat$Treatment_time <- dds$Treatment_time
gpca.dat$Group_2 <- dds$Group_2
gpca.dat$Batch <- dds$Batch
gpca.dat$Sample_name <- dds$Sample_ID
```

```{r, fig.height=4, fig.width =7}
ggplot(gpca.dat, aes(x = dim1, y = dim2, color = Group_2, shape = Batch)) + geom_text_repel(aes(label=Sample_name), size=2.5) +
  geom_point(size =3) + ggtitle("glmpca - Generalized PCA") + coord_fixed()
```

# Differential Expression 


* design " ~ Batch + Treatment_time + Stimulation + TreatmentTime:Stimulation



```{r}
## Week1: Treatments vs NSC
design(dds) <- formula(~ Batch + Treatment_time + Stimulation + Treatment_time:Stimulation)

# visulaise themodel matrix
mod_mat <- model.matrix(design(dds), colData(dds))
mod_mat

```

## Differential Expression : : PD vs NSC (WK1)

+ contrasts of interest: Stimulation_Aggregate_vs_NSC
* DEG log2FC threshold = 0 and FDR 5%


```{r}

dds <- DESeq(dds, parallel = T,betaPrior = FALSE, test = "Wald") # calculate LFC shrink afterwards using lfcshrink
#res_diffage <- results(dds)
#res_diffage
#mcols(res_diffage)
resultsNames(dds) 
# Will have to relevel Group to "WK2_NSC" for Week2 compariosns
```




```{r}

res_WK1_Agg_NSC <- results(object=dds ,contrast = list(c("Stimulation_Aggregate_vs_NSC")) , lfcThreshold = 0, alpha=0.05)
 mcols(res_WK1_Agg_NSC)$description
 res_summary <- capture.output(summary(res_WK1_Agg_NSC))
 cat(res_summary, sep="  \n* ")
 
 # number of differentially expressed genes based on cut off
 
 num_DEG <- sum(res_WK1_Agg_NSC$padj < alpha_cutoff & abs(res_WK1_Agg_NSC$log2FoldChange) >= 0, na.rm=TRUE)
    cat("  \n* Genes with adjusted P-value not NA (universe of genes): ", sum(!is.na(res_WK1_Agg_NSC$padj)))
    cat("  \n* Differentially expressed genes with log2FC >= 0.50 & p.adjusted <0.05: ", num_DEG, "  \n")
resOrdered_WK1_Agg_NSC <- res_WK1_Agg_NSC[order(res_WK1_Agg_NSC$padj),]
resOrdered_WK1_Agg_NSC <- as.data.frame(resOrdered_WK1_Agg_NSC )
#write.table(as.data.frame(resOrdered_WK1_PD_NSC), file = paste0("deseq2_results_","WK1_PD_vs._NSC",".txt"), sep="\t", quote=F)
```

### MA-plot

```{r}
res_WK1_Agg_NSC_LFCshrink <- lfcShrink(dds = dds , contrast = list(c("Stimulation_Aggregate_vs_NSC")) ,type="ashr")
DESeq2::plotMA(res_WK1_Agg_NSC_LFCshrink, ylim = c(-20,20))
resOrdered_WK1_Agg_NSC_LFCshrink <- res_WK1_Agg_NSC_LFCshrink[order(res_WK1_Agg_NSC_LFCshrink$padj),]
resOrdered_WK1_Agg_NSC_LFCshrink  <- as.data.frame(resOrdered_WK1_Agg_NSC_LFCshrink )
```

### Dispersion plot

```{r, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
plotDispEsts(dds)
```


### Table of DEG

```{r}
top_genes <- 20

 #prnt table of up and down regulated genes from DEG
    
res_print_WK1_Agg_NSC <- print_DESeq_table(resOrdered_WK1_Agg_NSC_LFCshrink, t2g_info = t2g_genes, alpha_level = alpha_cutoff,logfcthreshold = 0)


    
    plot_up_genes <- res_print_WK1_Agg_NSC[fc == "up", target_id][1:top_genes]
    plot_up_genes <- plot_up_genes[!(is.na(plot_up_genes))] # if there are not top_genes DEGs, NA values will be returned
    plot_down_genes <-res_print_WK1_Agg_NSC[fc == "down", target_id][1:top_genes]
    plot_down_genes <- plot_down_genes[!(is.na(plot_down_genes))]
  
    
    
  res_print_WK1_Agg_NSC <- res_print_WK1_Agg_NSC[, gene_type := NULL] ## only protein coding genes
   res_print_WK1_Agg_NSC <- res_print_WK1_Agg_NSC[, target_id := NULL] ## remove "symbol - ensembl_ID"
    
    setnames(res_print_WK1_Agg_NSC, "desc", "___________long_gene_description___________")
   res_print_WK1_Agg_NSC <- res_print_WK1_Agg_NSC %>% drop_na()
```



```{r, fig.height=6}
res_print_WK1_Agg_NSC %>% DT::datatable(caption=" WK1: Aggregate vs NSC", escape=F, extensions = 'Buttons', options = list(dom = 'Blfrtip', buttons = list('colvis', list(extend = 'copy', exportOptions = list(columns=':visible')), list(extend = 'csv', exportOptions = list(columns=':visible')), list(extend = 'excel', exportOptions = list(columns=':visible')))))
```


### Count Plots of Top genes


 plot normalised counts for DEG for different groups

```{r, echo=F}
my_plot_counts <- function(obj, plot_genes=NULL, intgroup_vec=c("Group_2", "Replicate_2", "Batch","Treatment"), t2g_info=NULL, n_ncol=4, n_nrow =6, title=NULL){

  # collect data for each gene
  plot_data_all <- as.data.table(plotCounts(obj, gene = plot_genes[1], intgroup_vec, returnData=TRUE,transform = F, replaced = F))
  plot_data_all[, gene := plot_genes[1]]
  plot_data_all[, gene_idx := formatC(1,width=2,flag='0')]
  
  if (length(plot_genes) >= 2){
    for (i in 2:length(plot_genes)){
      
      plot_data <- as.data.table(plotCounts(obj, gene = plot_genes[i], intgroup_vec, returnData=TRUE,transform = F))
      plot_data[, gene := plot_genes[i]]
      plot_data[, gene_idx := formatC(i,width=2,flag='0')]
      plot_data_all <- rbind(plot_data_all, plot_data)
    }
  }
  
  plot_data_all <- merge(plot_data_all, t2g_info[, .(gene, ext_gene)], by.x="gene", by.y="gene")
  # plot_data_all[, gene_print := paste0(gene_idx, "  ", gene, "  ", ext_gene)]
  # plot_data_all[, gene_print := paste0(gene_idx, "  ", gene)]
  plot_data_all[, gene_print := paste0(gene_idx, "  ", ext_gene)] ## use only gene symbol as facet title
  plot_data_all <- plot_data_all %>% filter( Group_2 == c("WK1_NSC","WK1_Aggregate"))
  p <- ggplot(data = plot_data_all, aes(x=Group_2, y=log2(count+1), colour=Group_2, shape=Treatment))
  p <- p + geom_violin(aes(group=Group_2), alpha = 0, colour = "gray60", scale="width")
  ## p <- p + ggbeeswarm::geom_quasirandom(alpha = 0.6, size = 3, groupOnX = TRUE)
  p <- p + geom_point(position = position_jitterdodge(), size=5, alpha=0.6)
  p <- p + xlab(NULL)
  p <- p + facet_wrap(~gene_print, ncol=n_ncol, scales="free_y",nrow = n_nrow)
  p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
  p <- p + ylab("log2(normalised count + 1)") + theme(legend.position="top")
  p <- p + theme(axis.text.x=element_text(angle=90, hjust=1, size=10)) + theme(axis.text.y = element_text(size=8))
  p <- p + ggtitle(title)
  p
}

```

 UP Genes

```{r, echo=FALSE, fig.height=10, fig.width=10}
p <-my_plot_counts(dds, plot_genes = plot_up_genes,title="upregulated genes in WK1 Aggregate vs NSC", t2g_info = t2g_genes, n_ncol = 4)
p
```
 Down genes

```{r, echo=FALSE, fig.height=9, fig.width=10}
my_plot_counts(dds, plot_genes = plot_down_genes,title="downregulated genes in WK1: Aggregate vs NSC", t2g_info = t2g_genes, n_ncol=5)
```

  PD genes that are significant

+ none were significant

```{r,echo=FALSE, fig.height=4, fig.width=9, eval=F}
control_genes <- c("OPA1 - ENSG00000198836","MFN1 - ENSG00000171109","TOMM20 - ENSG00000173726","DNM1L - ENSG00000087470","TFAM - ENSG00000108064","NRF1 - ENSG00000106459","NFE2L2 - ENSG00000116044","MTOR - ENSG00000198793","HIF1A - ENSG00000100644","ARNT - ENSG00000143437","SNCA - ENSG00000145335","PARK7 - ENSG00000116288","OMA1 - ENSG00000162600","MFN1 - ENSG00000171109")

#t2g_genes_control <- t2g_genes %>% filter(gene %in% control_genes) %>% select(gene)
control_genes_sig <- resOrdered_WK1_Agg_NSC %>% filter(rownames(.) %in% control_genes & padj<0.05 )
my_plot_counts(dds, plot_genes = rownames(control_genes_sig),title="interesting significant PD genes", t2g_info = t2g_genes)
#PGC-1alpha = ENSG00000109819
# OMA1 - ENSG00000162600
# OPA1 - ENSG00000198836
# MFN1 - ENSG00000171109
# TOM20 - ENSG00000173726
# DNM1L - ENSG00000087470
# TFAM - ENSG00000108064
# NRF1 - ENSG00000106459
# NFE2L2 -  ENSG00000116044
# TFEB - ENSG00000112561
# MTOR - ENSG00000198793
# HIF1a - ENSG00000100644
# HIF1b -  ENSG00000143437
#SNCA - ENSG00000145335
# PARK7 - ENSG00000116288
```




```{r,echo=FALSE}

# Get ENSEMBLE IDS

resOrdered_WK1_Agg_NSC_LFCshrink$gene <- rownames(resOrdered_WK1_Agg_NSC_LFCshrink)
resOrdered_WK1_Agg_NSC_LFCshrink_ens <- merge(resOrdered_WK1_Agg_NSC_LFCshrink, t2g_genes, by.all ="gene")
rownames(resOrdered_WK1_Agg_NSC_LFCshrink_ens) <- resOrdered_WK1_Agg_NSC_LFCshrink_ens$ens_gene
rm(resOrdered_WK1_Agg_NSC_LFCshrink)
resOrdered_WK1_Agg_NSC_LFCshrink_ens <- resOrdered_WK1_Agg_NSC_LFCshrink_ens[,c(1:7,11)]

# get rid of NAs for clusterprofiler
#library(tidyr)
resOrdered_WK1_Agg_NSC_LFCshrink_ens <- resOrdered_WK1_Agg_NSC_LFCshrink_ens %>% drop_na()

# map ids using annotation db
library(org.Hs.eg.db)
library(AnnotationDbi)

resOrdered_WK1_Agg_NSC_LFCshrink_ens$entrez <- mapIds(org.Hs.eg.db, keys= rownames(resOrdered_WK1_Agg_NSC_LFCshrink_ens), column = "ENTREZID", keytype = "ENSEMBL", multiVals = "first")
resOrdered_WK1_Agg_NSC_LFCshrink_ens$symbol <- mapIds(org.Hs.eg.db, keys= rownames(resOrdered_WK1_Agg_NSC_LFCshrink_ens), column = "SYMBOL", keytype = "ENSEMBL", multiVals = "first")
write.table(resOrdered_WK1_Agg_NSC_LFCshrink_ens, file="deseq2_results_Jan_Jun21_WK1_Aggregate_vs WK1_NSC.txt", sep="\t", quote=F)


```

### Volcano plot 

```{r, fig.height=5, fig.width=7}
library(EnhancedVolcano)
 Vol <- EnhancedVolcano(resOrdered_WK1_Agg_NSC_LFCshrink_ens,
    lab = resOrdered_WK1_Agg_NSC_LFCshrink_ens$symbol,
    x = 'log2FoldChange',
    y = 'pvalue', subtitle = "", title = "WK1 Aggregate vs WK1 NSC", xlim = c(-15,20), labSize =3, FCcutoff = 0.2, axisLabSize = 6, titleLabSize = 8, legendLabSize = 6, pCutoff = 0.05,pCutoffCol = 'padj', drawConnectors = F, captionLabSize = 6,
    widthConnectors = 0.2, colConnectors = 'grey30',caption = "Log2FC cutoff = 0.2; p-value cutoff= 0.05" )
 #Vol <-   Vol +  ggplot2::coord_cartesian(xlim=c(-10, 8))  + ggplot2::scale_x_continuous(breaks=seq(-10,8, 2))
 Vol
```



### Gene Ontology Over-representation analysis
+ GO Biological Process
+ genes used : p.adj < 0.05 and log2FC >= 0


```{r, eval=T}

 
 # Done all DEG with p.adj <0.05 , no logFC threshold applied

library(clusterProfiler)

resOrdered_WK1_Agg_NSC_LFCshrink_ens_sig <- resOrdered_WK1_Agg_NSC_LFCshrink_ens %>% filter(padj < 0.05 & abs(log2FoldChange) >= 0) 

#geneChangeList <- resOrdered_Parent_stim_control_LFCshrink_ens_sig$log2FoldChange
geneChangeList <- unique(rownames(resOrdered_WK1_Agg_NSC_LFCshrink_ens_sig))
#geneChangeList <- sort(geneChangeList, decreasing=TRUE)
#desiredGeneChangeList <- names(geneChangeList)[abs(geneChangeList) >1] 
 all_genes <- as.character(unique(rownames(resOrdered_WK1_Agg_NSC_LFCshrink_ens)))

enrichGOResult_1 <- enrichGO(gene = geneChangeList, OrgDb = org.Hs.eg.db, keyType = 'ENSEMBL', ont = "BP", pAdjustMethod = "BH", universe=all_genes, readable = T)
enrichGOResult_1_s <- simplify(enrichGOResult_1, cutoff=0.8)
```


#### GO BP over-representation test

```{r, eval=T}

scorePlot <- RScorePlot_v2(enrichGOResult_1_s, resOrdered_WK1_Agg_NSC_LFCshrink_ens, showCategory = 20, textSize = 9, title = "" ) + theme(title = element_text(size=8), axis.text = element_text(size=8)) + ggtitle("GO BP terms for WK1: Aggregate vs NSC")
plot(scorePlot)
```

#### Reactome Pathways

```{r, eval=T}

library(ReactomePA)
# only takes entrez id
geneChangeList <- unique(resOrdered_WK1_Agg_NSC_LFCshrink_ens_sig$entrez)
#geneChangeList <- sort(geneChangeList, decreasing=TRUE)
#desiredGeneChangeList <- names(geneChangeList)[abs(geneChangeList) >1] 
 all_genes <- as.character(unique(resOrdered_WK1_Agg_NSC_LFCshrink_ens$entrez))
enrich_Reactome <-  enrichPathway(gene = geneChangeList, pAdjustMethod = "BH", universe=all_genes, readable = T, organism = "human")
scorePlot <- RScorePlot_v2(enrich_Reactome, resOrdered_WK1_Agg_NSC_LFCshrink_ens, showCategory = 25, textSize = 9, title = "" ) + theme(title = element_text(size=8)) +ggtitle("Reactome terms for WK1 : Aggregate vs NSC")
plot(scorePlot)
```


```{r, echo=FALSE, message=FALSE, warning=FALSE}
# from https://stephenturner.github.io/deseq-to-fgsea/
# symbol here comes from map ids. it is possible that 2 ensgs map to the same symbol! this creates duplicates in the stat data frame and is removed using distinct
library(fgsea)
gsea_res_WK1_Agg_NSC <- resOrdered_WK1_Agg_NSC_LFCshrink_ens %>% dplyr::select(symbol,log2FoldChange) %>% na.omit() %>% distinct() %>% group_by(symbol) %>% summarize(log2FoldChange=mean(log2FoldChange))
# dim(gsea_res)
# head(gsea_res)

# fast Gene Set Enrichment Analysis
ranks<- deframe(gsea_res_WK1_Agg_NSC)

```

### GSEA Reactome Pathways

```{r}
pathways.reactome <- gmtPathways("../genesets/c2.cp.reactome.v7.4.symbols.gmt")
fgsea_reactome <- fgseaMultilevel(pathways=pathways.reactome, stats=ranks, nPermSimple = 20000, maxSize = 500, minSize = 30)
# convert to tibble, sort by NES and select columns
fgsea_reactome_tidy <- fgsea_reactome %>% as_tibble() %>% arrange(padj) %>% dplyr::select(-pval, -ES)
# Show in a nice table:
fgsea_reactome_tidy %>% DT::datatable()
```





### Top 15 up and down regulated Reactome pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowd pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_reactome_up <- fgsea_reactome[ES > 0][size < 300][order(padj,-NES),pathway][1:15]
top_reactome_dn <- fgsea_reactome[ES < 0][size < 300][order(padj,NES),pathway][1:15]
top_reactome <- c(top_reactome_up, rev(top_reactome_dn))
plotGseaTable(pathways.reactome[top_reactome], ranks, fgsea_reactome, gseaParam = 0.5)
fgsea_reactome_tidy_top <- fgsea_reactome_tidy %>% filter(pathway %in% top_reactome)
```


```{r, fig.width=12}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_reactome_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down Reactome pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=8))+theme(plot.title = element_text(size=7))
p1

```

### Enrichments plots for top Reactome hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.reactome[[top_reactome_up[i]]], ranks) + labs(title=top_reactome_up[i]))
}
```


### Leading Edge heatmaps for top Reactome hits

Heatmap of row normalised rld regularised leg transformed size factor normalised read counts

```{r, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
norm_counts <- as.data.frame(assay(rld))
norm_counts <- norm_counts %>% rownames_to_column(var="gene")
norm_counts_Ens <- merge(norm_counts, t2g_genes[,c(4,9)], by.all="gene")
ens2symbol <- AnnotationDbi::select(org.Hs.eg.db, key=norm_counts_Ens$ens_gene, columns="SYMBOL", keytype="ENSEMBL", multiVals="first") %>% distinct()
ens2symbol$gene <- paste(ens2symbol$ENSEMBL,"-",ens2symbol$SYMBOL,sep="")
ens2symbol <- as_tibble(ens2symbol)
norm_counts_Ens <- norm_counts_Ens %>% column_to_rownames(var= "ens_gene") %>% dplyr::select(-gene)
norm_counts_Ens_WK1 <- norm_counts_Ens %>%  dplyr::select(starts_with("WK1"))

```

```{r, eval=T, fig.height=8, fig.width=10}
top_reactome_up_full <- fgsea_reactome[ES > 0][size < 250][order(padj,-NES),][1:5]

for (i in 1:5) {
  # Full pathway
  # print(pathways.reactome[[top_reactome_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_reactome_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens_WK1[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens_WK1)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  pheatmap(gene_counts_rownorm, col = colors, main=top_reactome_up_full[i,pathway])
 }
  
```


### GSEA KEGG Pathways

```{r}
pathways.kegg <- gmtPathways("../genesets/c2.cp.kegg.v7.4.symbols.gmt")
fgsea_kegg <- fgseaMultilevel(pathways=pathways.kegg, stats=ranks, nPermSimple = 10000, maxSize = 500, minSize = 30)
# convert to tibble, sort by NES and select columns
fgsea_kegg_tidy <- fgsea_kegg %>% as_tibble() %>% arrange(padj) %>% dplyr::select(-pval, -ES)
# Show in a nice table:
fgsea_kegg_tidy %>% DT::datatable()
```




### Top 15 up and down regulated KEGG pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowd pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_kegg_up <- fgsea_kegg[ES > 0][size < 250][order(padj,-NES),pathway][1:15]
top_kegg_dn <- fgsea_kegg[ES < 0][size < 250][order(padj,NES),pathway][1:15]
top_kegg <- c(top_kegg_up, rev(top_kegg_dn))
plotGseaTable(pathways.kegg[top_kegg], ranks, fgsea_kegg, gseaParam = 0.5)
fgsea_kegg_tidy_top <- fgsea_kegg_tidy %>% filter(pathway %in% top_kegg)
```


```{r, fig.width=10}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_kegg_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down KEGG pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=8))+theme(plot.title = element_text(size=7), legend.title = element_text(size=10))
p1

```

### Enrichments plots for top KEGG hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.kegg[[top_kegg_up[i]]], ranks) + labs(title=top_kegg_up[i]))
}
```




### Leading Edge heatmaps for top KEGG hits

Heatmap of row noemalised rld regularised leg transformed size factor normalised read counts

```{r, echo=FALSE, message=FALSE, warning=FALSE}
norm_counts <- as.data.frame(assay(rld))
norm_counts <- norm_counts %>% rownames_to_column(var="gene")
norm_counts_Ens <- merge(norm_counts, t2g_genes[,c(4,9)], by.all="gene")
ens2symbol <- AnnotationDbi::select(org.Hs.eg.db, key=norm_counts_Ens$ens_gene, columns="SYMBOL", keytype="ENSEMBL", multiVals="first") %>% distinct()
ens2symbol$gene <- paste(ens2symbol$ENSEMBL,"-",ens2symbol$SYMBOL,sep="")
ens2symbol <- as_tibble(ens2symbol)
norm_counts_Ens <- norm_counts_Ens %>% column_to_rownames(var= "ens_gene") %>% dplyr::select(-gene)
norm_counts_Ens_WK1 <- norm_counts_Ens %>%  dplyr::select(starts_with("WK1"))

```

```{r, eval=T, fig.height=9}
top_kegg_up_full <- fgsea_kegg[ES > 0][size < 250][order(padj,-NES),][1:6]

for (i in 1:6) {
  # Full pathway
   #print(pathways.kegg[[top_kegg_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_kegg_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens_WK1[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens_WK1)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  pheatmap(gene_counts_rownorm, col = colors, main=top_kegg_up_full[i,pathway])
 }
  
```




### GSEA GO BP Terms

```{r}
pathways.gobp <- gmtPathways("../genesets/c5.go.bp.v7.4.symbols.gmt")
fgsea_gobp <- fgseaMultilevel(pathways=pathways.gobp, stats=ranks, nPermSimple = 10000, maxSize = 500, minSize = 30)
# convert to tibble, sort by NES and select columns
fgsea_gobp_tidy <- fgsea_gobp %>% as_tibble() %>% arrange(padj) %>% dplyr::select(-pval, -ES)
# Show in a nice table:
fgsea_gobp_tidy %>% DT::datatable()
```





### Top 15 up and down regulated GOBP pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowed pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_gobp_up <- fgsea_gobp[ES > 0][size < 250][order(padj,-NES),pathway][1:15]
top_gobp_dn <- fgsea_gobp[ES < 0][size < 250][order(padj,NES),pathway][1:15]
top_gobp <- c(top_gobp_up, rev(top_gobp_dn))
plotGseaTable(pathways.gobp[top_gobp], ranks, fgsea_gobp, gseaParam = 0.5)
fgsea_gobp_tidy_top <- fgsea_gobp_tidy %>% filter(pathway %in% top_gobp)
```


```{r, fig.width=10}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_gobp_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down GO-BP pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=8))+theme(plot.title = element_text(size=7), legend.title = element_text(size=10))
p1

```

### Enrichments plots for top GOBP hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.gobp[[top_gobp_up[i]]], ranks) + labs(title=top_gobp_up[i]))
}
```




### Leading Edge heatmaps for top GOBP hits

Heatmap of row normalised rld regularised leg transformed size factor normalised read counts

```{r, echo=FALSE, message=FALSE, warning=FALSE}
norm_counts <- as.data.frame(assay(rld))
norm_counts <- norm_counts %>% rownames_to_column(var="gene")
norm_counts_Ens <- merge(norm_counts, t2g_genes[,c(4,9)], by.all="gene")
ens2symbol <- AnnotationDbi::select(org.Hs.eg.db, key=norm_counts_Ens$ens_gene, columns="SYMBOL", keytype="ENSEMBL", multiVals="first") %>% distinct()
ens2symbol$gene <- paste(ens2symbol$ENSEMBL,"-",ens2symbol$SYMBOL,sep="")
ens2symbol <- as_tibble(ens2symbol)
norm_counts_Ens <- norm_counts_Ens %>% column_to_rownames(var= "ens_gene") %>% dplyr::select(-gene)
norm_counts_Ens_WK1 <- norm_counts_Ens %>%  dplyr::select(starts_with("WK1"))

```

```{r, eval=T, fig.height=10}
top_gobp_up_full <- fgsea_gobp[ES > 0][size < 250][order(padj,-NES),][1:5]

for (i in 1:5) {
  # Full pathway
  # print(pathways.gobp[[top_gobp_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_gobp_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens_WK1[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens_WK1)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  pheatmap(gene_counts_rownorm, col = colors, main=top_gobp_up_full[i,pathway])
 }
  
```



## Differential Expression : : PD vs NSC (WK2)

+ contrasts of interest: "Stimulation_Aggregate_vs_NSC"  + "Treatment_timeWK2.StimulationAggregate"
* DEG log2FC threshold = 0 and FDR 5%


```{r}

dds <- DESeq(dds, parallel = T,betaPrior = FALSE, test = "Wald") # calculate LFC shrink afterwards using lfcshrink
#res_diffage <- results(dds)
#res_diffage
#mcols(res_diffage)
resultsNames(dds) 
# Will have to relevel Group to "WK2_NSC" for Week2 compariosns
```




```{r}

res_WK2_Agg_NSC <- results(object=dds ,contrast = list(c("Stimulation_Aggregate_vs_NSC","Treatment_timeWK2.StimulationAggregate")) , lfcThreshold = 0, alpha=0.05)
 mcols(res_WK2_Agg_NSC)$description
 res_summary <- capture.output(summary(res_WK2_Agg_NSC))
 cat(res_summary, sep="  \n* ")
 
 # number of differentially expressed genes based on cut off
 
 num_DEG <- sum(res_WK2_Agg_NSC$padj < alpha_cutoff & abs(res_WK2_Agg_NSC$log2FoldChange) >= 0, na.rm=TRUE)
    cat("  \n* Genes with adjusted P-value not NA (universe of genes): ", sum(!is.na(res_WK2_Agg_NSC$padj)))
    cat("  \n* Differentially expressed genes with log2FC >= 0.50 & p.adjusted <0.05: ", num_DEG, "  \n")
resOrdered_WK2_Agg_NSC <- res_WK2_Agg_NSC[order(res_WK2_Agg_NSC$padj),]
resOrdered_WK2_Agg_NSC <- as.data.frame(resOrdered_WK2_Agg_NSC )
#write.table(as.data.frame(resOrdered_WK1_PD_NSC), file = paste0("deseq2_results_","WK1_PD_vs._NSC",".txt"), sep="\t", quote=F)
```

### MA-plot

```{r}
res_WK2_Agg_NSC_LFCshrink <- lfcShrink(dds = dds , contrast = list(c("Stimulation_Aggregate_vs_NSC","Treatment_timeWK2.StimulationAggregate")) ,type="ashr")
DESeq2::plotMA(res_WK2_Agg_NSC_LFCshrink, ylim = c(-20,20))
resOrdered_WK2_Agg_NSC_LFCshrink <- res_WK2_Agg_NSC_LFCshrink[order(res_WK2_Agg_NSC_LFCshrink$padj),]
resOrdered_WK2_Agg_NSC_LFCshrink  <- as.data.frame(resOrdered_WK2_Agg_NSC_LFCshrink )
```

### Dispersion plot

```{r, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
plotDispEsts(dds)
```


### Table of DEG

```{r}
top_genes <- 20

 #prnt table of up and down regulated genes from DEG
    
res_print_WK2_Agg_NSC <- print_DESeq_table(resOrdered_WK2_Agg_NSC_LFCshrink, t2g_info = t2g_genes, alpha_level = alpha_cutoff,logfcthreshold = 0)


    
    plot_up_genes <- res_print_WK2_Agg_NSC[fc == "up", target_id][1:top_genes]
    plot_up_genes <- plot_up_genes[!(is.na(plot_up_genes))] # if there are not top_genes DEGs, NA values will be returned
    plot_down_genes <-res_print_WK2_Agg_NSC[fc == "down", target_id][1:top_genes]
    plot_down_genes <- plot_down_genes[!(is.na(plot_down_genes))]
  
    
    
  res_print_WK2_Agg_NSC <- res_print_WK2_Agg_NSC[, gene_type := NULL] ## only protein coding genes
   res_print_WK2_Agg_NSC <- res_print_WK2_Agg_NSC[, target_id := NULL] ## remove "symbol - ensembl_ID"
    
    setnames(res_print_WK2_Agg_NSC, "desc", "___________long_gene_description___________")
   res_print_WK2_Agg_NSC <- res_print_WK2_Agg_NSC %>% drop_na()
```



```{r, fig.height=6}
res_print_WK2_Agg_NSC %>% DT::datatable(caption=" WK2: Aggregate vs NSC", escape=F, extensions = 'Buttons', options = list(dom = 'Blfrtip', buttons = list('colvis', list(extend = 'copy', exportOptions = list(columns=':visible')), list(extend = 'csv', exportOptions = list(columns=':visible')), list(extend = 'excel', exportOptions = list(columns=':visible')))))
```


### Count Plots of Top genes


 plot normalised counts for DEG for different groups

```{r, echo=F}
my_plot_counts <- function(obj, plot_genes=NULL, intgroup_vec=c("Group_2", "Replicate_2", "Batch","Treatment"), t2g_info=NULL, n_ncol=4, n_nrow =6, title=NULL){

  # collect data for each gene
  plot_data_all <- as.data.table(plotCounts(obj, gene = plot_genes[1], intgroup_vec, returnData=TRUE,transform = F, replaced = F))
  plot_data_all[, gene := plot_genes[1]]
  plot_data_all[, gene_idx := formatC(1,width=2,flag='0')]
  
  if (length(plot_genes) >= 2){
    for (i in 2:length(plot_genes)){
      
      plot_data <- as.data.table(plotCounts(obj, gene = plot_genes[i], intgroup_vec, returnData=TRUE,transform = F))
      plot_data[, gene := plot_genes[i]]
      plot_data[, gene_idx := formatC(i,width=2,flag='0')]
      plot_data_all <- rbind(plot_data_all, plot_data)
    }
  }
  
  plot_data_all <- merge(plot_data_all, t2g_info[, .(gene, ext_gene)], by.x="gene", by.y="gene")
  # plot_data_all[, gene_print := paste0(gene_idx, "  ", gene, "  ", ext_gene)]
  # plot_data_all[, gene_print := paste0(gene_idx, "  ", gene)]
  plot_data_all[, gene_print := paste0(gene_idx, "  ", ext_gene)] ## use only gene symbol as facet title
  plot_data_all <- plot_data_all %>% filter( Group_2 == c("WK2_NSC","WK2_Aggregate"))
  p <- ggplot(data = plot_data_all, aes(x=Group_2, y=log2(count+1), colour=Group_2, shape=Treatment))
  p <- p + geom_violin(aes(group=Group_2), alpha = 0, colour = "gray60", scale="width")
  ## p <- p + ggbeeswarm::geom_quasirandom(alpha = 0.6, size = 3, groupOnX = TRUE)
  p <- p + geom_point(position = position_jitterdodge(), size=5, alpha=0.6)
  p <- p + xlab(NULL)
  p <- p + facet_wrap(~gene_print, ncol=n_ncol, scales="free_y",nrow = n_nrow)
  p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
  p <- p + ylab("log2(normalised count + 1)") + theme(legend.position="top")
  p <- p + theme(axis.text.x=element_text(angle=90, hjust=1, size=10)) + theme(axis.text.y = element_text(size=8))
  p <- p + ggtitle(title)
  p
}

```

 UP Genes

```{r, echo=FALSE, fig.height=10, fig.width=10}
p <-my_plot_counts(dds, plot_genes = plot_up_genes,title="upregulated genes in WK2 Aggregate vs NSC", t2g_info = t2g_genes, n_ncol = 4)
p
```
 Down genes

```{r, echo=FALSE, fig.height=9, fig.width=10}
my_plot_counts(dds, plot_genes = plot_down_genes,title="downregulated genes in WK2: Aggregate vs NSC", t2g_info = t2g_genes, n_ncol=5)
```

  PD genes that are significant

+ none were significant

```{r,echo=FALSE, fig.height=4, fig.width=9, eval=F}
control_genes <- c("OPA1 - ENSG00000198836","MFN1 - ENSG00000171109","TOMM20 - ENSG00000173726","DNM1L - ENSG00000087470","TFAM - ENSG00000108064","NRF1 - ENSG00000106459","NFE2L2 - ENSG00000116044","MTOR - ENSG00000198793","HIF1A - ENSG00000100644","ARNT - ENSG00000143437","SNCA - ENSG00000145335","PARK7 - ENSG00000116288","OMA1 - ENSG00000162600","MFN1 - ENSG00000171109")

#t2g_genes_control <- t2g_genes %>% filter(gene %in% control_genes) %>% select(gene)
control_genes_sig <- resOrdered_WK2_Agg_NSC_LFCshrink %>% filter(rownames(.) %in% control_genes & padj<0.05 )
my_plot_counts(dds, plot_genes = rownames(control_genes_sig),title="interesting significant PD genes", t2g_info = t2g_genes)
#PGC-1alpha = ENSG00000109819
# OMA1 - ENSG00000162600
# OPA1 - ENSG00000198836
# MFN1 - ENSG00000171109
# TOM20 - ENSG00000173726
# DNM1L - ENSG00000087470
# TFAM - ENSG00000108064
# NRF1 - ENSG00000106459
# NFE2L2 -  ENSG00000116044
# TFEB - ENSG00000112561
# MTOR - ENSG00000198793
# HIF1a - ENSG00000100644
# HIF1b -  ENSG00000143437
#SNCA - ENSG00000145335
# PARK7 - ENSG00000116288
```




```{r,echo=FALSE}

# Get ENSEMBLE IDS

resOrdered_WK2_Agg_NSC_LFCshrink$gene <- rownames(resOrdered_WK2_Agg_NSC_LFCshrink)
resOrdered_WK2_Agg_NSC_LFCshrink_ens <- merge(resOrdered_WK2_Agg_NSC_LFCshrink, t2g_genes, by.all ="gene")
rownames(resOrdered_WK2_Agg_NSC_LFCshrink_ens) <- resOrdered_WK2_Agg_NSC_LFCshrink_ens$ens_gene
rm(resOrdered_WK2_Agg_NSC_LFCshrink)
resOrdered_WK2_Agg_NSC_LFCshrink_ens <- resOrdered_WK2_Agg_NSC_LFCshrink_ens[,c(1:7,11)]

# get rid of NAs for clusterprofiler
#library(tidyr)
resOrdered_WK2_Agg_NSC_LFCshrink_ens <- resOrdered_WK2_Agg_NSC_LFCshrink_ens %>% drop_na()

# map ids using annotation db
library(org.Hs.eg.db)
library(AnnotationDbi)

resOrdered_WK2_Agg_NSC_LFCshrink_ens$entrez <- mapIds(org.Hs.eg.db, keys= rownames(resOrdered_WK2_Agg_NSC_LFCshrink_ens), column = "ENTREZID", keytype = "ENSEMBL", multiVals = "first")
resOrdered_WK2_Agg_NSC_LFCshrink_ens$symbol <- mapIds(org.Hs.eg.db, keys= rownames(resOrdered_WK2_Agg_NSC_LFCshrink_ens), column = "SYMBOL", keytype = "ENSEMBL", multiVals = "first")
write.table(resOrdered_WK2_Agg_NSC_LFCshrink_ens, file="deseq2_results_Jan_Jun21_WK2_Aggregate_vs WK1_NSC.txt", sep="\t", quote=F)


```

### Volcano plot 

```{r, fig.height=5, fig.width=7}
library(EnhancedVolcano)
 Vol <- EnhancedVolcano(resOrdered_WK2_Agg_NSC_LFCshrink_ens,
    lab = resOrdered_WK2_Agg_NSC_LFCshrink_ens$symbol,
    x = 'log2FoldChange',
    y = 'pvalue', subtitle = "", title = "WK2 Aggregate vs WK1 NSC", xlim = c(-22,20), labSize =3, FCcutoff = 0.5, axisLabSize = 6, titleLabSize = 8, legendLabSize = 6, pCutoff = 0.05,pCutoffCol = 'padj', drawConnectors = F, captionLabSize = 6,
    widthConnectors = 0.2, colConnectors = 'grey30',caption = "Log2FC cutoff = 0.2; p-value cutoff= 0.05" )
 #Vol <-   Vol +  ggplot2::coord_cartesian(xlim=c(-10, 8))  + ggplot2::scale_x_continuous(breaks=seq(-10,8, 2))
 Vol
```



### Gene Ontology Over-representation analysis
+ GO Biological Process
+ genes used : p.adj < 0.05 and log2FC >= 0


```{r, eval=T}

 
 # Done all DEG with p.adj <0.05 , no logFC threshold applied

library(clusterProfiler)

resOrdered_WK2_Agg_NSC_LFCshrink_ens_sig <- resOrdered_WK2_Agg_NSC_LFCshrink_ens %>% filter(padj < 0.05 & abs(log2FoldChange) >= 0) 

#geneChangeList <- resOrdered_Parent_stim_control_LFCshrink_ens_sig$log2FoldChange
geneChangeList <- unique(rownames(resOrdered_WK2_Agg_NSC_LFCshrink_ens_sig))
#geneChangeList <- sort(geneChangeList, decreasing=TRUE)
#desiredGeneChangeList <- names(geneChangeList)[abs(geneChangeList) >1] 
 all_genes <- as.character(unique(rownames(resOrdered_WK2_Agg_NSC_LFCshrink_ens)))

enrichGOResult_2 <- enrichGO(gene = geneChangeList, OrgDb = org.Hs.eg.db, keyType = 'ENSEMBL', ont = "BP", pAdjustMethod = "BH", universe=all_genes, readable = T)
enrichGOResult_2_s <- simplify(enrichGOResult_2, cutoff=0.8)
```


#### GO BP over-representation test

```{r, eval=T}

scorePlot <- RScorePlot_v2(enrichGOResult_2, resOrdered_WK2_Agg_NSC_LFCshrink_ens, showCategory = 20, textSize = 9, title = "" ) + theme(title = element_text(size=8), axis.text = element_text(size=8)) + ggtitle("GO BP terms for WK2: Aggregate vs NSC")
plot(scorePlot)
```

#### Reactome Pathways

```{r, eval=T}

library(ReactomePA)
# only takes entrez id
geneChangeList <- unique(resOrdered_WK2_Agg_NSC_LFCshrink_ens_sig$entrez)
#geneChangeList <- sort(geneChangeList, decreasing=TRUE)
#desiredGeneChangeList <- names(geneChangeList)[abs(geneChangeList) >1] 
 all_genes <- as.character(unique(resOrdered_WK2_Agg_NSC_LFCshrink_ens$entrez))
enrich_Reactome_2 <-  enrichPathway(gene = geneChangeList, pAdjustMethod = "BH", universe=all_genes, readable = T, organism = "human")
scorePlot <- RScorePlot_v2(enrich_Reactome_2, resOrdered_WK2_Agg_NSC_LFCshrink_ens, showCategory = 25, textSize = 9, title = "" ) + theme(title = element_text(size=8)) +ggtitle("Reactome terms for WK2 : Aggregate vs NSC")
plot(scorePlot)
```


```{r, echo=FALSE, message=FALSE, warning=FALSE}
# from https://stephenturner.github.io/deseq-to-fgsea/
# symbol here comes from map ids. it is possible that 2 ensgs map to the same symbol! this creates duplicates in the stat data frame and is removed using distinct
library(fgsea)
gsea_res_WK2_Agg_NSC <- resOrdered_WK2_Agg_NSC_LFCshrink_ens %>% dplyr::select(symbol,log2FoldChange) %>% na.omit() %>% distinct() %>% group_by(symbol) %>% summarize(log2FoldChange=mean(log2FoldChange))
# dim(gsea_res)
# head(gsea_res)

# fast Gene Set Enrichment Analysis
ranks<- deframe(gsea_res_WK2_Agg_NSC)

```

### GSEA Reactome Pathways

```{r}
pathways.reactome <- gmtPathways("../genesets/c2.cp.reactome.v7.4.symbols.gmt")
fgsea_reactome <- fgseaMultilevel(pathways=pathways.reactome, stats=ranks, nPermSimple = 20000, maxSize = 500, minSize = 30)
# convert to tibble, sort by NES and select columns
fgsea_reactome_tidy <- fgsea_reactome %>% as_tibble() %>% arrange(padj) %>% dplyr::select(-pval, -ES)
# Show in a nice table:
fgsea_reactome_tidy %>% DT::datatable()
```





### Top 15 up and down regulated Reactome pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowd pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_reactome_up <- fgsea_reactome[ES > 0][size < 300][order(padj,-NES),pathway][1:15]
top_reactome_dn <- fgsea_reactome[ES < 0][size < 300][order(padj,NES),pathway][1:15]
top_reactome <- c(top_reactome_up, rev(top_reactome_dn))
plotGseaTable(pathways.reactome[top_reactome], ranks, fgsea_reactome, gseaParam = 0.5)
fgsea_reactome_tidy_top <- fgsea_reactome_tidy %>% filter(pathway %in% top_reactome)
```


```{r, fig.width=12}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_reactome_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down Reactome pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=8))+theme(plot.title = element_text(size=7))
p1

```

### Enrichments plots for top Reactome hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.reactome[[top_reactome_up[i]]], ranks) + labs(title=top_reactome_up[i]))
}
```


### Leading Edge heatmaps for top Reactome hits

Heatmap of row normalised rld regularised leg transformed size factor normalised read counts

```{r, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
norm_counts <- as.data.frame(assay(rld))
norm_counts <- norm_counts %>% rownames_to_column(var="gene")
norm_counts_Ens <- merge(norm_counts, t2g_genes[,c(4,9)], by.all="gene")
ens2symbol <- AnnotationDbi::select(org.Hs.eg.db, key=norm_counts_Ens$ens_gene, columns="SYMBOL", keytype="ENSEMBL", multiVals="first") %>% distinct()
ens2symbol$gene <- paste(ens2symbol$ENSEMBL,"-",ens2symbol$SYMBOL,sep="")
ens2symbol <- as_tibble(ens2symbol)
norm_counts_Ens <- norm_counts_Ens %>% column_to_rownames(var= "ens_gene") %>% dplyr::select(-gene)
norm_counts_Ens_WK2 <- norm_counts_Ens %>%  dplyr::select(starts_with("WK2"))

```

```{r, eval=T, fig.height=8, fig.width=10}
top_reactome_up_full <- fgsea_reactome[ES > 0][size < 250][order(padj,-NES),][1:5]

for (i in 1:5) {
  # Full pathway
  # print(pathways.reactome[[top_reactome_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_reactome_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens_WK2[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens_WK2)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  pheatmap(gene_counts_rownorm, col = colors, main=top_reactome_up_full[i,pathway])
 }
  
```


### GSEA KEGG Pathways

```{r}
pathways.kegg <- gmtPathways("../genesets/c2.cp.kegg.v7.4.symbols.gmt")
fgsea_kegg <- fgseaMultilevel(pathways=pathways.kegg, stats=ranks, nPermSimple = 10000, maxSize = 500, minSize = 30)
# convert to tibble, sort by NES and select columns
fgsea_kegg_tidy <- fgsea_kegg %>% as_tibble() %>% arrange(padj) %>% dplyr::select(-pval, -ES)
# Show in a nice table:
fgsea_kegg_tidy %>% DT::datatable()
```




### Top 15 up and down regulated KEGG pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowd pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_kegg_up <- fgsea_kegg[ES > 0][size < 250][order(padj,-NES),pathway][1:15]
top_kegg_dn <- fgsea_kegg[ES < 0][size < 250][order(padj,NES),pathway][1:15]
top_kegg <- c(top_kegg_up, rev(top_kegg_dn))
plotGseaTable(pathways.kegg[top_kegg], ranks, fgsea_kegg, gseaParam = 0.5)
fgsea_kegg_tidy_top <- fgsea_kegg_tidy %>% filter(pathway %in% top_kegg)
```


```{r, fig.width=10}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_kegg_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down KEGG pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=8))+theme(plot.title = element_text(size=7), legend.title = element_text(size=10))
p1

```

### Enrichments plots for top KEGG hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.kegg[[top_kegg_up[i]]], ranks) + labs(title=top_kegg_up[i]))
}
```




### Leading Edge heatmaps for top KEGG hits

Heatmap of row noemalised rld regularised leg transformed size factor normalised read counts

```{r, echo=FALSE, message=FALSE, warning=FALSE}
norm_counts <- as.data.frame(assay(rld))
norm_counts <- norm_counts %>% rownames_to_column(var="gene")
norm_counts_Ens <- merge(norm_counts, t2g_genes[,c(4,9)], by.all="gene")
ens2symbol <- AnnotationDbi::select(org.Hs.eg.db, key=norm_counts_Ens$ens_gene, columns="SYMBOL", keytype="ENSEMBL", multiVals="first") %>% distinct()
ens2symbol$gene <- paste(ens2symbol$ENSEMBL,"-",ens2symbol$SYMBOL,sep="")
ens2symbol <- as_tibble(ens2symbol)
norm_counts_Ens <- norm_counts_Ens %>% column_to_rownames(var= "ens_gene") %>% dplyr::select(-gene)
norm_counts_Ens_WK2 <- norm_counts_Ens %>%  dplyr::select(starts_with("WK2"))

```

```{r, eval=T, fig.height=9}
top_kegg_up_full <- fgsea_kegg[ES > 0][size < 250][order(padj,-NES),][1:6]

for (i in 1:6) {
  # Full pathway
   #print(pathways.kegg[[top_kegg_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_kegg_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens_WK2[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens_WK2)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  pheatmap(gene_counts_rownorm, col = colors, main=top_kegg_up_full[i,pathway])
 }
  
```




### GSEA GO BP Terms

```{r}
pathways.gobp <- gmtPathways("../genesets/c5.go.bp.v7.4.symbols.gmt")
fgsea_gobp <- fgseaMultilevel(pathways=pathways.gobp, stats=ranks, nPermSimple = 10000, maxSize = 500, minSize = 30)
# convert to tibble, sort by NES and select columns
fgsea_gobp_tidy <- fgsea_gobp %>% as_tibble() %>% arrange(padj) %>% dplyr::select(-pval, -ES)
# Show in a nice table:
fgsea_gobp_tidy %>% DT::datatable()
```





### Top 15 up and down regulated GOBP pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowed pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_gobp_up <- fgsea_gobp[ES > 0][size < 250][order(padj,-NES),pathway][1:15]
top_gobp_dn <- fgsea_gobp[ES < 0][size < 250][order(padj,NES),pathway][1:15]
top_gobp <- c(top_gobp_up, rev(top_gobp_dn))
plotGseaTable(pathways.gobp[top_gobp], ranks, fgsea_gobp, gseaParam = 0.5)
fgsea_gobp_tidy_top <- fgsea_gobp_tidy %>% filter(pathway %in% top_gobp)
```


```{r, fig.width=10}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_gobp_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down GO-BP pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=8))+theme(plot.title = element_text(size=7), legend.title = element_text(size=10))
p1

```

### Enrichments plots for top GOBP hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.gobp[[top_gobp_up[i]]], ranks) + labs(title=top_gobp_up[i]))
}
```




### Leading Edge heatmaps for top GOBP hits

Heatmap of row normalised rld regularised leg transformed size factor normalised read counts

```{r, echo=FALSE, message=FALSE, warning=FALSE}
norm_counts <- as.data.frame(assay(rld))
norm_counts <- norm_counts %>% rownames_to_column(var="gene")
norm_counts_Ens <- merge(norm_counts, t2g_genes[,c(4,9)], by.all="gene")
ens2symbol <- AnnotationDbi::select(org.Hs.eg.db, key=norm_counts_Ens$ens_gene, columns="SYMBOL", keytype="ENSEMBL", multiVals="first") %>% distinct()
ens2symbol$gene <- paste(ens2symbol$ENSEMBL,"-",ens2symbol$SYMBOL,sep="")
ens2symbol <- as_tibble(ens2symbol)
norm_counts_Ens <- norm_counts_Ens %>% column_to_rownames(var= "ens_gene") %>% dplyr::select(-gene)
norm_counts_Ens_WK2 <- norm_counts_Ens %>%  dplyr::select(starts_with("WK2"))

```

```{r, eval=T, fig.height=10}
top_gobp_up_full <- fgsea_gobp[ES > 0][size < 250][order(padj,-NES),][1:5]

for (i in 1:5) {
  # Full pathway
  # print(pathways.gobp[[top_gobp_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_gobp_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens_WK2[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens_WK2)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  pheatmap(gene_counts_rownorm, col = colors, main=top_gobp_up_full[i,pathway])
 }
  
```





















# Differential Expression : Week2 NSC vs Week1 NSC

 * design " ~ Batch + Treatment_time + Treatment + TreatmentTime:Treatment
* DEG log2FC threshold = 0.50 and FDR 5%
* Accounting for differences in WK2 vs WK1 PD
+ contrasts of interest: Treatment_time_WK2_vs_WK1
 
```{r}

res_WK2NSC_WK1NSC <- results(object=dds ,contrast = list("Treatment_time_WK2_vs_WK1") , lfcThreshold = 0.50, alpha=0.05)
 mcols(res_WK2NSC_WK1NSC)$description
 res_summary <- capture.output(summary(res_WK2NSC_WK1NSC))
 cat(res_summary, sep="  \n* ")
 
 # number of differentially expressed genes based on cut off
 
 num_DEG <- sum(res_WK2NSC_WK1NSC$padj < alpha_cutoff & abs(res_WK2NSC_WK1NSC$log2FoldChange) >= 0.50, na.rm=TRUE)
    cat("  \n* Genes with adjusted P-value not NA (universe of genes): ", sum(!is.na(res_WK2NSC_WK1NSC$padj)))
    cat("  \n* Differentially expressed genes with log2fc >= 0.5 & p.adjusted <0.05: ", num_DEG, "  \n")
resOrdered_WK2NSC_WK1NSC <- res_WK2NSC_WK1NSC[order(res_WK2NSC_WK1NSC$padj),]
resOrdered_WK2NSC_WK1NSC <- as.data.frame(resOrdered_WK2NSC_WK1NSC )
#write.table(as.data.frame(resOrdered_WK1_PD_NSC), file = paste0("deseq2_results_","WK1_PD_vs._NSC",".txt"), sep="\t", quote=F)
```

### MA-plot

```{r}
res_WK2NSC_WK1NSC_LFCshrink <- lfcShrink(dds = dds ,contrast = list("Treatment_time_WK2_vs_WK1") ,type="ashr")
DESeq2::plotMA(res_WK2NSC_WK1NSC_LFCshrink, ylim = c(-20,20))
resOrdered_WK2NSC_WK1NSC_LFCshrink <- res_WK2NSC_WK1NSC_LFCshrink[order(res_WK2NSC_WK1NSC_LFCshrink$padj),]
resOrdered_WK2NSC_WK1NSC_LFCshrink  <- as.data.frame(resOrdered_WK2NSC_WK1NSC_LFCshrink )
```

### Dispersion plot

```{r, echo=FALSE, message=FALSE, warning=FALSE}
plotDispEsts(dds)
```


### Table of DEG

```{r}
top_genes <- 20

 #prnt table of up and down regulated genes from DEG
    
res_print_WK2NSC_WK1NSC <- print_DESeq_table(res_WK2NSC_WK1NSC_LFCshrink, t2g_info = t2g_genes, alpha_level = alpha_cutoff,logfcthreshold = 0.5)


    
    plot_up_genes <- res_print_WK2NSC_WK1NSC[fc == "up", target_id][1:top_genes]
    plot_up_genes <- plot_up_genes[!(is.na(plot_up_genes))] # if there are not top_genes DEGs, NA values will be returned
    plot_down_genes <- res_print_WK2NSC_WK1NSC[fc == "down", target_id][1:top_genes]
    plot_down_genes <- plot_down_genes[!(is.na(plot_down_genes))]
  
    
    
   res_print_WK2NSC_WK1NSC <-res_print_WK2NSC_WK1NSC[, gene_type := NULL] ## only protein coding genes
   res_print_WK2NSC_WK1NSC <- res_print_WK2NSC_WK1NSC[, target_id := NULL] ## remove "symbol - ensembl_ID"
    
    setnames(res_print_WK2NSC_WK1NSC, "desc", "___________long_gene_description___________")
   res_print_WK2NSC_WK1NSC <- res_print_WK2NSC_WK1NSC %>% drop_na()
```



```{r}
res_print_WK2NSC_WK1NSC %>% DT::datatable(caption=" Week2 NSC vs Week1 NSC", escape=F, extensions = 'Buttons', options = list(dom = 'Blfrtip', buttons = list('colvis', list(extend = 'copy', exportOptions = list(columns=':visible')), list(extend = 'csv', exportOptions = list(columns=':visible')), list(extend = 'excel', exportOptions = list(columns=':visible')))))
```


### Count Plots of Top genes


+ plot normalised counts for DEG for different groups

```{r, echo=F}
my_plot_counts <- function(obj, plot_genes=NULL, intgroup_vec=c("Group", "Batch"), t2g_info=NULL, n_ncol=4, n_nrow =6, title=NULL){

  # collect data for each gene
  plot_data_all <- as.data.table(plotCounts(obj, gene = plot_genes[1], intgroup_vec, returnData=TRUE,transform = F))
  plot_data_all[, gene := plot_genes[1]]
  plot_data_all[, gene_idx := formatC(1,width=2,flag='0')]
  
  if (length(plot_genes) >= 2){
    for (i in 2:length(plot_genes)){
      
      plot_data <- as.data.table(plotCounts(obj, gene = plot_genes[i], intgroup_vec, returnData=TRUE,transform = F))
      plot_data[, gene := plot_genes[i]]
      plot_data[, gene_idx := formatC(i,width=2,flag='0')]
      plot_data_all <- rbind(plot_data_all, plot_data)
    }
  }
  
  plot_data_all <- merge(plot_data_all, t2g_info[, .(gene, ext_gene)], by.x="gene", by.y="gene")
  # plot_data_all[, gene_print := paste0(gene_idx, "  ", gene, "  ", ext_gene)]
  # plot_data_all[, gene_print := paste0(gene_idx, "  ", gene)]
  plot_data_all[, gene_print := paste0(gene_idx, "  ", ext_gene)] ## use only gene symbol as facet title
  
  p <- ggplot(data = plot_data_all, aes(x=Group, y=log2(count+1), colour=Group,shape=Batch))
  p <- p + geom_violin(aes(group=Group), alpha = 0, colour = "gray60", scale="width")
  ## p <- p + ggbeeswarm::geom_quasirandom(alpha = 0.6, size = 3, groupOnX = TRUE)
  p <- p + geom_point(position = position_jitterdodge(), size=5, alpha=0.6)
  p <- p + xlab(NULL)
  p <- p + facet_wrap(~gene_print, ncol=n_ncol, scales="free_y",nrow = n_nrow)
  p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
  p <- p + ylab("log2(normalised count + 1)") + theme(legend.position="top")
  p <- p + theme(axis.text.x=element_text(angle=90, hjust=1, size=10)) + theme(axis.text.y = element_text(size=8))
  p <- p + ggtitle(title)
  p
}

```


```{r, echo=FALSE, fig.height=9, fig.width=10}
my_plot_counts(dds, plot_genes = plot_up_genes,title="upregulated genes in WK2 NSC vs WK1 NSC", t2g_info = t2g_genes, n_ncol = 5)
```

```{r, echo=FALSE, fig.height=9, fig.width=10}
my_plot_counts(dds, plot_genes = plot_down_genes,title="downregulated genes in WK2 NSC vs WK1 NSC", t2g_info = t2g_genes, n_ncol = 5)
```

* plot interesting genes 

```{r,echo=FALSE, fig.height=5, fig.width=10, eval=T}
control_genes <- c("OPA1 - ENSG00000198836","MFN1 - ENSG00000171109","TOMM20 - ENSG00000173726","DNM1L - ENSG00000087470","TFAM - ENSG00000108064","NRF1 - ENSG00000106459","NFE2L2 - ENSG00000116044","MTOR - ENSG00000198793","HIF1A - ENSG00000100644","ARNT - ENSG00000143437","SNCA - ENSG00000145335","PARK7 - ENSG00000116288","OMA1 - ENSG00000162600","MFN1 - ENSG00000171109")

#t2g_genes_control <- t2g_genes %>% filter(gene %in% control_genes) %>% select(gene)
control_genes_sig <- resOrdered_WK2NSC_WK1NSC_LFCshrink %>% filter(rownames(.) %in% control_genes & padj<0.05 )
my_plot_counts(dds, plot_genes = rownames(control_genes_sig),title="interesting significant PD genes", t2g_info = t2g_genes)
#PGC-1alpha = ENSG00000109819
# OMA1 - ENSG00000162600
# OPA1 - ENSG00000198836
# Mitofusin - ENSG00000171109
# TOM20 - ENSG00000173726
# DNM1L - ENSG00000087470
# TFAM - ENSG00000108064
# NRF1 - ENSG00000106459
# NFE2L2 -  ENSG00000116044
# TFEB - ENSG00000112561
# MTOR - ENSG00000198793
# HIF1a - ENSG00000100644
# HIF1b -  ENSG00000143437
#SNCA - ENSG00000145335
# PARK7 - ENSG00000116288
```




```{r,eval=FALSE}
### Plot SNCA counts in Week2 samples only
 plot_data_SNCA <- plotCounts(dds = dds, gene = "SNCA - ENSG00000145335", intgroup =c("Group2", "Stimulation","Treatment_time","Replicate","Treatment"), returnData=TRUE,transform = F)
plot_data_SNCA_wk2 <- plot_data_SNCA %>% filter(Treatment_time == "WK2")

 p <- ggplot(data = plot_data_SNCA_wk2, aes(x=Group2, y=log2(count+1), colour=Stimulation))
  p <- p + geom_violin(aes(group=Group2), alpha = 0, colour = "gray60", scale="width")
  ## p <- p + ggbeeswarm::geom_quasirandom(alpha = 0.6, size = 3, groupOnX = TRUE)
  p <- p + geom_point(position = position_jitterdodge(), size=5, alpha=0.6, aes(shape = Treatment))
  p <- p + xlab(NULL)
 # p <- p + facet_wrap(~gene_print, ncol=n_ncol, scales="free_y",nrow = n_nrow)
  p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
  p <- p + ylab("log2(normalised count + 1)") + theme(legend.position="right")
  p <- p + theme(axis.text.x=element_text(angle=90, hjust=1, size=10)) + theme(axis.text.y = element_text(size=8))
  p <- p + ggtitle("SNCA-ENSG00000145335") 
  p
 # ggsave(filename = "RNASEQ_WK2_SNCA_normalised_counts_plot.pdf",width = 5, height = 5,units = "in", dpi = 300)
```





```{r,echo=FALSE}

# Get ENSEMBLE IDS

resOrdered_WK2NSC_WK1NSC_LFCshrink$gene <- rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink)
resOrdered_WK2NSC_WK1NSC_LFCshrink_ens <- merge(resOrdered_WK2NSC_WK1NSC_LFCshrink, t2g_genes, by.all ="gene")
rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens) <- resOrdered_WK2NSC_WK1NSC_LFCshrink_ens$ens_gene
rm(resOrdered_WK2NSC_WK1NSC)
resOrdered_WK2NSC_WK1NSC_LFCshrink_ens <- resOrdered_WK2NSC_WK1NSC_LFCshrink_ens[,c(1:7,11)]

# get rid of NAs for clusterprofiler
#library(tidyr)
resOrdered_WK2NSC_WK1NSC_LFCshrink_ens <- resOrdered_WK2NSC_WK1NSC_LFCshrink_ens%>% drop_na()

# map ids using annotation db
library(org.Hs.eg.db)
library(AnnotationDbi)

resOrdered_WK2NSC_WK1NSC_LFCshrink_ens$entrez <- mapIds(org.Hs.eg.db, keys= rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens), column = "ENTREZID", keytype = "ENSEMBL", multiVals = "first")
resOrdered_WK2NSC_WK1NSC_LFCshrink_ens$symbol <- mapIds(org.Hs.eg.db, keys= rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens), column = "SYMBOL", keytype = "ENSEMBL", multiVals = "first")
write.table(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens, file="deseq2_results_Jan_Jun_21_WK2_NSC_vsWK1_NSC.txt", sep="\t", quote=F)


```

### Volcano plot 

```{r, fig.height=6, fig.width=8}
library(EnhancedVolcano)
 Vol <- EnhancedVolcano(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens,
    lab = resOrdered_WK2NSC_WK1NSC_LFCshrink_ens$symbol,
    x = 'log2FoldChange',
    y = 'pvalue', subtitle = "", title = "WK2:NSC vs WK1:NSC", xlim = c(-26,26), labSize =3, FCcutoff = 1.5, axisLabSize = 6, titleLabSize = 8, legendLabSize = 6, pCutoff = 0.05, pCutoffCol = "padj",   drawConnectors = F, captionLabSize = 6,
    widthConnectors = 0.2, colConnectors = 'grey30',caption = "Log2FC cutoff = 1.5; p-value cutoff=0.05" )
# Vol <-   Vol +  ggplot2::coord_cartesian(xlim=c(-28, 26))  + ggplot2::scale_x_continuous(breaks=seq(-28,23, 5))
 Vol
```

### Gene Ontology Over-representation analysis


```{r, eval=T}

 
 # Done all DEG with p.adj <0.05 , no logFC threshold applied

library(clusterProfiler)

resOrdered_WK2NSC_WK1NSC_LFCshrink_ens_sig <- resOrdered_WK2NSC_WK1NSC_LFCshrink_ens %>% filter(padj < 0.05 & abs(log2FoldChange) >= 0.50) 

#geneChangeList <- resOrdered_Parent_stim_control_LFCshrink_ens_sig$log2FoldChange
geneChangeList <- unique(rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens_sig))
#geneChangeList <- sort(geneChangeList, decreasing=TRUE)
#desiredGeneChangeList <- names(geneChangeList)[abs(geneChangeList) >1] 
 all_genes <- as.character(unique(rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens)))

enrichGOResult_2 <- enrichGO(gene = geneChangeList, OrgDb = org.Hs.eg.db, keyType = 'ENSEMBL', ont = "BP", pAdjustMethod = "BH", universe=all_genes, readable = T)
enrichGOResult_2_s <- simplify(enrichGOResult_2, cutoff=0.8)
```


#### GO BP over-representation test


```{r, eval=T}

scorePlot <- RScorePlot_v2(enrichGOResult_2, resOrdered_WK2NSC_WK1NSC_LFCshrink_ens, showCategory = 25, textSize = 9, title = "" ) + theme(title = element_text(size=8))+ggtitle("GO BP terms for WK2:NSC vs WK1:NSC")
plot(scorePlot)
```

#### Reactome Pathways


```{r, eval=T}

library(ReactomePA)
# only takes entrez id
geneChangeList <- unique(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens_sig$entrez)
#geneChangeList <- sort(geneChangeList, decreasing=TRUE)
#desiredGeneChangeList <- names(geneChangeList)[abs(geneChangeList) >1] 
 all_genes <- as.character(unique(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens$entrez))
enrich_Reactome_2 <-  enrichPathway(gene = geneChangeList, pAdjustMethod = "BH", universe=all_genes, readable = T, organism = "human")
scorePlot <- RScorePlot_v2(enrich_Reactome, resOrdered_WK2NSC_WK1NSC_LFCshrink_ens, showCategory = 25, textSize = 9, title = "" ) + theme(title = element_text(size=8))+ ggtitle("Reactome terms for WK2:NSC vs WK1:NSC")
plot(scorePlot)
```

```{r,echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE}
library(fgsea)
gsea_res_WK2NSC_WK1NSC <- resOrdered_WK2NSC_WK1NSC_LFCshrink_ens %>% dplyr::select(symbol,log2FoldChange) %>% na.omit() %>% distinct() %>% group_by(symbol) %>% summarize(log2FoldChange=mean(log2FoldChange))
# dim(gsea_res)
# head(gsea_res)

# fast Gene Set Enrichment Analysis
ranks <- deframe(gsea_res_WK2NSC_WK1NSC)

```

### GSEA Reactome Pathways

```{r}
#pathways.reactome <- gmtPathways("./genesets/c2.cp.reactome.v7.1.symbols.gmt")
fgsea_reactome <- fgseaMultilevel(pathways=pathways.reactome, stats=ranks, nPermSimple = 10000, maxSize = 500, minSize = 30)
# convert to tibble, sort by NES and select columns
fgsea_reactome_tidy <- fgsea_reactome %>% as_tibble() %>% arrange(padj) %>% dplyr::select(-pval, -ES)
# Show in a nice table:
fgsea_reactome_tidy %>% DT::datatable()
```



### Top 15 up and down regulated Reactome pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowd pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_reactome_up <- fgsea_reactome[ES > 0][size < 250][order(padj,-NES),pathway][1:15]
top_reactome_dn <- fgsea_reactome[ES < 0][size < 250][order(padj,NES),pathway][1:15]
top_reactome <- c(top_reactome_up, rev(top_reactome_dn))
plotGseaTable(pathways.reactome[top_reactome], ranks, fgsea_reactome, gseaParam = 0.5)
fgsea_reactome_tidy_top <- fgsea_reactome_tidy %>% filter(pathway %in% top_reactome)
```


```{r, fig.width=12}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_reactome_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.01)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down Reactome pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=8))+theme(plot.title = element_text(size=7))
p1

```

### Enrichments plots for top Reactome hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.reactome[[top_reactome_up[i]]], ranks) + labs(title=top_reactome_up[i]))
}
```



### Leading Edge heatmaps for top Reactome hits

Heatmap of row normalised rld regularised leg transformed size factor normalised read counts

```{r, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
norm_counts <- as.data.frame(assay(rld))
norm_counts <- norm_counts %>% rownames_to_column(var="gene")
norm_counts_Ens <- merge(norm_counts, t2g_genes[,c(4,9)], by.all="gene")
ens2symbol <- AnnotationDbi::select(org.Hs.eg.db, key=norm_counts_Ens$ens_gene, columns="SYMBOL", keytype="ENSEMBL", multiVals="first") %>% distinct()
ens2symbol$gene <- paste(ens2symbol$ENSEMBL,"-",ens2symbol$SYMBOL,sep="")
ens2symbol <- as_tibble(ens2symbol)
norm_counts_Ens <- norm_counts_Ens %>% column_to_rownames(var= "ens_gene") %>% dplyr::select(-gene)
norm_counts_Ens_NSC <- norm_counts_Ens %>%  dplyr::select(ends_with("NSC"))

```

```{r,fig.height=8}
top_reactome_up_full <- fgsea_reactome[ES > 0][size < 250][order(padj,-NES),][1:5]

for (i in 1:5) {
  # Full pathway
  # print(pathways.reactome[[top_reactome_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_reactome_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens_NSC[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens_NSC)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  print(pheatmap(gene_counts_rownorm, col = colors, main=top_reactome_up_full[i,pathway]))
 }
  
```

### GSEA KEGG Pathways

```{r}
#pathways.kegg <- gmtPathways("./genesets/c2.cp.kegg.v7.1.symbols.gmt")
fgsea_kegg <- fgseaMultilevel(pathways=pathways.kegg, stats=ranks, nPermSimple =10000, maxSize = 500, minSize = 30)
# convert to tibble, sort by NES and select columns
fgsea_kegg_tidy <- fgsea_kegg %>% as_tibble() %>% arrange(padj) %>% dplyr::select(-pval, -ES)
# Show in a nice table:
fgsea_kegg_tidy %>% DT::datatable()
```





### Top 15 up and down regulated KEGG pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowd pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_kegg_up <- fgsea_kegg[ES > 0][size < 250][order(padj,-NES),pathway][1:15]
top_kegg_dn <- fgsea_kegg[ES < 0][size < 250][order(padj,NES),pathway][1:15]
top_kegg <- c(top_kegg_up, rev(top_kegg_dn))
plotGseaTable(pathways.kegg[top_kegg], ranks, fgsea_kegg, gseaParam = 0.5)
fgsea_kegg_tidy_top <- fgsea_kegg_tidy %>% filter(pathway %in% top_kegg)
```


```{r, fig.width=12}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_kegg_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down KEGG pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=8))+theme(plot.title = element_text(size=7))
p1

```

### Enrichments plots for top KEGG hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.kegg[[top_kegg_up[i]]], ranks) + labs(title=top_kegg_up[i]))
}
```




### Leading Edge heatmaps for top KEGG hits

Heatmap of row noemalised rld regularised leg transformed size factor normalised read counts

```{r, echo=FALSE, message=FALSE, warning=FALSE, eval=FALSE}
norm_counts <- as.data.frame(assay(rld))
norm_counts <- norm_counts %>% rownames_to_column(var="gene")
norm_counts_Ens <- merge(norm_counts, t2g_genes[,c(4,9)], by.all="gene")
ens2symbol <- AnnotationDbi::select(org.Hs.eg.db, key=norm_counts_Ens$ens_gene, columns="SYMBOL", keytype="ENSEMBL", multiVals="first") %>% distinct()
ens2symbol$gene <- paste(ens2symbol$ENSEMBL,"-",ens2symbol$SYMBOL,sep="")
ens2symbol <- as_tibble(ens2symbol)
norm_counts_Ens <- norm_counts_Ens %>% column_to_rownames(var= "ens_gene") %>% dplyr::select(-gene)
norm_counts_Ens_WK2 <- norm_counts_Ens %>%  dplyr::select(starts_with("WK2_"))
```

```{r,fig.height=6}
top_kegg_up_full <- fgsea_kegg[ES > 0][size < 250][order(padj,-NES),][1:5]

for (i in 1:5) {
  # Full pathway
   #print(pathways.kegg[[top_kegg_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_kegg_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens_NSC[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens_NSC)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  print(pheatmap(gene_counts_rownorm, col = colors, main=top_kegg_up_full[i,pathway]))
 }
  
```



### GSEA GO BP Terms

```{r}
pathways.gobp <- gmtPathways("../genesets/c5.go.bp.v7.4.symbols.gmt")
fgsea_gobp <- fgseaMultilevel(pathways=pathways.gobp, stats=ranks, nPermSimple = 10000, maxSize = 500, minSize = 30)
# convert to tibble, sort by NES and select columns
fgsea_gobp_tidy <- fgsea_gobp %>% as_tibble() %>% arrange(padj) %>% dplyr::select(-pval, -ES)
# Show in a nice table:
fgsea_gobp_tidy %>% DT::datatable()
```




### Top 15 up and down regulated GOBP pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowd pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_gobp_up <- fgsea_gobp[ES > 0][size < 250][order(padj,-NES),pathway][1:15]
top_gobp_dn <- fgsea_gobp[ES < 0][size < 250][order(padj,NES),pathway][1:15]
top_gobp <- c(top_gobp_up, rev(top_gobp_dn))
plotGseaTable(pathways.gobp[top_gobp], ranks, fgsea_gobp, gseaParam = 0.5)
fgsea_gobp_tidy_top <- fgsea_gobp_tidy %>% filter(pathway %in% top_gobp)
```


```{r, fig.width=10}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_gobp_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down GO-BP pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=8))+theme(plot.title = element_text(size=7))
p1

```

### Enrichments plots for top GOBP hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.gobp[[top_gobp_up[i]]], ranks) + labs(title=top_gobp_up[i]))
}
```




### Leading Edge heatmaps for top GOBP hits

Heatmap of row noemalised rld regularised leg transformed size factor normalised read counts

```{r, echo=FALSE, message=FALSE, warning=FALSE, eval=FALSE}
norm_counts <- as.data.frame(assay(rld))
norm_counts <- norm_counts %>% rownames_to_column(var="gene")
norm_counts_Ens <- merge(norm_counts, t2g_genes[,c(4,9)], by.all="gene")
ens2symbol <- AnnotationDbi::select(org.Hs.eg.db, key=norm_counts_Ens$ens_gene, columns="SYMBOL", keytype="ENSEMBL", multiVals="first") %>% distinct()
ens2symbol$gene <- paste(ens2symbol$ENSEMBL,"-",ens2symbol$SYMBOL,sep="")
ens2symbol <- as_tibble(ens2symbol)
norm_counts_Ens <- norm_counts_Ens %>% column_to_rownames(var= "ens_gene") %>% dplyr::select(-gene)
norm_counts_Ens_WK2 <- norm_counts_Ens %>%  dplyr::select(starts_with("WK2_"))

```

```{r, fig.height=7}
top_gobp_up_full <- fgsea_gobp[ES > 0][size < 250][order(padj,-NES),][1:5]

for (i in 1:5) {
  # Full pathway
  # print(pathways.gobp[[top_gobp_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_gobp_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens_NSC[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens_NSC)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  print(pheatmap(gene_counts_rownorm, col = colors, main=top_gobp_up_full[i,pathway]))
 }
  
```




# Overlap of DEG: PD DEG (WK1 vs WK2) vs NSC DEG (WK 1 vs WK2)

+ As we can see there is a 30% overlap in the genes which are changing (up or down) between week1 and week2 for NSC and PD.
+ To get a PD and NSC specific signal we , need to only look at the gene subsets that do not overlap.

```{r, echo=FALSE, eval=T}
  
  d <- "PD vs NSC (WK1 vs WK2)"
res_print_WK2PD_WK1PD <- as.data.frame(res_print_WK2PD_WK1PD)
rownames(res_print_WK2PD_WK1PD) <- res_print_WK2PD_WK1PD$ens_gene

res_print_WK2NSC_WK1NSC <- as.data.frame(res_print_WK2NSC_WK1NSC)
rownames(res_print_WK2NSC_WK1NSC) <- res_print_WK2NSC_WK1NSC$ens_gene

  ## Venn Diagram: DEGs for all 3 pairwise comparisons
  sig_PD_up <- unique(rownames(res_print_WK2PD_WK1PD[res_print_WK2PD_WK1PD$fc == "up", ]))
  sig_PD_down <- unique(rownames(res_print_WK2PD_WK1PD[res_print_WK2PD_WK1PD$fc == "down", ]))
  sig_NSC_up <- unique(rownames(res_print_WK2NSC_WK1NSC [res_print_WK2NSC_WK1NSC$fc == "up", ]))
  sig_NSC_down <- unique(rownames(res_print_WK2NSC_WK1NSC[res_print_WK2NSC_WK1NSC$fc == "down", ]))
  
 # tiff(filename = "./DEG_genes_WK1_WK2_aggregate_vs_NSC_Venn_diagram.tiff", height = 4, width=6, units = "in", res=300)
 
 # cairo_ps("./DEG_genes_Venn_diagram.eps", height = 4, width = 5, onefile = F)
   venn.plot <- venn.diagram(x=list(S1=as.matrix(sig_PD_up), S2=as.matrix(sig_PD_down), S3=as.matrix(sig_NSC_up), S4=as.matrix(sig_NSC_down)), fill = c("red", "cyan3", "green3","yellow"), alpha=c(0.5, 0.5, 0.5,0.5), cex=0.6, cat.cex=0.55, fontfamily="sans", cat.fontfamily="sans", main.fontfamily = "sans", cat.dist=c(0.2,0.2,0.1,0.1),  filename=NULL, euler.d=F, scaled=F, print.mode=c("percent", "raw"), sigdigs = 2, category.names=paste0(c("PD UP", "PD Down","NSC UP","NSC Down"), "\n", c(length(sig_PD_up), length(sig_PD_down), length(sig_NSC_up), length(sig_NSC_down))), main = d, main.cex = 0.7)
  
  grid.newpage()
  grid.draw(venn.plot)
  #dev.off()

```


# Interaction between Treatment:condition

* So far everything done would match the V2 analysis where I DID NOT control for the PD vs NSC effect while looking for whats is changing  in WK2 vs WK1. Using the interaction term allows us to do that. We will be looking at that now.
* Is the PD vs NSC effect *different* between treatment times as well
* contrast terms : "Treatment_timeWK2.TreatmentPD"
* design " ~ Batch + Treatment_time + Treatment + TreatmentTime:Treatment
* DEG log2FC threshold = 0.0 and FDR 5%

 
```{r}

res_WK2WK1_PDNSC <- results(object=dds ,contrast = list("Treatment_timeWK2.TreatmentPD") , lfcThreshold = 0.0, alpha=0.05)
 mcols(res_WK2WK1_PDNSC)$description
 res_summary <- capture.output(summary(res_WK2WK1_PDNSC))
 cat(res_summary, sep="  \n* ")
 
 # number of differentially expressed genes based on cut off
 
 num_DEG <- sum(res_WK2WK1_PDNSC$padj < alpha_cutoff & abs(res_WK2WK1_PDNSC$log2FoldChange) > 0, na.rm=TRUE)
    cat("  \n* Genes with adjusted P-value not NA (universe of genes): ", sum(!is.na(res_WK2WK1_PDNSC$padj)))
    cat("  \n* Differentially expressed genes with log2fc > 0 & p.adjusted <0.05: ", num_DEG, "  \n")
resOrdered_WK2WK1_PDNSC <- res_WK2WK1_PDNSC[order(res_WK2WK1_PDNSC$padj),]
resOrdered_WK2WK1_PDNSC <- as.data.frame(resOrdered_WK2WK1_PDNSC )
#write.table(as.data.frame(resOrdered_WK1_PD_NSC), file = paste0("deseq2_results_","WK1_PD_vs._NSC",".txt"), sep="\t", quote=F)
```

### MA-plot

```{r}
res_WK2WK1_PDNSC_LFCshrink <- lfcShrink(dds = dds ,contrast = list("Treatment_timeWK2.TreatmentPD") ,type="ashr")
DESeq2::plotMA(res_WK2WK1_PDNSC_LFCshrink, ylim = c(-20,20))
resOrdered_WK2WK1_PDNSC_LFCshrink <- res_WK2WK1_PDNSC_LFCshrink[order(res_WK2WK1_PDNSC_LFCshrink$padj),]
resOrdered_WK2WK1_PDNSC_LFCshrink  <- as.data.frame(resOrdered_WK2WK1_PDNSC_LFCshrink)
```

### Dispersion plot

```{r, echo=FALSE, message=FALSE, warning=FALSE}
plotDispEsts(dds)
```


### Table of DEG

```{r}
top_genes <- 20

 #prnt table of up and down regulated genes from DEG
    
res_print_WK2WK1_PDNSC <- print_DESeq_table(res_WK2WK1_PDNSC_LFCshrink, t2g_info = t2g_genes, alpha_level = alpha_cutoff,logfcthreshold = 0)


    
    plot_up_genes <- res_print_WK2WK1_PDNSC[fc == "up", target_id][1:top_genes]
    plot_up_genes <- plot_up_genes[!(is.na(plot_up_genes))] # if there are not top_genes DEGs, NA values will be returned
    plot_down_genes <- res_print_WK2WK1_PDNSC[fc == "down", target_id][1:top_genes]
    plot_down_genes <- plot_down_genes[!(is.na(plot_down_genes))]
  
    
    
   res_print_WK2WK1_PDNSC <-res_print_WK2WK1_PDNSC[, gene_type := NULL] ## only protein coding genes
  res_print_WK2WK1_PDNSC <- res_print_WK2WK1_PDNSC[, target_id := NULL] ## remove "symbol - ensembl_ID"
    
    setnames(res_print_WK2WK1_PDNSC, "desc", "___________long_gene_description___________")
   res_print_WK2WK1_PDNSC <- res_print_WK2WK1_PDNSC %>% drop_na()
```



```{r}
res_print_WK2WK1_PDNSC %>% DT::datatable(caption="Interaction Treatment Time vs Condition", escape=F, extensions = 'Buttons', options = list(dom = 'Blfrtip', buttons = list('colvis', list(extend = 'copy', exportOptions = list(columns=':visible')), list(extend = 'csv', exportOptions = list(columns=':visible')), list(extend = 'excel', exportOptions = list(columns=':visible')))))
```


### Count Plots of Top genes


+ plot normalised counts for DEG for different groups

```{r, echo=F}
my_plot_counts <- function(obj, plot_genes=NULL, intgroup_vec=c("Group", "Batch"), t2g_info=NULL, n_ncol=4, n_nrow =6, title=NULL){

  # collect data for each gene
  plot_data_all <- as.data.table(plotCounts(obj, gene = plot_genes[1], intgroup_vec, returnData=TRUE,transform = F))
  plot_data_all[, gene := plot_genes[1]]
  plot_data_all[, gene_idx := formatC(1,width=2,flag='0')]
  
  if (length(plot_genes) >= 2){
    for (i in 2:length(plot_genes)){
      
      plot_data <- as.data.table(plotCounts(obj, gene = plot_genes[i], intgroup_vec, returnData=TRUE,transform = F))
      plot_data[, gene := plot_genes[i]]
      plot_data[, gene_idx := formatC(i,width=2,flag='0')]
      plot_data_all <- rbind(plot_data_all, plot_data)
    }
  }
  
  plot_data_all <- merge(plot_data_all, t2g_info[, .(gene, ext_gene)], by.x="gene", by.y="gene")
  # plot_data_all[, gene_print := paste0(gene_idx, "  ", gene, "  ", ext_gene)]
  # plot_data_all[, gene_print := paste0(gene_idx, "  ", gene)]
  plot_data_all[, gene_print := paste0(gene_idx, "  ", ext_gene)] ## use only gene symbol as facet title
  
  p <- ggplot(data = plot_data_all, aes(x=Group, y=log2(count+1), colour=Group,shape=Batch))
  p <- p + geom_violin(aes(group=Group), alpha = 0, colour = "gray60", scale="width")
  ## p <- p + ggbeeswarm::geom_quasirandom(alpha = 0.6, size = 3, groupOnX = TRUE)
  p <- p + geom_point(position = position_jitterdodge(), size=5, alpha=0.6)
  p <- p + xlab(NULL)
  p <- p + facet_wrap(~gene_print, ncol=n_ncol, scales="free_y",nrow = n_nrow)
  p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
  p <- p + ylab("log2(normalised count + 1)") + theme(legend.position="top")
  p <- p + theme(axis.text.x=element_text(angle=90, hjust=1, size=10)) + theme(axis.text.y = element_text(size=8))
  p <- p + ggtitle(title)
  p
}

```


```{r, echo=FALSE, fig.height=4, fig.width=8}
my_plot_counts(dds, plot_genes = plot_up_genes,title="upregulated genes in Time:condition interaction", t2g_info = t2g_genes, n_ncol = 5)
```

```{r, echo=FALSE, fig.height=4, fig.width=10}
my_plot_counts(dds, plot_genes = plot_down_genes,title="downregulated genes inTime:condition interaction", t2g_info = t2g_genes, n_ncol = 5)
```


```{r,echo=FALSE, fig.height=5, fig.width=10, eval=F}
control_genes <- c("OPA1 - ENSG00000198836","MFN1 - ENSG00000171109","TOMM20 - ENSG00000173726","DNM1L - ENSG00000087470","TFAM - ENSG00000108064","NRF1 - ENSG00000106459","NFE2L2 - ENSG00000116044","MTOR - ENSG00000198793","HIF1A - ENSG00000100644","ARNT - ENSG00000143437","SNCA - ENSG00000145335","PARK7 - ENSG00000116288","OMA1 - ENSG00000162600","MFN1 - ENSG00000171109")

#t2g_genes_control <- t2g_genes %>% filter(gene %in% control_genes) %>% select(gene)
control_genes_sig <- resOrdered_WK2WK1_PDNSC_LFCshrink %>% filter(rownames(.) %in% control_genes & padj<0.05 )
my_plot_counts(dds, plot_genes = rownames(control_genes_sig),title="interesting significant PD genes", t2g_info = t2g_genes)
#PGC-1alpha = ENSG00000109819
# OMA1 - ENSG00000162600
# OPA1 - ENSG00000198836
# Mitofusin - ENSG00000171109
# TOM20 - ENSG00000173726
# DNM1L - ENSG00000087470
# TFAM - ENSG00000108064
# NRF1 - ENSG00000106459
# NFE2L2 -  ENSG00000116044
# TFEB - ENSG00000112561
# MTOR - ENSG00000198793
# HIF1a - ENSG00000100644
# HIF1b -  ENSG00000143437
#SNCA - ENSG00000145335
# PARK7 - ENSG00000116288
```




```{r,eval=FALSE}
### Plot SNCA counts in Week2 samples only
 plot_data_SNCA <- plotCounts(dds = dds, gene = "SNCA - ENSG00000145335", intgroup =c("Group2", "Stimulation","Treatment_time","Replicate","Treatment"), returnData=TRUE,transform = F)
plot_data_SNCA_wk2 <- plot_data_SNCA %>% filter(Treatment_time == "WK2")

 p <- ggplot(data = plot_data_SNCA_wk2, aes(x=Group2, y=log2(count+1), colour=Stimulation))
  p <- p + geom_violin(aes(group=Group2), alpha = 0, colour = "gray60", scale="width")
  ## p <- p + ggbeeswarm::geom_quasirandom(alpha = 0.6, size = 3, groupOnX = TRUE)
  p <- p + geom_point(position = position_jitterdodge(), size=5, alpha=0.6, aes(shape = Treatment))
  p <- p + xlab(NULL)
 # p <- p + facet_wrap(~gene_print, ncol=n_ncol, scales="free_y",nrow = n_nrow)
  p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
  p <- p + ylab("log2(normalised count + 1)") + theme(legend.position="right")
  p <- p + theme(axis.text.x=element_text(angle=90, hjust=1, size=10)) + theme(axis.text.y = element_text(size=8))
  p <- p + ggtitle("SNCA-ENSG00000145335") 
  p
 # ggsave(filename = "RNASEQ_WK2_SNCA_normalised_counts_plot.pdf",width = 5, height = 5,units = "in", dpi = 300)
```





```{r,echo=FALSE}

# Get ENSEMBLE IDS

resOrdered_WK2WK1_PDNSC_LFCshrink$gene <- rownames(resOrdered_WK2WK1_PDNSC_LFCshrink)
resOrdered_WK2WK1_PDNSC_LFCshrink_ens <- merge(resOrdered_WK2WK1_PDNSC_LFCshrink, t2g_genes, by.all ="gene")
rownames(resOrdered_WK2WK1_PDNSC_LFCshrink_ens) <- resOrdered_WK2WK1_PDNSC_LFCshrink_ens$ens_gene
rm(resOrdered_WK2WK1_PDNSC)
resOrdered_WK2WK1_PDNSC_LFCshrink_ens <- resOrdered_WK2WK1_PDNSC_LFCshrink_ens[,c(1:7,11)]

# get rid of NAs for clusterprofiler
#library(tidyr)
resOrdered_WK2WK1_PDNSC_LFCshrink_ens <- resOrdered_WK2WK1_PDNSC_LFCshrink_ens%>% drop_na()

# map ids using annotation db
library(org.Hs.eg.db)
library(AnnotationDbi)

resOrdered_WK2WK1_PDNSC_LFCshrink_ens$entrez <- mapIds(org.Hs.eg.db, keys= rownames(resOrdered_WK2WK1_PDNSC_LFCshrink_ens), column = "ENTREZID", keytype = "ENSEMBL", multiVals = "first")
resOrdered_WK2WK1_PDNSC_LFCshrink_ens$symbol <- mapIds(org.Hs.eg.db, keys= rownames(resOrdered_WK2WK1_PDNSC_LFCshrink_ens), column = "SYMBOL", keytype = "ENSEMBL", multiVals = "first")
write.table(resOrdered_WK2WK1_PDNSC_LFCshrink_ens, file="deseq2_results_Jan_Jun_21_WK2WK1_vs_NSCPD_interaction.txt", sep="\t", quote=F)


```

### Volcano plot 

```{r, fig.height=6, fig.width=8}
library(EnhancedVolcano)
 Vol <- EnhancedVolcano(resOrdered_WK2WK1_PDNSC_LFCshrink_ens,
    lab = resOrdered_WK2NSC_WK1NSC_LFCshrink_ens$symbol,
    x = 'log2FoldChange',
    y = 'pvalue', subtitle = "", title = "Treatment:condition interaction", xlim = c(-26,26), labSize =3, FCcutoff = 0.20, axisLabSize = 6, titleLabSize = 8, legendLabSize = 6, pCutoff = 0.05, pCutoffCol = "padj",   drawConnectors = F, captionLabSize = 6,
    widthConnectors = 0.2, colConnectors = 'grey30',caption = "Log2FC cutoff = 0.20; p-value cutoff=0.05" )
# Vol <-   Vol +  ggplot2::coord_cartesian(xlim=c(-28, 26))  + ggplot2::scale_x_continuous(breaks=seq(-28,23, 5))
 Vol
```

```{r,echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE}
library(fgsea)
gsea_res_WK2WK1_PDNSC <- resOrdered_WK2WK1_PDNSC_LFCshrink_ens %>% dplyr::select(symbol,log2FoldChange) %>% na.omit() %>% distinct() %>% group_by(symbol) %>% summarize(log2FoldChange=mean(log2FoldChange))
# dim(gsea_res)
# head(gsea_res)

# fast Gene Set Enrichment Analysis
ranks <- deframe(gsea_res_WK2WK1_PDNSC)

```

### GSEA Reactome Pathways

```{r}
#pathways.reactome <- gmtPathways("./genesets/c2.cp.reactome.v7.1.symbols.gmt")
fgsea_reactome <- fgseaMultilevel(pathways=pathways.reactome, stats=ranks, nPermSimple = 10000, maxSize = 500, minSize = 30)
# convert to tibble, sort by NES and select columns
fgsea_reactome_tidy <- fgsea_reactome %>% as_tibble() %>% arrange(padj) %>% dplyr::select(-pval, -ES)
# Show in a nice table:
fgsea_reactome_tidy %>% DT::datatable()
```



### Top 15 up and down regulated Reactome pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowd pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_reactome_up <- fgsea_reactome[ES > 0][size < 250][order(padj,-NES),pathway][1:15]
top_reactome_dn <- fgsea_reactome[ES < 0][size < 250][order(padj,NES),pathway][1:15]
top_reactome <- c(top_reactome_up, rev(top_reactome_dn))
plotGseaTable(pathways.reactome[top_reactome], ranks, fgsea_reactome, gseaParam = 0.5)
fgsea_reactome_tidy_top <- fgsea_reactome_tidy %>% filter(pathway %in% top_reactome)
```


```{r, fig.width=12}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_reactome_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down Reactome pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=8))+theme(plot.title = element_text(size=7))
p1

```

### Enrichments plots for top Reactome hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.reactome[[top_reactome_up[i]]], ranks) + labs(title=top_reactome_up[i]))
}
```



### Leading Edge heatmaps for top Reactome hits

Heatmap of row normalised rld regularised leg transformed size factor normalised read counts

```{r, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
norm_counts <- as.data.frame(assay(rld))
norm_counts <- norm_counts %>% rownames_to_column(var="gene")
norm_counts_Ens <- merge(norm_counts, t2g_genes[,c(4,9)], by.all="gene")
ens2symbol <- AnnotationDbi::select(org.Hs.eg.db, key=norm_counts_Ens$ens_gene, columns="SYMBOL", keytype="ENSEMBL", multiVals="first") %>% distinct()
ens2symbol$gene <- paste(ens2symbol$ENSEMBL,"-",ens2symbol$SYMBOL,sep="")
ens2symbol <- as_tibble(ens2symbol)
norm_counts_Ens <- norm_counts_Ens %>% column_to_rownames(var= "ens_gene") %>% dplyr::select(-gene)
#norm_counts_Ens_NSC <- norm_counts_Ens %>%  dplyr::select(ends_with("PD"))

```

```{r,fig.height=8, fig.width=10}
top_reactome_up_full <- fgsea_reactome[ES > 0][size < 250][order(padj,-NES),][1:5]

for (i in 1:5) {
  # Full pathway
  # print(pathways.reactome[[top_reactome_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_reactome_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  print(pheatmap(gene_counts_rownorm, col = colors, main=top_reactome_up_full[i,pathway]))
 }
  
```

### GSEA KEGG Pathways

```{r}
#pathways.kegg <- gmtPathways("./genesets/c2.cp.kegg.v7.1.symbols.gmt")
fgsea_kegg <- fgseaMultilevel(pathways=pathways.kegg, stats=ranks, nPermSimple = 10000, maxSize = 500, minSize = 30)
# convert to tibble, sort by NES and select columns
fgsea_kegg_tidy <- fgsea_kegg %>% as_tibble() %>% arrange(padj) %>% dplyr::select(-pval, -ES)
# Show in a nice table:
fgsea_kegg_tidy %>% DT::datatable()
```





### Top 15 up and down regulated KEGG pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowd pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_kegg_up <- fgsea_kegg[ES > 0][size < 250][order(padj,-NES),pathway][1:15]
top_kegg_dn <- fgsea_kegg[ES < 0][size < 250][order(padj,NES),pathway][1:15]
top_kegg <- c(top_kegg_up, rev(top_kegg_dn))
plotGseaTable(pathways.kegg[top_kegg], ranks, fgsea_kegg, gseaParam = 0.5)
fgsea_kegg_tidy_top <- fgsea_kegg_tidy %>% filter(pathway %in% top_kegg)
```


```{r, fig.width=12}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_kegg_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down KEGG pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=8))+theme(plot.title = element_text(size=7))
p1

```

### Enrichments plots for top KEGG hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.kegg[[top_kegg_up[i]]], ranks) + labs(title=top_kegg_up[i]))
}
```




### Leading Edge heatmaps for top KEGG hits

Heatmap of row noemalised rld regularised leg transformed size factor normalised read counts

```{r, echo=FALSE, message=FALSE, warning=FALSE, eval=FALSE}
norm_counts <- as.data.frame(assay(rld))
norm_counts <- norm_counts %>% rownames_to_column(var="gene")
norm_counts_Ens <- merge(norm_counts, t2g_genes[,c(4,9)], by.all="gene")
ens2symbol <- AnnotationDbi::select(org.Hs.eg.db, key=norm_counts_Ens$ens_gene, columns="SYMBOL", keytype="ENSEMBL", multiVals="first") %>% distinct()
ens2symbol$gene <- paste(ens2symbol$ENSEMBL,"-",ens2symbol$SYMBOL,sep="")
ens2symbol <- as_tibble(ens2symbol)
norm_counts_Ens <- norm_counts_Ens %>% column_to_rownames(var= "ens_gene") %>% dplyr::select(-gene)
#norm_counts_Ens_WK2 <- norm_counts_Ens %>%  dplyr::select(starts_with("WK2_"))
```

```{r,fig.height=8, fig.width=10}
top_kegg_up_full <- fgsea_kegg[ES > 0][size < 250][order(padj,-NES),][1:5]

for (i in 1:5) {
  # Full pathway
   #print(pathways.kegg[[top_kegg_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_kegg_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  print(pheatmap(gene_counts_rownorm, col = colors, main=top_kegg_up_full[i,pathway]))
 }
  
```


### GSEA GO BP Terms

```{r}
pathways.gobp <- gmtPathways("../genesets/c5.go.bp.v7.4.symbols.gmt")
fgsea_gobp <- fgseaMultilevel(pathways=pathways.gobp, stats=ranks, nPermSimple = 10000, maxSize = 500, minSize = 30)
# convert to tibble, sort by NES and select columns
fgsea_gobp_tidy <- fgsea_gobp %>% as_tibble() %>% arrange(padj) %>% dplyr::select(-pval, -ES)
# Show in a nice table:
fgsea_gobp_tidy %>% DT::datatable()
```


### Top 15 up and down regulated GOBP pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowd pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_gobp_up <- fgsea_gobp[ES > 0][size < 250][order(padj,-NES),pathway][1:15]
top_gobp_dn <- fgsea_gobp[ES < 0][size < 250][order(padj,NES),pathway][1:15]
top_gobp <- c(top_gobp_up, rev(top_gobp_dn))
plotGseaTable(pathways.gobp[top_gobp], ranks, fgsea_gobp, gseaParam = 0.5)
fgsea_gobp_tidy_top <- fgsea_gobp_tidy %>% filter(pathway %in% top_gobp)
```


```{r, fig.width=10}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_gobp_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down GO-BP pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=8))+theme(plot.title = element_text(size=7))
p1

```

### Enrichments plots for top GOBP hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.gobp[[top_gobp_up[i]]], ranks) + labs(title=top_gobp_up[i]))
}
```




### Leading Edge heatmaps for top GOBP hits

Heatmap of row noemalised rld regularised leg transformed size factor normalised read counts

```{r, echo=FALSE, message=FALSE, warning=FALSE, eval=FALSE}
norm_counts <- as.data.frame(assay(rld))
norm_counts <- norm_counts %>% rownames_to_column(var="gene")
norm_counts_Ens <- merge(norm_counts, t2g_genes[,c(4,9)], by.all="gene")
ens2symbol <- AnnotationDbi::select(org.Hs.eg.db, key=norm_counts_Ens$ens_gene, columns="SYMBOL", keytype="ENSEMBL", multiVals="first") %>% distinct()
ens2symbol$gene <- paste(ens2symbol$ENSEMBL,"-",ens2symbol$SYMBOL,sep="")
ens2symbol <- as_tibble(ens2symbol)
norm_counts_Ens <- norm_counts_Ens %>% column_to_rownames(var= "ens_gene") %>% dplyr::select(-gene)
#norm_counts_Ens_WK2 <- norm_counts_Ens %>%  dplyr::select(starts_with("WK2_"))

```

```{r, fig.height=8, fig.width=12}
top_gobp_up_full <- fgsea_gobp[ES > 0][size < 250][order(padj,-NES),][1:5]

for (i in 1:5) {
  # Full pathway
  # print(pathways.gobp[[top_gobp_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_gobp_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  print(pheatmap(gene_counts_rownorm, col = colors, main=top_gobp_up_full[i,pathway]))
 }
  
```




```{r}
sessionInfo()
```


---
title: "George_Tofaris_iPSC_pooled_PD_treatments_NSC"
author: "Devika Agarwal"
date: 'Last update: `r date()`'
output:
  html_document:
    theme: cerulean
    number_sections: true
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: yes
      toc_depth: 8
---
<style type="text/css">

body{ /* Normal  */
      font-size: 12px;
  }
td {  /* Table  */
  font-size: 12px;
}
h1.title {
  font-size: 18px;
  color: DarkRed;
}
h1 { /* Header 1 */
  font-size: 16px;
  color: DarkBlue;
}
h2 { /* Header 2 */
    font-size: 16px;
  color: DarkBlue;
}
h3 { /* Header 3 */
  font-size: 14px;
  font-family: "Times New Roman", Times, serif;
  color: DarkBlue;
}
code.r{ /* Code block */
    font-size: 12px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 14px;
}
</style>
```{r setup, include=F, message=F, warning=FALSE}
knitr::opts_chunk$set(echo=FALSE,message=FALSE,warning=FALSE, cache=TRUE)
#rm(list=ls())
#biocLite("sva") #install sva
#install.packages("DT")
#install.packages("png")
library(knitr)
library(sva)
library(DT)
library(png)
library(grid)
library(plyr)
#biocLite("biomaRt")
library(biomaRt)
library(tidyverse)
library(corrr)
#install.packages("gplots")
library(gplots)
#install.packages("dendextend")
library(dendextend)
library(ggplot2)
#biocLite("oligo")
#library(oligo)
#install.packages("data.table")
library(data.table)
#source("https://bioconductor.org/biocLite.R")
#biocLite("limma")
#library(limma)
#source("https://bioconductor.org/biocLite.R")
#biocLite("DESeq2")
library(DESeq2)
#install.packages("stringr")
library(stringr)
#install.packages("RColorBrewer")
library(RColorBrewer)
#library(scater)
library(tximport) # here only needed to get and report effective gene lengths
library(readr) # used by tximport for faster import
library(VennDiagram)
library(ggrepel)
library(clusterProfiler)
library(GeneTonic)
library(viridis)
library(splitstackshape) # for splitting data table columns
#library(tximeta)


futile.logger::flog.threshold(futile.logger::ERROR, name = "VennDiagramLogger")

## white background theme for all plots
theme_set(theme_bw())
multicoreParam <- MulticoreParam(workers = 6)
multicoreParam
```


```{r functions}
# Vector to colours
Vector2Colour <- function(clase, ucol2 = c("red", "blue"), alfa = .8, Pal = "Blues"){
  colores <- vector(length = length(clase))
  if(is.numeric(clase)){
    pal1 <- colorRampPalette(brewer.pal(n = 9, name = Pal)[3:9], space = "Lab")
    ucol <- pal1(length(unique(clase)))
    rk <- rank(clase)
    rku <- unique(rk)
    rku <- rku[order(rku)]
    for (i in c(1:length(ucol))){
      colores[which(rank(clase) == rku[i])] <- ucol[i]    
    }
  } else {
    if(length(unique(clase)) == 2){
      ucol <- ucol2
      for (i in c(1:length(ucol))){
        colores[which(clase == unique(clase)[i])] <- ucol[i]    
      }
    } else {
      if(length(unique(clase)) < 9){
        pal1 <- brewer.pal(9, "Set1")[-6] # Remove yellow
        ucol <- pal1[1:length(unique(clase))]
        for (i in c(1:length(ucol))){
          colores[which(clase == unique(clase)[i])] <- ucol[i]    
        }
      } else {
        if(length(unique(clase)) > 8){
          pal1 <- colorRampPalette(brewer.pal(n = 7, name = "Dark2"), space = "Lab")
          ucol <- pal1(length(unique(clase)))
          for (i in c(1:length(ucol))){
            colores[which(clase == unique(clase)[i])] <- ucol[i]    
          }
        }
      }
    }  
  }
  colores <- alpha(colores, alpha = alfa)
  return(colores)
}


# From_Jimena
# Hyperlinks to ensembl 
ens_links <- function(geneids){
  genelinks <- vector()
  for (i in c(1:length(geneids))){
  genelinks[i] <- paste('<a href="', paste("http://www.ensembl.org/Mus_musculus/Gene/Summary?g=", geneids[i], sep = ""),'">', geneids[i], '</a>', sep = "")   }
  return(genelinks)
}  

ensembl_url <- "<a href=\"http://www.ensembl.org/Homo_sapiens/Gene/Summary?g="

# From_Frank
# create hyperlinks in tables printed with the DT package
set_hyperlinks <- function(DT, col_names, url_strings) {
  DT_out <- copy(DT)  
  for (i in 1:length(col_names)){
    ## DT_out[, (col_names[i]) := paste0(url_strings[i], get(col_names[i]),"\">", get(col_names[i]),"</a>")]
    DT_out[(col_names[i]) != '', (col_names[i]) := paste0(url_strings[i], get(col_names[i]),"\">", get(col_names[i]),"</a>")]
  }
  DT_out
}

# From Jimena
# TPM_matrix from tx object #
TPM_from_tx <- function(tx_import_object){
  countsbylength <- tx_import_object$counts/tx_import_object$length
  total_countsbylength <- colSums(countsbylength)
  data_TPM <- t(apply(countsbylength, 1, function(x) x / total_countsbylength * 1000000))
  colnames(data_TPM) <- colnames(tx_import_object$counts)
  return(data_TPM)
}

## re-format DESeq2 results table


print_DESeq_table <- function(A, alpha_level = 0.05, t2g_info = t2g_genes, merge_column = "gene", logfcthreshold=0){
  
  A_2 <- as.data.table(A)
  A_2 <- A_2[, target_id := rownames(A)]
  A_2 <- A_2[order(pvalue)]
  A_2 <- A_2[log2FoldChange < (logfcthreshold), fc := "down"]
  A_2[log2FoldChange < (logfcthreshold) & !is.na(padj), rank := 1:sum(log2FoldChange < (logfcthreshold))]
  A_2 <- A_2[log2FoldChange > logfcthreshold, fc := "up"]
  A_2[log2FoldChange > logfcthreshold & !is.na(padj), rank := 1:sum(log2FoldChange > logfcthreshold)]
  
  A_2 <- A_2[padj < alpha_level, ]
  
  A_2[,c("lfcSE") := NULL]
  
  C <- merge(A_2, t2g_info[, .(gene, ens_gene, gene_type, ext_gene, desc)], by.x="target_id", by.y=merge_column, all.x=T)
  ### C <- C[, target_id := NULL] ## keep for now, for look-up
  
  setcolorder(C, c("target_id", "ext_gene", "ens_gene", "log2FoldChange","pvalue", "padj", "fc", "rank", "baseMean", "gene_type", "desc"))
  
  C[, c("log2FoldChange","pvalue","padj") := list(signif(log2FoldChange, 3), signif(pvalue, 3), signif(padj, 3))]
  C[, baseMean := round(baseMean, digits=1)]
  setnames(C, c("log2FoldChange"), c("log2FC"))
  C[order(pvalue)]
}




## create table to combine results from 3 concentrations
print_DESeq_union_table <- function(L, M, H, alpha_level = 0.05, t2g_info = t2g_genes, merge_column = "target_id"){
  
  setnames(L, c("target_id", paste0(colnames(L)[-1], "_L")))
  setnames(M, c("target_id", paste0(colnames(M)[-1], "_M")))
  setnames(H, c("target_id", paste0(colnames(H)[-1], "_H")))
  
  C <- merge(L[, .(target_id, log2FoldChange_L, padj_L)], M[, .(target_id, log2FoldChange_M, padj_M)], by="target_id")
  C <- merge(C, H[, .(target_id, log2FoldChange_H, padj_H)], by="target_id")
  
  C <- C[log2FoldChange_L < 0, fc_L := "down"]
  C <- C[log2FoldChange_L > 0, fc_L := "up"]
  C <- C[log2FoldChange_M < 0, fc_M := "down"]
  C <- C[log2FoldChange_M > 0, fc_M := "up"]
  C <- C[log2FoldChange_H < 0, fc_H := "down"]
  C <- C[log2FoldChange_H > 0, fc_H := "up"]
  
  C <- C[, sig_num := sum(padj_L < alpha_cutoff, padj_M < alpha_cutoff, padj_H < alpha_cutoff, na.rm = T), by="target_id"]
  C <- C[padj_L < alpha_cutoff, L := "L"]
  C <- C[padj_M < alpha_cutoff, M := "M"]
  C <- C[padj_H < alpha_cutoff, H := "H"]
  
  C <- merge(C, t2g_info[, .(target_id, ens_gene, ext_gene, desc)], by.x="target_id", by.y=merge_column, all.x=T)
  C <- C[, target_id := NULL]
  
  setcolorder(C, c("ext_gene", "ens_gene", "sig_num", c("L","M","H"), paste0("fc_", c("L","M","H")), paste0("log2FoldChange_", c("L","M","H")), paste0("padj_", c("L","M","H")), "desc"))
  
  C[, c(paste0("log2FoldChange_", c("L","M","H")), paste0("padj_", c("L","M","H"))) := list(signif(log2FoldChange_L, 3), signif(log2FoldChange_M, 3), signif(log2FoldChange_H, 3), signif(padj_L, 3), signif(padj_M, 3), signif(padj_H, 3))]
  
  setnames(C, paste0("log2FoldChange_", c("L","M","H")), paste0("l2fc_", c("L","M","H")))
  C[order(-sig_num)]
}


## print top DEGs
# get data from DESeq2 plotCounts function
# counts data is normalized 
# from `DESeq2::counts`: normalized: logical indicating whether or not to divide the counts by the size factors or normalization factors before returning (normalization factors always preempt size factors)
my_plot_counts <- function(obj, plot_genes=NULL, intgroup_vec=c("Treatment_time", "Group"), t2g_info=NULL, n_ncol=4, n_nrow =6, title=NULL){

  # collect data for each gene
  plot_data_all <- as.data.table(plotCounts(obj, gene = plot_genes[1], intgroup_vec, returnData=TRUE,transform = F))
  plot_data_all[, gene := plot_genes[1]]
  plot_data_all[, gene_idx := formatC(1,width=2,flag='0')]
  
  if (length(plot_genes) >= 2){
    for (i in 2:length(plot_genes)){
      
      plot_data <- as.data.table(plotCounts(obj, gene = plot_genes[i], intgroup_vec, returnData=TRUE,transform = F))
      plot_data[, gene := plot_genes[i]]
      plot_data[, gene_idx := formatC(i,width=2,flag='0')]
      plot_data_all <- rbind(plot_data_all, plot_data)
    }
  }
  
  plot_data_all <- merge(plot_data_all, t2g_info[, .(gene, ext_gene)], by.x="gene", by.y="gene")
  # plot_data_all[, gene_print := paste0(gene_idx, "  ", gene, "  ", ext_gene)]
  # plot_data_all[, gene_print := paste0(gene_idx, "  ", gene)]
  plot_data_all[, gene_print := paste0(gene_idx, "  ", ext_gene)] ## use only gene symbol as facet title
  
  p <- ggplot(data = plot_data_all, aes(x=Group, y=log2(count+1), colour=Treatment_time))
  p <- p + geom_violin(aes(group=Group), alpha = 0, colour = "gray60", scale="width")
  ## p <- p + ggbeeswarm::geom_quasirandom(alpha = 0.6, size = 3, groupOnX = TRUE)
  p <- p + geom_point(position = position_jitterdodge(), size=5, alpha=0.6)
  p <- p + xlab(NULL)
  p <- p + facet_wrap(~gene_print, ncol=n_ncol, scales="free_y",nrow = n_nrow)
  p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
  p <- p + ylab("log2(normalised count + 1)") + theme(legend.position="top")
  p <- p + theme(axis.text.x=element_text(angle=90, hjust=1, size=10)) + theme(axis.text.y = element_text(size=8))
  p <- p + ggtitle(title)
  p
}


getRScore <- function(geneIDs, DEGs) {
  pathgenes <- str_split(geneIDs, "/") %>% unlist()
  deRes <- as.data.frame(DEGs)
  deRes <- subset(deRes,deRes$symbol %in% pathgenes)
  up <- deRes %>% dplyr::filter(log2FoldChange > 0) %>% nrow()
  down <- deRes %>% dplyr::filter(log2FoldChange < 0) %>% nrow()
  
  score <- (up - down) / nrow(deRes)
  
  
  return(score)
}

RScorePlot <- function(enrichObj, DESeqRes, showCategory = 25, textSize = 10, title = NULL) {
  df <- enrichObj@result %>% 
    separate(GeneRatio, c("obs_hits", "obs_total"), "/") %>% 
    separate(BgRatio, c("exp_hits", "exp_total"), "/")
  df$Rscore <- map_dbl(enrichObj@result$geneID, getRScore, DESeqRes)
  df <- df %>% 
    mutate_at(3:6, as.numeric) %>% 
    dplyr::mutate(enrichScore = (obs_hits/obs_total)/(exp_hits/exp_total)) %>% 
    as.data.frame() %>% 
    dplyr::arrange(p.adjust) %>% 
    dplyr::slice(1:showCategory)

  p <- df %>% 
    ggplot(aes(x = reorder(Description, -log10(p.adjust)), y = -log10(p.adjust))) +
    geom_point(aes(col = Rscore, size = enrichScore)) +
    coord_flip() +
    scale_color_distiller(limits = c(-1, 1), type = "div", palette = "RdBu", direction = 1 ) +
    ylab("adjusted p-value (-log10)") +
    xlab(NULL) +
    ggtitle(title) +
    theme_bw() +
    theme(text = element_text(size = textSize))
  return(p)
}


RScorePlot_v2 <- function(enrichObj, DESeqRes, showCategory = 25, textSize = 10, title = NULL) {
  df <- enrichObj@result %>% 
    separate(GeneRatio, c("obs_hits", "obs_total"), "/") %>% 
    separate(BgRatio, c("exp_hits", "exp_total"), "/")
  df$Rscore <- map_dbl(enrichObj@result$geneID, getRScore, DESeqRes)
  df <- df %>% 
    dplyr::filter(Count >=10 & p.adjust < 0.05) %>%
    mutate_at(3:6, as.numeric) %>% 
    dplyr::mutate(enrichScore = (obs_hits/obs_total)/(exp_hits/exp_total)) %>% 
    as.data.frame() %>% 
    dplyr::arrange(p.adjust) %>% 
    dplyr::slice(1:showCategory)

  p <- df %>% 
    ggplot(aes(x = reorder(Description, -log10(p.adjust)), y = -log10(p.adjust))) +
    geom_point(aes(col = Rscore, size =Count)) +
    coord_flip() +
    scale_color_distiller(limits = c(-1, 1), type = "div", palette = "RdBu", direction = 1 ) +
    ylab("adjusted p-value (-log10)") +
    xlab(NULL) +
    ggtitle(title) +
    theme_bw() +
    theme(text = element_text(size = textSize))
  return(p)
}

RScorePlot_v3 <- function(enrichObj, DESeqRes, showCategory = 25, textSize = 10, title = NULL) {
  df <- enrichObj@result %>% 
    separate(GeneRatio, c("obs_hits", "obs_total"), "/") %>% 
    separate(BgRatio, c("exp_hits", "exp_total"), "/")
  df$Rscore <- map_dbl(enrichObj@result$geneID, getRScore, DESeqRes)
  df <- df %>% 
    mutate_at(3:6, as.numeric) %>% 
    dplyr::mutate(enrichScore = (obs_hits/obs_total)/(exp_hits/exp_total)) %>% 
    as.data.frame() %>% 
    dplyr::arrange(p.adjust) %>% 
    dplyr::slice(1:showCategory)

  p <- df %>% 
    ggplot(aes(x = reorder(Description, -log10(p.adjust)), y = -log10(p.adjust))) +
    geom_point(aes(col = Rscore, size =Count)) +
    coord_flip() +
    scale_color_distiller(limits = c(-1, 1), type = "div", palette = "RdBu", direction = 1 ) +
    ylab("adjusted p-value (-log10)") +
    xlab(NULL) +
    ggtitle(title) +
    theme_bw() +
    theme(text = element_text(size = textSize))
  return(p)
}


pcaCorrPlot <- function(counts, ntop = 2000, metadata, returnData = FALSE) {
  #pca
  rv <- rowVars(assay(counts))
  rowSel <- order(rv, decreasing = T)[seq_len(ntop)]
  pca <- prcomp(t(assay(counts)[rowSel, ]))
  percentVar <- pca$sdev^2 / sum(pca$sdev^2)

  #attach PCs to metadata
  pc.df <- pca$x %>% 
    as.data.frame() %>% 
    rownames_to_column(var = "sample")
  meta <- metadata %>% 
    mutate(joinName = paste(sample, treatment, sep = "."))
  meta <- inner_join(meta, pc.df, by = c( "joinName" = "sample"))
  meta <- meta %>% 
    dplyr::select(-disease, -joinName, -fastq, -mapped)

  #column names by variable type
  facCols <- meta %>% 
    dplyr::select_if(is.factor) %>%
    colnames()

  pcCols <- meta %>%
    dplyr::select(starts_with("PC")) %>%
    colnames()

  #factor correlations
  facCor.df <- expand.grid(pcCols, facCols) 

  rsquared <- facCor.df %>%
    apply(1, function(x) reformulate(x[2], x[1])) %>%
    lapply(., lm, data = meta) %>%
    map(summary) %>%
    map_dbl("r.squared")

  facCor.df$corr <- sqrt(rsquared)

  facCor.df <- facCor.df %>%
    dplyr::rename(PC = Var1, covariate = Var2) %>%
    mutate(type = "lm")

  #numeric correlations
  numCor.df <- meta %>%
    dplyr::select_if(is.numeric) %>%
    correlate(method = "kendall") %>%
    focus(-matches("^PC")) %>%
    gather(variable, corr, 2:7) %>%
    mutate(type = "kendall") %>%
    dplyr::rename(PC = rowname, covariate = variable)

  #combine
  pcaBar <- bind_rows(numCor.df, facCor.df)

  #filter sample and sex
  pcaBar <- pcaBar %>%
    filter( ! (covariate %in% c("sample", "sex")))

  #add percent variation
  pcs <- paste("PC", 1:8, sep = "")
  pvar <- data.frame( PC = pcs, perVar = paste(pcs, " (", sprintf("%.2f", percentVar * 100), "%)", sep = ""))
  pcaBar <- inner_join(pcaBar, pvar)

  #arrange
  pcaBar <- pcaBar %>%
    group_by(PC) %>%
    arrange(corr) %>%
    unite("pcvar", PC, covariate, sep = "_", remove = F) %>%
    data.frame() %>%
    mutate(pcvar = factor(pcvar, levels = pcvar))

  #return data
  if (returnData) {
    return(pcaBar)
  }

  #plot
  pcaBar %>%
    group_by(PC) %>%
    ggplot(aes(x = pcvar, y = corr)) +
    geom_col(aes(fill = type)) +
    coord_flip() + 
    facet_wrap( ~ perVar, scale = "free_y") +
    xlab("metadata") +
    ylab("correlation") +
    scale_x_discrete(breaks = pcaBar$pcvar, labels = pcaBar$covariate) +
    scale_y_continuous(limits = c(-1, 1)) +
    scale_fill_manual(values = c("darkorange", "dodgerblue")) +
    theme_bw()

}

plotPCA_higher_2_3 <- function(object, intgroup = "condition", ntop=1000, returnData = FALSE) {
        rv <- rowVars(assay(object))
        select <- order(rv, decreasing = TRUE)[seq_len(min(ntop,
            length(rv)))]
        pca <- prcomp(t(assay(object)[select, ]))
        percentVar <- pca$sdev^2/sum(pca$sdev^2)
        if (!all(intgroup %in% names(colData(object)))) {
            stop("the argument 'intgroup' should specify columns of colData(dds)")
        }
        intgroup.df <- as.data.frame(colData(object)[, intgroup,
            drop = FALSE])
        group <- if (length(intgroup) > 1) {
            factor(apply(intgroup.df, 1, paste, collapse = ":"))
        }
        else {
            colData(object)[[intgroup]]
        } 
        d <- data.frame(PC2 = pca$x[, 2], PC3 = pca$x[, 3], group = group,
            intgroup.df, name = colnames(object))
        if (returnData) {
            attr(d, "percentVar") <- percentVar[2:3]
            return(d)
        }
        g<-ggplot(data = d, aes_string(x = "PC2", y = "PC3", color = "group")) +
            geom_point(size = 3) + xlab(paste0("PC2: ", round(percentVar[2] *
            100,2), "%")) + ylab(paste0("PC3: ", round(percentVar[3] *
            100,2), "%")) + coord_fixed()
        return(g)
}


plotPCA_higher_3_4 <- function(object, intgroup = "condition", ntop=1000, returnData = FALSE) {
        rv <- rowVars(assay(object))
        select <- order(rv, decreasing = TRUE)[seq_len(min(ntop,
            length(rv)))]
        pca <- prcomp(t(assay(object)[select, ]))
        percentVar <- pca$sdev^2/sum(pca$sdev^2)
        if (!all(intgroup %in% names(colData(object)))) {
            stop("the argument 'intgroup' should specify columns of colData(dds)")
        }
        intgroup.df <- as.data.frame(colData(object)[, intgroup,
            drop = FALSE])
        group <- if (length(intgroup) > 1) {
            factor(apply(intgroup.df, 1, paste, collapse = ":"))
        }
        else {
            colData(object)[[intgroup]]
        } 
        d <- data.frame(PC3 = pca$x[, 3], PC4 = pca$x[, 4], group = group,
            intgroup.df, name = colnames(object))
        if (returnData) {
            attr(d, "percentVar") <- percentVar[3:4]
            return(d)
        }
        g<-ggplot(data = d, aes_string(x = "PC3", y = "PC4", color = "group")) +
            geom_point(size = 3) + xlab(paste0("PC3: ", round(percentVar[3] *
            100,2), "%")) + ylab(paste0("PC4: ", round(percentVar[4] *
            100,2), "%")) + coord_fixed()
        return(g)
}

plotPCA_higher_4_5 <- function(object, intgroup = "condition", ntop=1000, returnData = FALSE) {
        rv <- rowVars(assay(object))
        select <- order(rv, decreasing = TRUE)[seq_len(min(ntop,
            length(rv)))]
        pca <- prcomp(t(assay(object)[select, ]))
        percentVar <- pca$sdev^2/sum(pca$sdev^2)
        if (!all(intgroup %in% names(colData(object)))) {
            stop("the argument 'intgroup' should specify columns of colData(dds)")
        }
        intgroup.df <- as.data.frame(colData(object)[, intgroup,
            drop = FALSE])
        group <- if (length(intgroup) > 1) {
            factor(apply(intgroup.df, 1, paste, collapse = ":"))
        }
        else {
            colData(object)[[intgroup]]
        } 
        d <- data.frame(PC4 = pca$x[, 4], PC5 = pca$x[, 5], group = group,
            intgroup.df, name = colnames(object))
        if (returnData) {
            attr(d, "percentVar") <- percentVar[4:5]
            return(d)
        }
        g<-ggplot(data = d, aes_string(x = "PC4", y = "PC5", color = "group")) +
            geom_point(size = 3) + xlab(paste0("PC4: ", round(percentVar[4] *
            100,2), "%")) + ylab(paste0("PC5: ", round(percentVar[5] *
            100,2), "%")) + coord_fixed()
        return(g)
}

plotPCA_higher_5_6 <- function(object, intgroup = "condition", ntop=1000, returnData = FALSE) {
        rv <- rowVars(assay(object))
        select <- order(rv, decreasing = TRUE)[seq_len(min(ntop,
            length(rv)))]
        pca <- prcomp(t(assay(object)[select, ]))
        percentVar <- pca$sdev^2/sum(pca$sdev^2)
        if (!all(intgroup %in% names(colData(object)))) {
            stop("the argument 'intgroup' should specify columns of colData(dds)")
        }
        intgroup.df <- as.data.frame(colData(object)[, intgroup,
            drop = FALSE])
        group <- if (length(intgroup) > 1) {
            factor(apply(intgroup.df, 1, paste, collapse = ":"))
        }
        else {
            colData(object)[[intgroup]]
        } 
        d <- data.frame(PC5 = pca$x[, 5], PC6 = pca$x[, 6], group = group,
            intgroup.df, name = colnames(object))
        if (returnData) {
            attr(d, "percentVar") <- percentVar[5:6]
            return(d)
        }
        g<-ggplot(data = d, aes_string(x = "PC5", y = "PC6", color = "group")) +
            geom_point(size = 3) + xlab(paste0("PC5: ", round(percentVar[5] *
            100,2), "%")) + ylab(paste0("PC6: ", round(percentVar[6] *
            100,2), "%")) + coord_fixed()
        return(g)
}

test_enrich_two_sets_avi <- function(input_net, input_cds, input_list_1, input_list_2, input_universe, n_rand){
  ## restrict to universe
  input_net <- input_net[gene1 %in% input_universe & gene2 %in% input_universe, ]
  cat("  \n* Links in PPI network within gene universe: ", nrow(input_net), fill=T)
  ## sum of scores for each gene in network
  ## for PPI this is equivalent to the number of PPIs/links to other genes
  net_melt <- melt(input_net, id.vars = c("score"))
  net_genes_scores <- net_melt[, sum(score), by = "value"]
  setnames(net_genes_scores, c("gene", "score"))
  
  ## consider only those genes that are in the network AND have CDS length info
  info_table <- merge(net_genes_scores, input_cds, by="gene")
  
  ## consider only genes from input lists that are in input network and have CDS length info
  input_list_1 <- intersect(input_list_1, info_table[, gene])
  input_list_2 <- intersect(input_list_2, info_table[, gene])

  ## 'Avi'-like binning approach
  ## the same as in GeneNet Toolbox using 'scott' method
  n_bins_score <- nclass.scott(info_table[, score])
  n_bins_cds <-  nclass.scott(info_table[, max_length])
  
  ## print(n_bins_score)
  ## print(n_bins_cds)
  
  ## prepare data: get unique overall bins/groups based on score AND cds and number of input genes within each of those bins
  ## this will determine how many genes to pick from each bin/group
  
  x <- copy(info_table)
  x$group_score <- as.factor(cut(x$score, n_bins_score, labels=F))
  x$group_cds <- as.factor(cut(x$max_length, n_bins_cds, labels=F))
  ## combine the two bins to get 'unique bins' for both gene attributes
  x <- x[, group := as.numeric(as.factor(paste0(group_score, "_", group_cds)))]
  
  ## in which bins/groups do the input genes fall:
  x <- x[, n_list_1 := 0]
  x <- x[gene %in% input_list_1, n_list_1 := 1]
  x <- x[, n_list_2 := 0]
  x <- x[gene %in% input_list_2, n_list_2 := 1]
  
  ## number of genes to draw per group i.e. number of input genes in each group
  n_list_1_per_group <- x[n_list_1 == 1, list(n_list_1 = .N), by="group"]
  n_list_2_per_group <- x[n_list_2 == 1, list(n_list_2 = .N), by="group"]
  
  ## number of candidate genes per group, across all groups
  n_size_per_group <- x[, list(bin_size = .N),by="group"]
  
  ## 2 look-up tables: list all genes within the unique bins
  ## 1 table for each input gene list
  
  bin_table_1 <- merge(n_list_1_per_group, n_size_per_group, by="group")
  bin_table_1 <- bin_table_1[, idx_in_group := paste(1:bin_size, collapse = ','), by="group"]
  genes_bins_table_1 <- cSplit(bin_table_1, splitCols = "idx_in_group", sep = ",", direction = "long")[order(group, idx_in_group)]
  bin_table_1 <- bin_table_1[, idx_in_group := NULL]
  genes_bins_table_1 <- cbind(genes_bins_table_1[, group := NULL], x[group %in% bin_table_1[, group], .(gene, group, score, max_length)][order(group, gene)])
  
  bin_table_2 <- merge(n_list_2_per_group, n_size_per_group, by="group")
  bin_table_2 <- bin_table_2[, idx_in_group := paste(1:bin_size, collapse = ','), by="group"]
  genes_bins_table_2 <- cSplit(bin_table_2, splitCols = "idx_in_group", sep = ",", direction = "long")[order(group, idx_in_group)]
  bin_table_2 <- bin_table_2[, idx_in_group := NULL]
  genes_bins_table_2 <- cbind(genes_bins_table_2[, group := NULL], x[group %in% bin_table_2[, group], .(gene, group, score, max_length)][order(group, gene)])

  ### scores_rand <- data.table(overlap_with_list_1 = numeric(length=n_rand), overlap_with_list_2 = numeric(length=n_rand), score = numeric(length=n_rand))
  scores_rand <- matrix(nrow = n_rand + 1, ncol = 3)

  ## create reverse table, speed up  
  input_net_reverse <- copy(input_net)
  setnames(input_net_reverse, c("gene2", "gene1", "score"))
  setcolorder(input_net_reverse, c("gene1", "gene2", "score"))
  input_net_reverse <- rbind(input_net, input_net_reverse)
  keycols = c("gene1", "gene2")
  setkeyv(input_net_reverse, keycols)
  
  for (k in 1:n_rand) {
    
    ## from each bin/group get random genes
    rand_set_1 <- bin_table_1[, sample(1:bin_size, n_list_1), by="group"] ## get random index set
    setnames(rand_set_1, "V1", "idx_in_group")
    rand_set_1 <- merge(genes_bins_table_1, rand_set_1, by=c("group", "idx_in_group"))
    
    rand_set_2 <- bin_table_2[, sample(1:bin_size, n_list_2), by="group"] ## get random index set
    setnames(rand_set_2, "V1", "idx_in_group")
    rand_set_2 <- merge(genes_bins_table_2, rand_set_2, by=c("group", "idx_in_group"))
    
    links_across <- input_net_reverse[(gene1 %chin% rand_set_1[, gene] & gene2 %chin% rand_set_2[, gene]), ] ## rather slow
    scores_rand[k,] <- c(length(intersect(rand_set_1[, gene], input_list_1)), length(intersect(rand_set_2[, gene], input_list_2)), sum(links_across[, score]))
  }
  
  ## sum of scores for original two gene sets
  links_across <- input_net_reverse[(gene1 %chin% input_list_1 & gene2 %chin% input_list_2), ]
  scores_rand[n_rand + 1, ] <- c(length(input_list_1), length(input_list_2), sum(links_across[, score]))
  
  scores_rand <- as.data.table(scores_rand)
  setnames(scores_rand, c("Overlap_1", "Overlap_2", "Score"))

  ## write summary
  ## average length of randomised sets
  # cat("Length of list 1: ", scores_rand[n_rand+1, Overlap_1], fill=T)
  # cat("Average overlap of random sets with list 1: ", round(mean(scores_rand[1:n_rand, Overlap_1])), fill=T)
  # cat("Length of list 2: ", scores_rand[n_rand+1, Overlap_2], fill=T)
  # cat("Average overlap of random sets with list 2: ", round(mean(scores_rand[1:n_rand, Overlap_2])), fill=T)
  # 
  # cat("Number of simulations: ", n_rand, fill=T)
  # cat("Score for gene lists tested: ", scores_rand[n_rand+1, Score], fill=T)
  # cat("Average score for random gene lists: ", round(mean(scores_rand[1:n_rand, Score])), fill=T)
  # 
  # n_as_good <- sum(scores_rand[1:n_rand, Score] >= scores_rand[n_rand+1, Score])
  # cat("Number of times random sets have the same or higher score: ", n_as_good, fill=T)
  # if (n_as_good == 0){
  #   cat("Empirical p-value: <", 1/n_rand, fill=T)
  # } else {
  #   cat("Empirical p-value: ", n_as_good/n_rand, fill=T)
  # }
  
  
  cat("  \n* Length of list 1: ", scores_rand[n_rand+1, Overlap_1], fill=T)
  cat("  \n* Average overlap of random sets with list 1: ", round(mean(scores_rand[1:n_rand, Overlap_1])), fill=T)
  cat("  \n* Length of list 2: ", scores_rand[n_rand+1, Overlap_2], fill=T)
  cat("  \n* Average overlap of random sets with list 2: ", round(mean(scores_rand[1:n_rand, Overlap_2])), fill=T)
  
  cat("  \n* Number of simulations: ", n_rand, fill=T)
  cat("  \n* Score for gene lists tested: ", scores_rand[n_rand+1, Score], fill=T)
  cat("  \n* Average score for random gene lists: ", round(mean(scores_rand[1:n_rand, Score])), fill=T)
  
  n_as_good <- sum(scores_rand[1:n_rand, Score] >= scores_rand[n_rand+1, Score])
  cat("  \n* Number of times random sets have the same or higher score: ", n_as_good, fill=T)
  if (n_as_good == 0){
    cat("  \n* Empirical p-value: <", 1/n_rand, fill=T)
  } else {
    cat("  \n* Empirical p-value: ", n_as_good/n_rand, fill=T)
  }
  
  scores_rand
}


```



+ Samples: 18 samples
+ Genotype : SNCA triplication (clone 3)
+ Stimulation : Non-seeded control(NSC),PD , n= 9 each
+ Stimulation time : Week1, Week2
+ Differentiation Age post treatment : DIV 52 (Week1) , DIV 59 (Week 2)
+ generate cDNA : Novaseq 6000 and PolyA library prep
+ generate libraries : 
+ Organism: Homo_sapiens
+ Tissue & Cell: iPSC-derived dopinamergic neurons
+ read_type : paired, 150 bp
+ Fragment Library type :IU (Inward Unstranded, an unstranded paired-end library where the reads face each other)
+ Pseudoalignment : Kallisto (v0.46.2)
+ Reference Genome: Ensemble  Release 102

```{r files, include=FALSE}
setwd("~/Documents/George_tofaris_manuscripts/2021_June_DaNs_coC_mic/DaNs_treated_PD/")
## Salmon using Mouse ensembl GRCm38 reference
#quant_dir <- "./kallisto3/abundance/"


# Salmon or Kallisto for abundance data
# in_type <- "Kallisto"
in_type <- "kallisto"

# samples metadata
samples_file <- "./June_DaN_treated_metadata_PD_aggregated.csv"

# transcript to gene mapping
# generated from headers of fasta file used as transcriptome reference
# contains version numbers for ensembl transcript and gene IDs (v102)
ens_annot_file <- "../genome_v102/Homo_sapiens.GRCh38.cdna.all_genemap.txt"

#salmon_duplicates_file <- "~/Documents//Hazel_ipsc/Homo_sapiens.GRCh38.v95.cdna.all.ncrna_index/duplicate_clusters.tsv"
## number of components for plots e.g. PCA
n_comp <- 6

# n_comp <- 4

## theme size for scater plots
t_size <- 14

## seed to make some plots reproducible
n_seed <- 12

## DESeq2 settings

pre_filter_type <- "counts"
# pre_filter_type <- "tpm"

# minimum expression of a gene - pre-filtering step
# if counts are used: a rowsum-threshold 
# expression_cutoff <- 0 # at least one sample has to have an estimated count of 1
expression_cutoff <- 10 # at least 2 counts across all samples, i.e. remove genes with only 0 or 1 read across all samples
#expression_cutoff <- 15 # at 10 counts across all samples , 
# expression_cutoff <- -1 # no filtering
# if fpkms are used: each gene has at least 1 sample with FPKM > expression_cutoff

# adjusted alpha value
alpha_cutoff <- 0.05

# how many genes with lowest adjusted pvalue to print
top_genes <- 20


## make use of multiple cores
register(MulticoreParam(6))
```

```{r print_setting}

cat("Quantification data from: ", in_type, fill=T)

```

```{r set_annotation}
t2g <- fread(ens_annot_file, header=F)
setnames(t2g, c("target_id", "seqtype", "location", "ens_gene", "gene_type", "tx_type", "ext_gene", "desc"))

# remove version number from ensembl gene IDs
t2g <- t2g[, ens_gene := gsub('\\..*', '', ens_gene, perl=T)]

# combine external gene symbol with ensembl ID
t2g <- t2g[, gene := paste0(ext_gene, ' - ', ens_gene)]

# remove duplicates identified by Salmon index
#salmon_duplicates <- fread(salmon_duplicates_file)
#t2g <- t2g[!(target_id %in% salmon_duplicates[, DuplicateTxp]), ]

###############################################
## consider only protein coding genes
t2g <- t2g[gene_type == "protein_coding", ]
###############################################

# unique ensembl gene IDs
t2g_genes <- unique(t2g, by="ens_gene")
# setnames(t2g_genes, c("target_id", "ens_gene"), c("tx_id", "target_id")) # ensembl ID as target_id
setnames(t2g_genes, c("target_id", "gene"), c("tx_id", "target_id")) # gene symbol + esnembl ID as new target_id


# unique ensembl gene IDs
t2g_genes <- unique(t2g, by="ens_gene")
## setnames(t2g_genes, c("target_id", "ens_gene"), c("tx_id", "target_id"))
## setnames(t2g_genes, c("target_id", "gene"), c("tx_id", "target_id"))

```

```{r setup_samples}

samples_meta <- read_csv(file = samples_file, locale = locale(encoding = "Latin1"))

#samples_meta <- samples_meta[, Condition := factor(Condition, levels=c( "ND", "AD","PD"))]
#samples_meta <- samples_meta[, sample.time := factor(sample.time, levels=c(2,4,6,8))]
samples_meta$Sample_ID <- as.character(samples_meta$Sample_ID)
#samples_meta$Sample_name  <- as.factor(samples_meta$Sample_name)
samples_meta$Replicate <- as.factor(samples_meta$Replicate)
samples_meta$Treatment_time <- as.factor(samples_meta$Treatment_time)
samples_meta$Treatment_time <- relevel(samples_meta$Treatment_time, ref ="WK1")
samples_meta$Batch <- as.factor(samples_meta$Batch)
samples_meta$Treatment <- as.factor(samples_meta$Treatment)
samples_meta$Treatment <- relevel(samples_meta$Treatment, ref="NSC")
samples_meta$Group <- paste(samples_meta$Treatment_time,"_",samples_meta$Treatment,sep="")
#samples_meta$Differentiation_Age <- as.factor(samples_meta$Differentiation_Age)
#samples_meta$Stimulation <- as.factor(samples_meta$Stimulation)
#samples_meta$Stimulation <- relevel(samples_meta$Stimulation, ref="NSC")
#samples_meta$Group2 <- as.factor(samples_meta$Group2)#
#samples_meta$Group2 <- relevel(samples_meta$Group2, ref="WK1_NSC")

#quant_dirs <- list.dirs(quant_dir, full.names = TRUE, recursive = FALSE)
#quant_dirs_short <- list.dirs(quant_dir, full.names = FALSE, recursive = FALSE)

#quant_dirs_table <- data.table(Sample=quant_dirs_short, path=quant_dirs)
#quant_files_table <- data.table(Sample=quant_dirs_short, path=file_path)

#samples_meta_merged <- merge(samples_meta, quant_dirs_table, by.x="Sample_name", by.y= "Sample", all.x=T)

#samples_meta <- samples_meta_merged

```

-------------------------------

# Samples metadata

---------------------------------
```{r samples_overview, echo=FALSE, cache=T}
#samples_meta_merged <- as.data.frame(samples_meta_merged)
samples_meta_print <- subset.data.frame(samples_meta,select = c(Sample_ID,Replicate,Batch,Group, percent_aligned,reads_aligned_millions))
#samples_meta_print <- samples_meta_print[, .(sample.id, sample.group_name,sample.genotype, sample.time,sample.gender, sample.rin, sample.3pbias)]
samples_meta_print %>% DT::datatable(caption="iPSC DaNS", escape=F)
#kable(samples_meta_print, caption =" LCM microglia and astrocytes SN of Control, AD and PD patients", escape = T, format="markdown", padding=2)
```

# Import Expression Data

* use tximport to import Kallisto counts for transcripts summarised as genes in to DESEQ2

* after aggregation of transcripts to genes, remove those genes with zero variance - i.e. no expression at all across samples


```{r test_t2g, eval=FALSE}

cat("Unique ensembl genes provided in transcript to gene mapping file: ", length(unique(t2g[, ens_gene])), fill=T)

```

```{r tximport_setup_1, include=F, eval=F}

if (in_type == "kallisto"){
  files_tximport <- paste0(samples_meta$path, "/", "abundance.h5")
} else {
  files_tximport <- paste0(samples_meta$path, "/", "quant.sf")
}
#only included protein coding genes
names(files_tximport) <- samples_meta[, "Sample_name"]
## txi <- tximport(files_tximport, type = tolower(in_type), tx2gene = t2g[, .(target_id, ens_gene)], reader = read_tsv)
txi <- tximport(files_tximport, type = in_type, tx2gene = t2g_genes[, .(target_id, gene)], txOut = F, countsFromAbundance = "no", ignoreTxVersion = F)

#txi_2 <- tximport(files_tximport, type = "salmon", tx2gene = t2g[, .(target_id, gene)], txOut = T, countsFromAbundance = "no")
#saveRDS(txi, file="tximport_kallisto3.rds")
```


# Import data into DESeq2

* Remove genes with less than 10 counts across atleast 3 samples (the total number of replicates per group)

```{r tximport_merge, echo=FALSE, eval=FALSE}
txi_1 = readRDS(file="./tximport_kallisto.rds")
txi_1$infReps <- NULL
txi_2 = readRDS(file="./tximport_kallisto3.rds")

abundance_temp <- txi_2$abundance
keep <- c("WK1_R1_NSC","WK1_R2_NSC","WK1_R3_NSC", "WK1_R1_PD","WK1_R2_PD","WK1_R3_PD","WK2_R1_NSC","WK2_R2_NSC","WK2_R3_NSC","WK2_R1_PD","WK2_R2_PD","WK2_R3_PD")

abundance_temp <- abundance_temp[,keep]
abundance_temp <- as.data.frame(abundance_temp)
setnames(abundance_temp, c("WK1_R1_NSC","WK1_R2_NSC","WK1_R3_NSC", "WK1_R1_PD","WK1_R2_PD","WK1_R3_PD","WK2_R1_NSC","WK2_R2_NSC","WK2_R3_NSC","WK2_R1_PD","WK2_R2_PD","WK2_R3_PD"), c("WK1_R7_NSC","WK1_R8_NSC","WK1_R9_NSC", "WK1_R7_PD","WK1_R8_PD","WK1_R9_PD","WK2_R7_NSC","WK2_R8_NSC","WK2_R9_NSC","WK2_R7_PD","WK2_R8_PD","WK2_R9_PD"))

abundance_temp <- as.matrix(abundance_temp)

txi_2$abundance <- abundance_temp

counts_temp <- txi_2$counts
keep <- c("WK1_R1_NSC","WK1_R2_NSC","WK1_R3_NSC", "WK1_R1_PD","WK1_R2_PD","WK1_R3_PD","WK2_R1_NSC","WK2_R2_NSC","WK2_R3_NSC","WK2_R1_PD","WK2_R2_PD","WK2_R3_PD")

counts_temp <- counts_temp[,keep]
counts_temp <- as.data.frame(counts_temp)
setnames(counts_temp, c("WK1_R1_NSC","WK1_R2_NSC","WK1_R3_NSC", "WK1_R1_PD","WK1_R2_PD","WK1_R3_PD","WK2_R1_NSC","WK2_R2_NSC","WK2_R3_NSC","WK2_R1_PD","WK2_R2_PD","WK2_R3_PD"), c("WK1_R7_NSC","WK1_R8_NSC","WK1_R9_NSC", "WK1_R7_PD","WK1_R8_PD","WK1_R9_PD","WK2_R7_NSC","WK2_R8_NSC","WK2_R9_NSC","WK2_R7_PD","WK2_R8_PD","WK2_R9_PD"))

counts_temp <- as.matrix(counts_temp)

txi_2$counts <- counts_temp


length_temp <- txi_2$length
keep <- c("WK1_R1_NSC","WK1_R2_NSC","WK1_R3_NSC", "WK1_R1_PD","WK1_R2_PD","WK1_R3_PD","WK2_R1_NSC","WK2_R2_NSC","WK2_R3_NSC","WK2_R1_PD","WK2_R2_PD","WK2_R3_PD")

length_temp <- length_temp[,keep]
length_temp <- as.data.frame(length_temp)
setnames(length_temp, c("WK1_R1_NSC","WK1_R2_NSC","WK1_R3_NSC", "WK1_R1_PD","WK1_R2_PD","WK1_R3_PD","WK2_R1_NSC","WK2_R2_NSC","WK2_R3_NSC","WK2_R1_PD","WK2_R2_PD","WK2_R3_PD"), c("WK1_R7_NSC","WK1_R8_NSC","WK1_R9_NSC", "WK1_R7_PD","WK1_R8_PD","WK1_R9_PD","WK2_R7_NSC","WK2_R8_NSC","WK2_R9_NSC","WK2_R7_PD","WK2_R8_PD","WK2_R9_PD"))

length_temp <- as.matrix(length_temp)

txi_2$length <- length_temp

txi_all <- Map(cbind,txi_1,txi_2)
rm(abundance_temp,length_temp,counts_temp,txi_1,txi_2)

saveRDS(txi_all, file = "Jan_Jun_21_NSC_PD_tximport_kallisto.rds")
```


```{r deseq_setup, echo=FALSE}

txi_all <- readRDS(file="./Jan_Jun_21_NSC_PD_tximport_kallisto.rds")
samples_meta <- as.data.frame(samples_meta)
rownames(samples_meta) <- (samples_meta$Sample_ID)


## if only protein coding genes are used:
## "transcripts missing genes: 56393"
stopifnot(all.equal(colnames(txi_all$counts), rownames(samples_meta)))
samples_meta$Batch <- as.factor(samples_meta$Batch)
samples_meta$Group <- as.factor(samples_meta$Group)
samples_meta$Treatment <- as.factor(samples_meta$Treatment)
dds <- DESeqDataSetFromTximport(txi_all, samples_meta, design = ~ Batch + Group)
# using counts and average transcript lengths from tximport
# dds is now ready for DESeq() see DESeq2 vignette
# stores the rounded integers from txi$counts and tx lengths
# 2 assays: counts and avgTxLength
# NOTE: if tximport was run with countsFromAbundance as "scaledTPM" or "lengthScaledTPM", then only the counts are imported

cat("Assay names of DESeq dataset: ", assayNames(dds), fill=T)
cat("Number of genes and samples: ", dim(dds), fill=T)
cat("Number of genes with no read (estimated count) in any sample: ", sum(rowSums(counts(dds)) == 0), fill=T)
cat("Number of genes with exactly a count of 1 in a single sample (genes with row sum of 1): ", sum(rowSums(counts(dds)) == 1), fill=T)

## pre-filtering for low expression
cat("Expression threshold for exclusion of genes: ", expression_cutoff, fill=T)

if (pre_filter_type == "counts"){
  cat("Number of genes excluded: ", sum(rowSums(counts(dds) <= expression_cutoff ) <= 3), fill=T)
  keep <- rowSums(counts(dds) >= expression_cutoff) >= 3
  dds <- dds[keep, ]
} else if (pre_filter_type == "fpkm"){
  # Robust normalization is not used if average transcript lengths are present, which is the case here!
  # hence, raw counts are used here, and this is the basic calculation performed in fpm function:
  ## k <- counts(dds)
  ## library.sizes <- colSums(k)
  ## fpm_my <- 1e+06 * sweep(k, 2, library.sizes, "/")
  ## all.equal(fpm_test, fpm_my) # TRUE
  fpkm_robust <- DESeq2::fpkm(dds)
  cat("Number of genes excluded with less than 10 reads across a minimum of 3 samples: ", rowSums(fpkm_robust > expression_cutoff) < 3, fill=T)
  dds <- dds[rowSums(fpkm_robust > expression_cutoff) >= 3, ]
} else { stop("Unknown pre-filter type!")}


cat("Number of genes and samples after filtering: ", dim(dds), fill=T)

#expression_cutoff value =1 and to filter genes based on that based on RNA_seq workflow
# removing rows of the DESeqDataSet that have no counts, or only a single count across all samples
# DESEQ2 vignette suggests to use rowsums of counts >= 10 to keep

#dds <- dds[ rowSums(counts(dds)) >= 10, ]
#dim(dds)


dds <- estimateSizeFactors(dds)
sample_counts_norm <- counts(dds, normalized=T)
#colnames(sample_counts_norm) <- samples_meta$Sample_geo_accession
write.table(sample_counts_norm, file="Tofaris_Jan_June21_iPSC_DaNS_DESEQ2_counts_normalised.txt", sep="\t", quote=F)
#sample_fpkm_robust <- DESeq2::fpkm(dds, robust = T)
#sample_fpkm_robust_log2_1 <- (log2(sample_fpkm_robust+1))
#write.table(sample_fpkm_robust_log2_1, file= "All_dis_chall_RNAseq_DESEQ2_microglia_fpkm_log2_1.txt", sep="\t",quote=F)
#write.table(samples_meta, file="GSE75431_sample_microglia_metadata.txt", sep="\t", quote=F)

```

# Exploratory Data analysis 1

+ Rlog transformation tends to works well on small datasets (n<30) and for datasets with veyr different sequencing depth across samples
+ Corrected for Batch effect (June vs Jan study ) by using sva::ComBat
+ plot heatmaps and PCA plots on ComBat batch corrected rlog transformed data

```{r rlog_transform, include=FALSE}
# The function rlog returns an object based on the SummarizedExperiment class that contains the rlog-transformed values in its assay slot.
## slow
 rld <- rlogTransformation(dds, blind=TRUE)

# correct for batch effect
rlog_matrix <- assay(rld)
#mm <- model.matrix(~Group , colData(rld))
#limma_rld <- limma::removeBatchEffect(rlog_matrix, batch = rld$Batch,design = mm)

mm <- model.matrix(~Group , colData(rld))
combat_rld <- sva::ComBat(rlog_matrix, batch = rld$Batch, mod =  mm)

assay(rld) <-combat_rld


#assay(rld) <-limma_rld
```

## Sample Clustering


```{r sample_distances, echo=FALSE}
sampleDists <- dist(t(combat_rld))
#sampleDists
```

### Heatmap (Rlog transformation)

 

```{r sample_clustering_1, echo=FALSE, fig.height=6}
library("pheatmap")
library("RColorBrewer")
sampleDistMatrix <- as.matrix( sampleDists )
rownames(sampleDistMatrix) <- paste(rld$Group,"_", rld$Batch, sep="")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         col = colors,clustering_method = "ward.D2")
```

### Heatmap (Poisson Distance)

* This measure of dissimilarity between counts also takes the inherent variance structure of counts into consideration when calculating the distances between samples. 
```{r poison_distance, echo=FALSE}
library("PoiClaClu")
poisd <- PoissonDistance(t(combat_rld))
```


```{r Poisson_clustering_2, echo=FALSE, fig.height=5}
samplePoisDistMatrix <- as.matrix( poisd$dd )
rownames(samplePoisDistMatrix) <- paste( dds$Group,"_",dds$Batch, sep="" )
colnames(samplePoisDistMatrix) <- NULL
pheatmap(samplePoisDistMatrix,
         clustering_distance_rows = poisd$dd,
         clustering_distance_cols = poisd$dd,
         col = colors, clustering_method = "ward.D2")
```

## PCA plots with Rlog transformation 

+ ComBat corrected data for Batch effect
+ Top 500 & Top 100 most variable genes and all genes


```{r PCA_rlog, fig.height=5,fig.width=8}

plot_data <- DESeq2::plotPCA(rld, intgroup =c("Replicate", "Group","Batch","Treatment","Sample_ID"), returnData = T,ntop=500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by RLog transformation + ComBat corrected data:")
p <- ggplot(data = plot_data, aes(x=PC1, y=PC2, color= Group, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC1 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC2 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p


col_vector <-  c("WK1" ="#7FBFF5","WK2"="#061B29" )

#rld$Group <- factor(rld$Group, levels = c("WK1_NSC", "WK1_PD", "WK1_MSA","WK1_Fibrils", "WK2_NSC","WK2_PD","WK2_MSA","WK2_Fibrils"))
plot_data <- DESeq2::plotPCA(rld, intgroup =c("Replicate", "Group","Sample_ID","Treatment","Batch"), returnData = T,ntop=1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by RLog transformation + ComBat corrected data :")
p <- ggplot(data = plot_data, aes(x=PC1, y=PC2, color= Group, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.9, size=6, position = "jitter")  + scale_shape(solid = FALSE)
#p <- p + scale_color_manual(values = col_vector) + scale_shape_manual(values=c(1, 0, 2,5))
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5, point.padding = 0.5)
p <- p + xlab(paste0("PC1 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC2 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by RLog transformation") 
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p <- p + theme(axis.title = element_text(size=12, face="bold"))
p
#ggsave(filename = "PCA_1_2_top1000_HVG_v3.pdf",width = 5, height = 4)



cat("all genes by Rlog + Combat correction: ", dim(dds)[1])
plot_data <- DESeq2::plotPCA(rld, intgroup =c("Replicate", "Group","Sample_ID","Treatment","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

p <- ggplot(data = plot_data, aes(x=PC1, y=PC2, color=Group, shape= Batch))
p <- p + geom_point(alpha = 0.6, size=8, position = "jitter") 
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC1 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC2 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p



```

## PCA plots PC 2-3

+ Top 500 & Top 100 most variable genes and all genes

```{r}
 plot_data <- plotPCA_higher_2_3(object = rld, intgroup =c("Replicate", "Group","Sample_ID","Treatment","Batch"), returnData = T, ntop = 500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC2, y=PC3, color= Group, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC2 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC3 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p


col_vector <-  c("WK1" ="#7FBFF5","WK2"="#061B29" )

plot_data <- plotPCA_higher_2_3(object = rld, intgroup =c("Replicate", "Group","Sample_ID","Treatment","Batch"), returnData = T, ntop = 1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC2, y=PC3, color= Group, shape= Batch )) ## size = ?
p <- p + geom_point(alpha = 0.9, size=6, position="jitter") 
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5, point.padding = 0.5) 
#+ scale_shape_manual(values=c(1, 0, 2,5))
#p <- p + scale_color_manual(values = col_vector)
p <- p + xlab(paste0("PC2 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC3 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p <- p + theme(axis.title = element_text(size=12, face="bold"))
p
#ggsave(filename = "PCA_2_3_top1000_HVG_v3.pdf",width = 5, height = 4)




plot_data <- plotPCA_higher_2_3(object = rld, intgroup =c("Replicate", "Group","Sample_ID","Treatment","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("All genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC2, y=PC3, color= Group, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC2 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC3 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p
```


## PCA plots PC 3-4


```{r}
 plot_data <- plotPCA_higher_3_4(object = rld, intgroup =c("Replicate", "Group","Sample_ID","Treatment","Batch"), returnData = T, ntop = 500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC3, y=PC4, color= Group, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC3 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC4 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_3_4(object = rld, intgroup =c("Replicate", "Group","Sample_ID","Treatment","Batch"), returnData = T, ntop = 1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC3, y=PC4, color= Group, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC3 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC4 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_3_4(object = rld, intgroup =c("Replicate", "Group","Sample_ID","Treatment","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("All genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC3, y=PC4, color= Group, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC3 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC4 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p
```


## PCA plots PC 5-6


```{r}
plot_data <- plotPCA_higher_5_6(object = rld, intgroup =c("Replicate", "Group","Sample_ID","Treatment","Batch"), returnData = T, ntop = 500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC5, y=PC6, color= Group, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC5 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC6 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_5_6(object = rld, intgroup =c("Replicate", "Group","Sample_ID","Treatment","Batch"), returnData = T, ntop = 1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC5, y=PC6, color= Group, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC5 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC6 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_5_6(object = rld, intgroup =c("Replicate", "Group","Sample_ID","Treatment","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("All genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC5, y=PC6, color= Group, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC5 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC6 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p
```



# Exploratory Data analysis 2

+ VST transformation tends to works well on large datasets (n>30) 
+ Corrected for Batch effect (June vs Jan study ) by using ComBat from the sva package
+ plot heatmaps and PCA plots on ComBat batch corrected rlog transformed data

```{r , include=T}
library(sva)
# The function rlog returns an object based on the SummarizedExperiment class that contains the rlog-transformed values in its assay slot.
## slow
design(dds) <- formula(~1)
 vsd <- vst(dds, blind= TRUE)

# correct for batch effect
vst_matrix <- assay(vsd)
mm <- model.matrix(~Group , colData(vsd))
combat_vsd <- sva::ComBat(vst_matrix, batch = vsd$Batch, mod =  mm)

assay(vsd) <-combat_vsd
```

## Sample Clustering


```{r , echo=FALSE}
sampleDists <- dist(t(combat_vsd))
#sampleDists
```

### Heatmap (vst transformation)

 

```{r sample_clustering_2, echo=FALSE, fig.height=6}
library("pheatmap")
library("RColorBrewer")
sampleDistMatrix <- as.matrix( sampleDists )
rownames(sampleDistMatrix) <- paste(vsd$Group,"_", vsd$Batch, sep="")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         col = colors,clustering_method = "ward.D2")
```

### Heatmap (Poisson Distance)

* This measure of dissimilarity between counts also takes the inherent variance structure of counts into consideration when calculating the distances between samples. 
```{r poison_distance_2, echo=FALSE}
library("PoiClaClu")
poisd <- PoissonDistance(t(combat_vsd))
```


```{r Poisson_clustering_3, echo=FALSE, fig.height=5}
samplePoisDistMatrix <- as.matrix( poisd$dd )
rownames(samplePoisDistMatrix) <- paste( dds$Group,"_",dds$Batch, sep="" )
colnames(samplePoisDistMatrix) <- NULL
pheatmap(samplePoisDistMatrix,
         clustering_distance_rows = poisd$dd,
         clustering_distance_cols = poisd$dd,
         col = colors, clustering_method = "ward.D2")
```

## PCA plots with vst transformation 

+ sva::Combat corrected data for Batch effect

+ Top 500 & Top 100 most variable genes and all genes


```{r PCA_vst, fig.height=5,fig.width=8}

plot_data <- DESeq2::plotPCA(vsd, intgroup =c("Replicate", "Group","Batch","Treatment","Sample_ID"), returnData = T,ntop=500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by VST transformation:")
p <- ggplot(data = plot_data, aes(x=PC1, y=PC2, color= Group, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC1 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC2 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by VST transformation + Combat correction ")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p


col_vector <-  c("WK1" ="#7FBFF5","WK2"="#061B29" )

#rld$Group <- factor(rld$Group, levels = c("WK1_NSC", "WK1_PD", "WK1_MSA","WK1_Fibrils", "WK2_NSC","WK2_PD","WK2_MSA","WK2_Fibrils"))
plot_data <- DESeq2::plotPCA(vsd, intgroup =c("Replicate", "Group","Sample_ID","Treatment","Batch"), returnData = T,ntop=1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by VST transformation:")
p <- ggplot(data = plot_data, aes(x=PC1, y=PC2, color= Group, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.9, size=6, position = "jitter")  + scale_shape(solid = FALSE)
#p <- p + scale_color_manual(values = col_vector) + scale_shape_manual(values=c(1, 0, 2,5))
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5, point.padding = 0.5)
p <- p + xlab(paste0("PC1 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC2 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by VST transformation + Combat Correction") 
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p <- p + theme(axis.title = element_text(size=12, face="bold"))
p
#ggsave(filename = "PCA_1_2_top1000_HVG_v3.pdf",width = 5, height = 4)



cat("all genes: ", dim(dds)[1])
plot_data <- DESeq2::plotPCA(vsd, intgroup =c("Replicate", "Group","Sample_ID","Treatment","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

p <- ggplot(data = plot_data, aes(x=PC1, y=PC2, color=Group, shape= Batch))
p <- p + geom_point(alpha = 0.6, size=8, position = "jitter") 
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC1 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC2 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by VST transformation + Combat correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p



```



## PCA plots PC 2-3

+ Top 500 & Top 100 most variable genes and all genes

```{r}
 plot_data <- plotPCA_higher_2_3(object = vsd, intgroup =c("Replicate", "Group","Sample_ID","Treatment","Batch"), returnData = T, ntop = 500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by vst transformation + ComBat correction :")
p <- ggplot(data = plot_data, aes(x=PC2, y=PC3, color= Group, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC2 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC3 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by vst transformation + Combat Correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p


col_vector <-  c("WK1" ="#7FBFF5","WK2"="#061B29" )

plot_data <- plotPCA_higher_2_3(object = vsd, intgroup =c("Replicate", "Group","Sample_ID","Treatment","Batch"), returnData = T, ntop = 1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by vst transformation + ComBat correction:")
p <- ggplot(data = plot_data, aes(x=PC2, y=PC3, color= Group, shape= Batch )) ## size = ?
p <- p + geom_point(alpha = 0.9, size=6, position="jitter") 
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5, point.padding = 0.5) 
#+ scale_shape_manual(values=c(1, 0, 2,5))
#p <- p + scale_color_manual(values = col_vector)
p <- p + xlab(paste0("PC2 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC3 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by vst transformation + ComBat correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p <- p + theme(axis.title = element_text(size=12, face="bold"))
p
#ggsave(filename = "PCA_2_3_top1000_HVG_v3.pdf",width = 5, height = 4)




plot_data <- plotPCA_higher_2_3(object = vsd, intgroup =c("Replicate", "Group","Sample_ID","Treatment","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("All genes by vsd transformation + ComBat correction:")
p <- ggplot(data = plot_data, aes(x=PC2, y=PC3, color= Group, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC2 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC3 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by vst transformation + ComBat Correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p
```


## PCA plots PC 3-4


```{r}
 plot_data <- plotPCA_higher_3_4(object = vsd, intgroup =c("Replicate", "Group","Sample_ID","Treatment","Batch"), returnData = T, ntop = 500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by vst transformation + ComBat correction:")
p <- ggplot(data = plot_data, aes(x=PC3, y=PC4, color= Group, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC3 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC4 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_3_4(object = vsd, intgroup =c("Replicate", "Group","Sample_ID","Treatment","Batch"), returnData = T, ntop = 1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by vst transformation + ComBat Correction:")
p <- ggplot(data = plot_data, aes(x=PC3, y=PC4, color= Group, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC3 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC4 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by vst transformation + Combat correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_3_4(object = vsd, intgroup =c("Replicate", "Group","Sample_ID","Treatment","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("All genes by vst transformation + ComBat correction:")
p <- ggplot(data = plot_data, aes(x=PC3, y=PC4, color= Group, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC3 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC4 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by vst transformation + ComBat correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p
```


## PCA plots PC 5-6


```{r}
plot_data <- plotPCA_higher_5_6(object = vsd, intgroup =c("Replicate", "Group","Sample_ID","Treatment","Batch"), returnData = T, ntop = 500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by vst transformation + ComBat correction:")
p <- ggplot(data = plot_data, aes(x=PC5, y=PC6, color= Group, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC5 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC6 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by vst transformation + Combat Correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_5_6(object = vsd, intgroup =c("Replicate", "Group","Sample_ID","Treatment","Batch"), returnData = T, ntop = 1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by vst transformation + ComBat correction:")
p <- ggplot(data = plot_data, aes(x=PC5, y=PC6, color= Group, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC5 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC6 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by vst transformation + ComBat correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_5_6(object = vsd, intgroup =c("Replicate", "Group","Sample_ID","Treatment","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("All genes by vst transformation + ComBat Correction:")
p <- ggplot(data = plot_data, aes(x=PC5, y=PC6, color= Group, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC5 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC6 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by vst transformation + ComBat Correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p
```

## PCA correlation with covariates 

 + correlation of PCAs with multiple metadata covariates
 + using  ComBat batch corrected VST transformed data (as n> 30)  and top 1000 HVG
 
```{r, fig.height=6, fig.width=10}



  ntop = 1000
  rv <- rowVars(assay(vsd))
  rowSel <- order(rv, decreasing = T)[seq_len(ntop)]
  pca <- prcomp(t(assay(vsd)[rowSel, ]))
  percentVar <- pca$sdev^2 / sum(pca$sdev^2)
   #attach PCs to metadata
  pc.df <- pca$x %>% 
    as.data.frame() %>% 
    rownames_to_column(var = "sample")
  samples_meta <- inner_join(samples_meta, pc.df, by = c( "Sample_ID" = "sample"))
  meta <- samples_meta %>% 
    dplyr::select( -Clone, -Species, -Tissue_type,-Group)
  
  #column names by variable type
  facCols <- meta %>% 
    dplyr::select_if(is.factor) %>%
    colnames()

  pcCols <- meta %>%
    dplyr::select(starts_with("PC")) %>%
    colnames()

  #factor correlations
  facCor.df <- expand.grid(pcCols, facCols) 

  rsquared <- facCor.df %>%
    apply(1, function(x) reformulate(x[2], x[1])) %>%
    lapply(., lm, data = meta) %>%
    map(summary) %>%
    map_dbl("r.squared")

  facCor.df$corr <- sqrt(rsquared)

  facCor.df <- facCor.df %>%
    dplyr::rename(PC = Var1, covariate = Var2) %>%
    mutate(type = "lm")

  #numeric correlations
  numCor.df <- meta %>%
    dplyr::select_if(is.numeric) %>%
    correlate(method = "kendall") %>%
    focus(-matches("^PC")) %>%
    gather(variable, corr, 2:4) %>%
    mutate(type = "kendall") %>%
    dplyr::rename(PC = term, covariate = variable)

   #combine
  pcaBar <- bind_rows(numCor.df, facCor.df)

  #filter sample and sex
  #pcaBar <- pcaBar %>%
   # filter( ! (covariate %in% c("sample", "sex")))

  #add percent variation
  pcs <- paste("PC", 1:6, sep = "")
  percentVar <- percentVar[1:6]
  pvar <- data.frame( PC = pcs, perVar = paste(pcs, " (", sprintf("%.2f", percentVar * 100), "%)", sep = ""))
  pcaBar <- inner_join(pcaBar, pvar)

  #arrange
  pcaBar <- pcaBar %>%
    group_by(PC) %>%
    arrange(corr) %>%
    unite("pcvar", PC, covariate, sep = "_", remove = F) %>%
    data.frame() %>%
    mutate(pcvar = factor(pcvar))

```
 

### PCA correlation bar plot

 
```{r, fig.height= 5, fig.width=9 }
 # PCA correlation barplot
  pcaBar %>%
    group_by(PC) %>%
    ggplot(aes(x = pcvar, y = corr)) +
    geom_col(aes(fill = type)) +
    coord_flip() + 
    facet_wrap( ~ perVar, scale = "free_y") +
    xlab("metadata") +
    ylab("correlation") +
    scale_x_discrete(breaks = pcaBar$pcvar, labels = pcaBar$covariate) +
    scale_y_continuous(limits = c(-1, 1)) +
    scale_fill_manual(values = c("darkorange", "dodgerblue")) 
```

### PCA correlation heatmap

```{r,fig.height=4, fig.width=6}
pcaBar %>%
    ggplot(aes(x = covariate, y = perVar, fill=corr)) +
    geom_tile() + scale_fill_distiller(direction=-1, palette = "RdYlBu", limits= c(min(pcaBar$corr),1))+theme(axis.text.x =  element_text(angle = 45, vjust = 1, hjust = 1)) + ylab("") + xlab("") +  labs(fill='correlation') 
#ggsave(filename="PCA_covariates_corrleation_heatmap.tiff", width=6,height = 4, units = "in", dpi = 300)
```


## PCA plot using Generalised PCA
+ takes raw count matrix and number of latent dimensions (2 dimensions)

```{r}
library(glmpca)
gpca <- glmpca(counts(dds), L=2)
gpca.dat <- gpca$factors
gpca.dat$Treatment <- dds$Treatment
gpca.dat$Treatment_time <- dds$Treatment_time
gpca.dat$Group <- dds$Group
gpca.dat$Batch <- dds$Batch
gpca.dat$Sample_name <- dds$Sample_ID
```

```{r, fig.height=4, fig.width =7}
ggplot(gpca.dat, aes(x = dim1, y = dim2, color = Group, shape = Batch)) + geom_text_repel(aes(label=Sample_name), size=2.5) +
  geom_point(size =3) + ggtitle("glmpca - Generalized PCA") + coord_fixed()
```


# Differential Expression : WK1 PD vs NSC

* design " ~ Batch + Group
* DEG log2FC threshold = 0.20 and FDR 5%

```{r}
## Week1: Treatments vs NSC
design(dds) <- formula(~ Batch + Group)
dds <- DESeq(dds, parallel = T,betaPrior = FALSE, test = "Wald") # calculate LFC shrink afterwards using lfcshrink
#res_diffage <- results(dds)
#res_diffage
#mcols(res_diffage)
resultsNames(dds) 
# Will have to relevel Group to "WK2_NSC" for Week2 compariosns
```




```{r}

res_WK1_PD_NSC <- results(object=dds ,contrast = c("Group", "WK1_PD","WK1_NSC") , lfcThreshold = 0, alpha=0.05)
 mcols(res_WK1_PD_NSC)
 res_summary <- capture.output(summary(res_WK1_PD_NSC))
 cat(res_summary, sep="  \n* ")
 
 # number of differentially expressed genes based on cut off
 
 num_DEG <- sum(res_WK1_PD_NSC$padj < alpha_cutoff, na.rm=TRUE)
    cat("  \n* Genes with adjusted P-value not NA (universe of genes): ", sum(!is.na(res_WK1_PD_NSC$padj)))
    cat("  \n* Differentially expressed genes with p.adjusted <0.05: ", num_DEG, "  \n")
resOrdered_WK1_PD_NSC <- res_WK1_PD_NSC[order(res_WK1_PD_NSC$padj),]
resOrdered_WK1_PD_NSC<- as.data.frame(resOrdered_WK1_PD_NSC)
#write.table(as.data.frame(resOrdered_WK1_PD_NSC), file = paste0("deseq2_results_","WK1_PD_vs._NSC",".txt"), sep="\t", quote=F)
```

### MA-plot

```{r}
res_WK1_PD_NSC_LFCshrink <- lfcShrink(dds = dds ,contrast = c("Group", "WK1_PD","WK1_NSC") ,type="ashr")
DESeq2::plotMA(res_WK1_PD_NSC_LFCshrink, ylim = c(-10,10))

```

### Dispersion plot

```{r, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
plotDispEsts(dds)
```


### Table of DEG

```{r}
top_genes <- 15

 #prnt table of up and down regulated genes from DEG
    
res_print_WK1_NSC_PD <- print_DESeq_table(res_WK1_PD_NSC_LFCshrink, t2g_info = t2g_genes, alpha_level = alpha_cutoff,logfcthreshold = 0)


    
    plot_up_genes <- res_print_WK1_NSC_PD[fc == "up", target_id][1:top_genes]
    plot_up_genes <- plot_up_genes[!(is.na(plot_up_genes))] # if there are not top_genes DEGs, NA values will be returned
    plot_down_genes <- res_print_WK1_NSC_PD[fc == "down", target_id][1:top_genes]
    plot_down_genes <- plot_down_genes[!(is.na(plot_down_genes))]
  
    
    
  res_print_WK1_NSC_PD <- res_print_WK1_NSC_PD[, gene_type := NULL] ## only protein coding genes
    res_print_WK1_NSC_PD <- res_print_WK1_NSC_PD[, target_id := NULL] ## remove "symbol - ensembl_ID"
    
    setnames(res_print_WK1_NSC_PD, "desc", "___________long_gene_description___________")
   res_print_WK1_NSC_PD <- res_print_WK1_NSC_PD %>% drop_na()
```



```{r}
res_print_WK1_NSC_PD %>% DT::datatable(caption=" WK1 PD vs NSC", escape=F, extensions = 'Buttons', options = list(dom = 'Blfrtip', buttons = list('colvis', list(extend = 'copy', exportOptions = list(columns=':visible')), list(extend = 'csv', exportOptions = list(columns=':visible')), list(extend = 'excel', exportOptions = list(columns=':visible')))))
```


### Count Plots of Top genes


+ plot normalised counts for DEG for different groups

```{r, echo=F}
my_plot_counts <- function(obj, plot_genes=NULL, intgroup_vec=c("Group", "Replicate", "Batch"), t2g_info=NULL, n_ncol=4, n_nrow =6, title=NULL){

  # collect data for each gene
  plot_data_all <- as.data.table(plotCounts(obj, gene = plot_genes[1], intgroup_vec, returnData=TRUE,transform = F))
  plot_data_all[, gene := plot_genes[1]]
  plot_data_all[, gene_idx := formatC(1,width=2,flag='0')]
  
  if (length(plot_genes) >= 2){
    for (i in 2:length(plot_genes)){
      
      plot_data <- as.data.table(plotCounts(obj, gene = plot_genes[i], intgroup_vec, returnData=TRUE,transform = F))
      plot_data[, gene := plot_genes[i]]
      plot_data[, gene_idx := formatC(i,width=2,flag='0')]
      plot_data_all <- rbind(plot_data_all, plot_data)
    }
  }
  
  plot_data_all <- merge(plot_data_all, t2g_info[, .(gene, ext_gene)], by.x="gene", by.y="gene")
  # plot_data_all[, gene_print := paste0(gene_idx, "  ", gene, "  ", ext_gene)]
  # plot_data_all[, gene_print := paste0(gene_idx, "  ", gene)]
  plot_data_all[, gene_print := paste0(gene_idx, "  ", ext_gene)] ## use only gene symbol as facet title
  
  p <- ggplot(data = plot_data_all, aes(x=Group, y=log2(count+1), colour=Group, shape=Batch))
  p <- p + geom_violin(aes(group=Group), alpha = 0, colour = "gray60", scale="width")
  ## p <- p + ggbeeswarm::geom_quasirandom(alpha = 0.6, size = 3, groupOnX = TRUE)
  p <- p + geom_point(position = position_jitterdodge(), size=5, alpha=0.6)
  p <- p + xlab(NULL)
  p <- p + facet_wrap(~gene_print, ncol=n_ncol, scales="free_y",nrow = n_nrow)
  p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
  p <- p + ylab("log2(normalised count + 1)") + theme(legend.position="top")
  p <- p + theme(axis.text.x=element_text(angle=90, hjust=1, size=10)) + theme(axis.text.y = element_text(size=8))
  p <- p + ggtitle(title)
  p
}

```


```{r, echo=FALSE, fig.height=6, fig.width=10}
my_plot_counts(dds, plot_genes = plot_up_genes,title="upregulated genes in WK1 PD vs NSC", t2g_info = t2g_genes, n_ncol = 3)
```

```{r, echo=FALSE, fig.height=9, fig.width=10}
my_plot_counts(dds, plot_genes = plot_down_genes,title="downregulated genes in WK1: PD vs NSC", t2g_info = t2g_genes, n_ncol=3)
```

* plot interesting genes 

```{r,echo=FALSE, fig.height=8, fig.width=10}
control_genes <- c("OPA1 - ENSG00000198836","MFN1 - ENSG00000171109","TOMM20 - ENSG00000173726","DNM1L - ENSG00000087470","TFAM - ENSG00000108064","NRF1 - ENSG00000106459","NFE2L2 - ENSG00000116044","MTOR - ENSG00000198793","HIF1A - ENSG00000100644","ARNT - ENSG00000143437","SNCA - ENSG00000145335","PARK7 - ENSG00000116288")

#t2g_genes_control <- t2g_genes %>% filter(gene %in% control_genes) %>% select(gene)
my_plot_counts(dds, plot_genes = control_genes,title="interesting genes for PD", t2g_info = t2g_genes)
#PGC-1alpha = ENSG00000109819
# OMA1 - ENSG00000162600
# OPA1 - ENSG00000198836
# Mitofusin - ENSG00000171109
# TOM20 - ENSG00000173726
# DNM1L - ENSG00000087470
# TFAM - ENSG00000108064
# NRF1 - ENSG00000106459
# NFE2L2 -  ENSG00000116044
# TFEB - ENSG00000112561
# MTOR - ENSG00000198793
# HIF1a - ENSG00000100644
# HIF1b -  ENSG00000143437
#SNCA - ENSG00000145335
# PARK7 - ENSG00000116288
```




```{r,echo=FALSE}

# Get ENSEMBLE IDS

resOrdered_WK1_PD_NSC$gene <- rownames(resOrdered_WK1_PD_NSC)
resOrdered_WK1_PD_NSC_ens <- merge(resOrdered_WK1_PD_NSC, t2g_genes, by.all ="gene")
rownames(resOrdered_WK1_PD_NSC_ens) <- resOrdered_WK1_PD_NSC_ens$ens_gene
rm(resOrdered_WK1_PD_NSC)
resOrdered_WK1_PD_NSC_ens <- resOrdered_WK1_PD_NSC_ens[,c(1:7,11)]

# get rid of NAs for clusterprofiler
#library(tidyr)
resOrdered_WK1_PD_NSC_ens <- resOrdered_WK1_PD_NSC_ens %>% drop_na()

# map ids using annotation db
library(org.Hs.eg.db)
library(AnnotationDbi)

resOrdered_WK1_PD_NSC_ens$entrez <- mapIds(org.Hs.eg.db, keys= rownames(resOrdered_WK1_PD_NSC_ens), column = "ENTREZID", keytype = "ENSEMBL", multiVals = "first")
resOrdered_WK1_PD_NSC_ens$symbol <- mapIds(org.Hs.eg.db, keys= rownames(resOrdered_WK1_PD_NSC_ens), column = "SYMBOL", keytype = "ENSEMBL", multiVals = "first")
write.table(resOrdered_WK1_PD_NSC_ens, file="deseq2_results_Jan_Jun21_WK1_PD_vs._NSC.txt", sep="\t", quote=F)


```

### Volcano plot 

```{r, fig.height=5, fig.width=7}
library(EnhancedVolcano)
 Vol <- EnhancedVolcano(resOrdered_WK1_PD_NSC_ens,
    lab = resOrdered_WK1_PD_NSC_ens$symbol,
    x = 'log2FoldChange',
    y = 'pvalue', subtitle = "", title = "WK1:PD vs.NSC", xlim = c(-10,8), labSize =3, FCcutoff = 0, axisLabSize = 6, titleLabSize = 8, legendLabSize = 6, pCutoff = 0.05,pCutoffCol = 'padj', drawConnectors = F, captionLabSize = 6,
    widthConnectors = 0.2, colConnectors = 'grey30',caption = "Log2FC cutoff = 0; p-value cutoff= 0.05" )
 Vol <-   Vol +  ggplot2::coord_cartesian(xlim=c(-10, 8))  + ggplot2::scale_x_continuous(breaks=seq(-10,8, 2))
 Vol
```



```{r, eval=F}
### Gene Ontology Over-representation analysis
 
 # Done all DEG with p.adj <0.05 , no logFC threshold applied

library(clusterProfiler)

resOrdered_WK1_PD_NSC_ens_sig <- resOrdered_aggregate_NSC_ens %>% filter(padj < 0.05) 

#geneChangeList <- resOrdered_Parent_stim_control_LFCshrink_ens_sig$log2FoldChange
geneChangeList <- resOrdered_aggregate_NSC_ens_sig$ens_gene
#geneChangeList <- sort(geneChangeList, decreasing=TRUE)
#desiredGeneChangeList <- names(geneChangeList)[abs(geneChangeList) >1] 
 all_genes <- as.character(resOrdered_aggregate_NSC_ens$ens_gene)

enrichGOResult_1 <- enrichGO(gene = geneChangeList, OrgDb = org.Hs.eg.db, keyType = 'ENSEMBL', ont = "BP", pAdjustMethod = "BH", universe=all_genes, readable = T)

```



```{r, eval=F}
#GO BP over-representation test
scorePlot <- RScorePlot_v2(enrichGOResult_1, resOrdered_aggregate_NSC_ens, showCategory = 15, textSize = 9, title = "" ) + theme(title = element_text(size=8))
plot(scorePlot)
```



```{r, eval=F}
### Reactome Pathways
library(ReactomePA)
# only takes entrez id
geneChangeList <- resOrdered_aggregate_NSC_ens_sig$entrez
#geneChangeList <- sort(geneChangeList, decreasing=TRUE)
#desiredGeneChangeList <- names(geneChangeList)[abs(geneChangeList) >1] 
 all_genes <- as.character(resOrdered_aggregate_NSC_ens$entrez)
enrich_Reactome <-  enrichPathway(gene = geneChangeList, pAdjustMethod = "BH", universe=all_genes, readable = T, organism = "human")
scorePlot <- RScorePlot_v2(enrich_Reactome, resOrdered_aggregate_NSC_ens, showCategory = 25, textSize = 9, title = "" ) + theme(title = element_text(size=8))
plot(scorePlot)
```


```{r, echo=FALSE, message=FALSE, warning=FALSE}
# from https://stephenturner.github.io/deseq-to-fgsea/
# symbol here comes from map ids. it is possible that 2 ensgs map to the same symbol! this creates duplicates in the stat data frame and is removed using distinct
library(fgsea)
gsea_res_WK1_PD_NSC <- resOrdered_WK1_PD_NSC_ens %>% dplyr::select(symbol,stat) %>% na.omit() %>% distinct() %>% group_by(symbol) %>% summarize(stat=mean(stat))
# dim(gsea_res)
# head(gsea_res)

# fast Gene Set Enrichment Analysis
ranks<- deframe(gsea_res_WK1_PD_NSC)

```

### GSEA Reactome Pathways

```{r}
pathways.reactome <- gmtPathways("../genesets/c2.cp.reactome.v7.4.symbols.gmt")
fgsea_reactome <- fgsea(pathways=pathways.reactome, stats=ranks, nperm=10000, maxSize = 500, minSize = 30)
# convert to tibble, sort by NES and select columns
fgsea_reactome_tidy <- fgsea_reactome %>% as_tibble() %>% arrange(padj) %>% dplyr::select(-pval, -ES, -nMoreExtreme)
# Show in a nice table:
fgsea_reactome_tidy %>% DT::datatable()
```





### Top 15 up and down regulated Reactome pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowd pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_reactome_up <- fgsea_reactome[ES > 0][size < 250][order(padj,-NES),pathway][1:15]
top_reactome_dn <- fgsea_reactome[ES < 0][size < 250][order(padj,NES),pathway][1:15]
top_reactome <- c(top_reactome_up, rev(top_reactome_dn))
plotGseaTable(pathways.reactome[top_reactome], ranks, fgsea_reactome, gseaParam = 0.5)
fgsea_reactome_tidy_top <- fgsea_reactome_tidy %>% filter(pathway %in% top_reactome)
```


```{r, fig.width=10}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_reactome_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down Reactome pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=8))+theme(plot.title = element_text(size=7))
p1

```

### Enrichments plots for top Reactome hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.reactome[[top_reactome_up[i]]], ranks) + labs(title=top_reactome_up[i]))
}
```


### Leading Edge heatmaps for top Reactome hits

Heatmap of row normalised rld regularised leg transformed size factor normalised read counts

```{r, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
norm_counts <- as.data.frame(assay(rld))
norm_counts <- norm_counts %>% rownames_to_column(var="gene")
norm_counts_Ens <- merge(norm_counts, t2g_genes[,c(4,9)], by.all="gene")
ens2symbol <- AnnotationDbi::select(org.Hs.eg.db, key=norm_counts_Ens$ens_gene, columns="SYMBOL", keytype="ENSEMBL", multiVals="first") %>% distinct()
ens2symbol$gene <- paste(ens2symbol$ENSEMBL,"-",ens2symbol$SYMBOL,sep="")
ens2symbol <- as_tibble(ens2symbol)
norm_counts_Ens <- norm_counts_Ens %>% column_to_rownames(var= "ens_gene") %>% dplyr::select(-gene)
norm_counts_Ens_WK1 <- norm_counts_Ens %>%  dplyr::select(starts_with("WK1_"))

```

```{r, eval=T}
top_reactome_up_full <- fgsea_reactome[ES > 0][size < 250][order(padj,-NES),][1:5]

for (i in 1:5) {
  # Full pathway
  # print(pathways.reactome[[top_reactome_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_reactome_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens_WK1[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens_WK1)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  pheatmap(gene_counts_rownorm, col = colors, main=top_reactome_up_full[i,pathway])
 }
  
```


### GSEA KEGG Pathways

```{r}
pathways.kegg <- gmtPathways("../genesets/c2.cp.kegg.v7.4.symbols.gmt")
fgsea_kegg <- fgsea(pathways=pathways.kegg, stats=ranks, nperm=10000, maxSize = 500, minSize = 30)
# convert to tibble, sort by NES and select columns
fgsea_kegg_tidy <- fgsea_kegg %>% as_tibble() %>% arrange(padj) %>% dplyr::select(-pval, -ES, -nMoreExtreme)
# Show in a nice table:
fgsea_kegg_tidy %>% DT::datatable()
```




### Top 15 up and down regulated KEGG pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowd pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_kegg_up <- fgsea_kegg[ES > 0][size < 250][order(padj,-NES),pathway][1:15]
top_kegg_dn <- fgsea_kegg[ES < 0][size < 250][order(padj,NES),pathway][1:15]
top_kegg <- c(top_kegg_up, rev(top_kegg_dn))
plotGseaTable(pathways.kegg[top_kegg], ranks, fgsea_kegg, gseaParam = 0.5)
fgsea_kegg_tidy_top <- fgsea_kegg_tidy %>% filter(pathway %in% top_kegg)
```


```{r, fig.width=10}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_kegg_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down KEGG pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=8))+theme(plot.title = element_text(size=7))
p1

```

### Enrichments plots for top KEGG hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.kegg[[top_kegg_up[i]]], ranks) + labs(title=top_kegg_up[i]))
}
```




### Leading Edge heatmaps for top KEGG hits

Heatmap of row noemalised rld regularised leg transformed size factor normalised read counts

```{r, echo=FALSE, message=FALSE, warning=FALSE}
norm_counts <- as.data.frame(assay(rld))
norm_counts <- norm_counts %>% rownames_to_column(var="gene")
norm_counts_Ens <- merge(norm_counts, t2g_genes[,c(4,9)], by.all="gene")
ens2symbol <- AnnotationDbi::select(org.Hs.eg.db, key=norm_counts_Ens$ens_gene, columns="SYMBOL", keytype="ENSEMBL", multiVals="first") %>% distinct()
ens2symbol$gene <- paste(ens2symbol$ENSEMBL,"-",ens2symbol$SYMBOL,sep="")
ens2symbol <- as_tibble(ens2symbol)
norm_counts_Ens <- norm_counts_Ens %>% column_to_rownames(var= "ens_gene") %>% dplyr::select(-gene)
norm_counts_Ens_WK1 <- norm_counts_Ens %>%  dplyr::select(starts_with("WK1_"))

```

```{r, eval=T}
top_kegg_up_full <- fgsea_kegg[ES > 0][size < 250][order(padj,-NES),][1:5]

for (i in 1:5) {
  # Full pathway
   #print(pathways.kegg[[top_kegg_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_kegg_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens_WK1[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens_WK1)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  pheatmap(gene_counts_rownorm, col = colors, main=top_kegg_up_full[i,pathway])
 }
  
```




### GSEA GO BP Terms

```{r}
pathways.gobp <- gmtPathways("../genesets/c5.go.bp.v7.4.symbols.gmt")
fgsea_gobp <- fgsea(pathways=pathways.gobp, stats=ranks, nperm=10000, maxSize = 500, minSize = 30)
# convert to tibble, sort by NES and select columns
fgsea_gobp_tidy <- fgsea_gobp %>% as_tibble() %>% arrange(padj) %>% dplyr::select(-pval, -ES, -nMoreExtreme)
# Show in a nice table:
fgsea_gobp_tidy %>% DT::datatable()
```





### Top 15 up and down regulated GOBP pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowd pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_gobp_up <- fgsea_gobp[ES > 0][size < 250][order(padj,-NES),pathway][1:15]
top_gobp_dn <- fgsea_gobp[ES < 0][size < 250][order(padj,NES),pathway][1:15]
top_gobp <- c(top_gobp_up, rev(top_gobp_dn))
plotGseaTable(pathways.gobp[top_gobp], ranks, fgsea_gobp, gseaParam = 0.5)
fgsea_gobp_tidy_top <- fgsea_gobp_tidy %>% filter(pathway %in% top_gobp)
```


```{r, fig.width=10}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_gobp_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down GO-BP pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=8))+theme(plot.title = element_text(size=7))
p1

```

### Enrichments plots for top GOBP hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.gobp[[top_gobp_up[i]]], ranks) + labs(title=top_gobp_up[i]))
}
```




### Leading Edge heatmaps for top GOBP hits

Heatmap of row normalised rld regularised leg transformed size factor normalised read counts

```{r, echo=FALSE, message=FALSE, warning=FALSE}
norm_counts <- as.data.frame(assay(rld))
norm_counts <- norm_counts %>% rownames_to_column(var="gene")
norm_counts_Ens <- merge(norm_counts, t2g_genes[,c(4,9)], by.all="gene")
ens2symbol <- AnnotationDbi::select(org.Hs.eg.db, key=norm_counts_Ens$ens_gene, columns="SYMBOL", keytype="ENSEMBL", multiVals="first") %>% distinct()
ens2symbol$gene <- paste(ens2symbol$ENSEMBL,"-",ens2symbol$SYMBOL,sep="")
ens2symbol <- as_tibble(ens2symbol)
norm_counts_Ens <- norm_counts_Ens %>% column_to_rownames(var= "ens_gene") %>% dplyr::select(-gene)
norm_counts_Ens_WK1 <- norm_counts_Ens %>%  dplyr::select(starts_with("WK1_"))

```

```{r, eval=T}
top_gobp_up_full <- fgsea_gobp[ES > 0][size < 250][order(padj,-NES),][1:5]

for (i in 1:5) {
  # Full pathway
  # print(pathways.gobp[[top_gobp_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_gobp_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens_WK1[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens_WK1)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  pheatmap(gene_counts_rownorm, col = colors, main=top_gobp_up_full[i,pathway])
 }
  
```


# Differential Expression : Week2: PD vs NSC


```{r}

res_WK2_PD_NSC <- results(object=dds ,contrast = c("Group", "WK2_PD","WK2_NSC") , lfcThreshold = 0, alpha=0.05)
 mcols(res_WK2_PD_NSC)
 res_summary <- capture.output(summary(res_WK2_PD_NSC))
 cat(res_summary, sep="  \n* ")
 
 # number of differentially expressed genes based on cut off
 
 num_DEG <- sum(res_WK2_PD_NSC$padj < alpha_cutoff, na.rm=TRUE)
    cat("  \n* Genes with adjusted P-value not NA (universe of genes): ", sum(!is.na(res_WK2_PD_NSC$padj)))
    cat("  \n* Differentially expressed genes with p.adjusted <0.05: ", num_DEG, "  \n")
resOrdered_WK2_PD_NSC <- res_WK2_PD_NSC[order(res_WK2_PD_NSC$padj),]
resOrdered_WK2_PD_NSC <- as.data.frame(resOrdered_WK2_PD_NSC )
#write.table(as.data.frame(resOrdered_WK1_PD_NSC), file = paste0("deseq2_results_","WK1_PD_vs._NSC",".txt"), sep="\t", quote=F)
```

### MA-plot

```{r}
res_WK2_PD_NSC_LFCshrink <- lfcShrink(dds = dds ,contrast = c("Group", "WK2_PD","WK2_NSC") ,type="ashr")
DESeq2::plotMA(res_WK2_PD_NSC_LFCshrink, ylim = c(-10,10))

```

### Dispersion plot

```{r, echo=FALSE, message=FALSE, warning=FALSE}
plotDispEsts(dds)
```


### Table of DEG

```{r}
top_genes <- 20

 #prnt table of up and down regulated genes from DEG
    
res_print_WK2_PD_NSC <- print_DESeq_table(res_WK2_PD_NSC_LFCshrink, t2g_info = t2g_genes, alpha_level = alpha_cutoff,logfcthreshold = 0)


    
    plot_up_genes <- res_print_WK2_PD_NSC[fc == "up", target_id][1:top_genes]
    plot_up_genes <- plot_up_genes[!(is.na(plot_up_genes))] # if there are not top_genes DEGs, NA values will be returned
    plot_down_genes <- res_print_WK2_PD_NSC[fc == "down", target_id][1:top_genes]
    plot_down_genes <- plot_down_genes[!(is.na(plot_down_genes))]
  
    
    
   res_print_WK2_PD_NSC <-res_print_WK2_PD_NSC[, gene_type := NULL] ## only protein coding genes
    res_print_WK2_PD_NSC <- res_print_WK2_PD_NSC[, target_id := NULL] ## remove "symbol - ensembl_ID"
    
    setnames(res_print_WK2_PD_NSC, "desc", "___________long_gene_description___________")
   res_print_WK2_PD_NSC <- res_print_WK2_PD_NSC %>% drop_na()
```



```{r}
res_print_WK2_PD_NSC %>% DT::datatable(caption=" Week2 PD vs NSC", escape=F, extensions = 'Buttons', options = list(dom = 'Blfrtip', buttons = list('colvis', list(extend = 'copy', exportOptions = list(columns=':visible')), list(extend = 'csv', exportOptions = list(columns=':visible')), list(extend = 'excel', exportOptions = list(columns=':visible')))))
```


### Count Plots of Top genes


+ plot normalised counts for DEG for different groups

```{r, echo=F}
my_plot_counts <- function(obj, plot_genes=NULL, intgroup_vec=c("Group", "Batch"), t2g_info=NULL, n_ncol=4, n_nrow =6, title=NULL){

  # collect data for each gene
  plot_data_all <- as.data.table(plotCounts(obj, gene = plot_genes[1], intgroup_vec, returnData=TRUE,transform = F))
  plot_data_all[, gene := plot_genes[1]]
  plot_data_all[, gene_idx := formatC(1,width=2,flag='0')]
  
  if (length(plot_genes) >= 2){
    for (i in 2:length(plot_genes)){
      
      plot_data <- as.data.table(plotCounts(obj, gene = plot_genes[i], intgroup_vec, returnData=TRUE,transform = F))
      plot_data[, gene := plot_genes[i]]
      plot_data[, gene_idx := formatC(i,width=2,flag='0')]
      plot_data_all <- rbind(plot_data_all, plot_data)
    }
  }
  
  plot_data_all <- merge(plot_data_all, t2g_info[, .(gene, ext_gene)], by.x="gene", by.y="gene")
  # plot_data_all[, gene_print := paste0(gene_idx, "  ", gene, "  ", ext_gene)]
  # plot_data_all[, gene_print := paste0(gene_idx, "  ", gene)]
  plot_data_all[, gene_print := paste0(gene_idx, "  ", ext_gene)] ## use only gene symbol as facet title
  
  p <- ggplot(data = plot_data_all, aes(x=Group, y=log2(count+1), colour=Group,shape=Batch))
  p <- p + geom_violin(aes(group=Group), alpha = 0, colour = "gray60", scale="width")
  ## p <- p + ggbeeswarm::geom_quasirandom(alpha = 0.6, size = 3, groupOnX = TRUE)
  p <- p + geom_point(position = position_jitterdodge(), size=5, alpha=0.6)
  p <- p + xlab(NULL)
  p <- p + facet_wrap(~gene_print, ncol=n_ncol, scales="free_y",nrow = n_nrow)
  p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
  p <- p + ylab("log2(normalised count + 1)") + theme(legend.position="top")
  p <- p + theme(axis.text.x=element_text(angle=90, hjust=1, size=10)) + theme(axis.text.y = element_text(size=8))
  p <- p + ggtitle(title)
  p
}

```


```{r, echo=FALSE, fig.height=9, fig.width=10}
my_plot_counts(dds, plot_genes = plot_up_genes,title="upregulated genes in WK2 PD vs NSC", t2g_info = t2g_genes)
```

```{r, echo=FALSE, fig.height=9, fig.width=10}
my_plot_counts(dds, plot_genes = plot_down_genes,title="downregulated genes in WK2 PD vs NSC", t2g_info = t2g_genes)
```

* plot interesting genes 

```{r,echo=FALSE, fig.height=9, fig.width=10, eval=FALSE}
control_genes <- c("OPA1 - ENSG00000198836","MFN1 - ENSG00000171109","TOMM20 - ENSG00000173726","DNM1L - ENSG00000087470","TFAM - ENSG00000108064","NRF1 - ENSG00000106459","NFE2L2 - ENSG00000116044","MTOR - ENSG00000198793","HIF1A - ENSG00000100644","ARNT - ENSG00000143437","SNCA - ENSG00000145335","PARK7 - ENSG00000116288")

#t2g_genes_control <- t2g_genes %>% filter(gene %in% control_genes) %>% select(gene)
my_plot_counts(dds, plot_genes = control_genes,title="interesting genes for PD", t2g_info = t2g_genes)
#PGC-1alpha = ENSG00000109819
# OMA1 - ENSG00000162600
# OPA1 - ENSG00000198836
# Mitofusin - ENSG00000171109
# TOM20 - ENSG00000173726
# DNM1L - ENSG00000087470
# TFAM - ENSG00000108064
# NRF1 - ENSG00000106459
# NFE2L2 -  ENSG00000116044
# TFEB - ENSG00000112561
# MTOR - ENSG00000198793
# HIF1a - ENSG00000100644
# HIF1b -  ENSG00000143437
#SNCA - ENSG00000145335
# PARK7 - ENSG00000116288
```

### Plot SNCA counts in Week2 samples only


```{r,eval=FALSE}
 plot_data_SNCA <- plotCounts(dds = dds, gene = "SNCA - ENSG00000145335", intgroup =c("Group2", "Stimulation","Treatment_time","Replicate","Treatment"), returnData=TRUE,transform = F)
plot_data_SNCA_wk2 <- plot_data_SNCA %>% filter(Treatment_time == "WK2")

 p <- ggplot(data = plot_data_SNCA_wk2, aes(x=Group2, y=log2(count+1), colour=Stimulation))
  p <- p + geom_violin(aes(group=Group2), alpha = 0, colour = "gray60", scale="width")
  ## p <- p + ggbeeswarm::geom_quasirandom(alpha = 0.6, size = 3, groupOnX = TRUE)
  p <- p + geom_point(position = position_jitterdodge(), size=5, alpha=0.6, aes(shape = Treatment))
  p <- p + xlab(NULL)
 # p <- p + facet_wrap(~gene_print, ncol=n_ncol, scales="free_y",nrow = n_nrow)
  p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
  p <- p + ylab("log2(normalised count + 1)") + theme(legend.position="right")
  p <- p + theme(axis.text.x=element_text(angle=90, hjust=1, size=10)) + theme(axis.text.y = element_text(size=8))
  p <- p + ggtitle("SNCA-ENSG00000145335") 
  p
 # ggsave(filename = "RNASEQ_WK2_SNCA_normalised_counts_plot.pdf",width = 5, height = 5,units = "in", dpi = 300)
```





```{r,echo=FALSE}

# Get ENSEMBLE IDS

resOrdered_WK2_PD_NSC$gene <- rownames(resOrdered_WK2_PD_NSC)
resOrdered_WK2_PD_NSC_ens <- merge(resOrdered_WK2_PD_NSC, t2g_genes, by.all ="gene")
rownames(resOrdered_WK2_PD_NSC_ens) <- resOrdered_WK2_PD_NSC_ens$ens_gene
rm(resOrdered_WK2_PD_NSC)
resOrdered_WK2_PD_NSC_ens <- resOrdered_WK2_PD_NSC_ens[,c(1:7,11)]

# get rid of NAs for clusterprofiler
#library(tidyr)
resOrdered_WK2_PD_NSC_ens <- resOrdered_WK2_PD_NSC_ens %>% drop_na()

# map ids using annotation db
library(org.Hs.eg.db)
library(AnnotationDbi)

resOrdered_WK2_PD_NSC_ens$entrez <- mapIds(org.Hs.eg.db, keys= rownames(resOrdered_WK2_PD_NSC_ens), column = "ENTREZID", keytype = "ENSEMBL", multiVals = "first")
resOrdered_WK2_PD_NSC_ens$symbol <- mapIds(org.Hs.eg.db, keys= rownames(resOrdered_WK2_PD_NSC_ens), column = "SYMBOL", keytype = "ENSEMBL", multiVals = "first")
write.table(resOrdered_WK2_PD_NSC_ens, file="deseq2_results_Jan_Jun_21_WK2_PD_vs._NSC.txt", sep="\t", quote=F)


```

### Volcano plot 

```{r, fig.height=6, fig.width=8}
library(EnhancedVolcano)
 Vol <- EnhancedVolcano(resOrdered_WK2_PD_NSC_ens,
    lab = resOrdered_WK2_PD_NSC_ens$symbol,
    x = 'log2FoldChange',
    y = 'pvalue', subtitle = "", title = "WK2:PD vs. NSC", xlim = c(-13,26), labSize =3, FCcutoff = 0.20, axisLabSize = 6, titleLabSize = 8, legendLabSize = 6, pCutoff = 0.05, pCutoffCol = "padj",   drawConnectors = F, captionLabSize = 6,
    widthConnectors = 0.2, colConnectors = 'grey30',caption = "Log2FC cutoff = 0.20; p-value cutoff=0.05" )
# Vol <-   Vol +  ggplot2::coord_cartesian(xlim=c(-28, 26))  + ggplot2::scale_x_continuous(breaks=seq(-28,23, 5))
 Vol
```



```{r, eval=F}
### Gene Ontology Over-representation analysis
 
 # Done all DEG with p.adj <0.05 , no logFC threshold applied

library(clusterProfiler)

resOrdered_WK2_aggregate_NSC_ens_sig <- resOrdered_WK2_aggregate_NSC_ens %>% filter(padj < 0.05) 

#geneChangeList <- resOrdered_Parent_stim_control_LFCshrink_ens_sig$log2FoldChange
geneChangeList <- resOrdered_WK2_aggregate_NSC_ens_sig$ens_gene
#geneChangeList <- sort(geneChangeList, decreasing=TRUE)
#desiredGeneChangeList <- names(geneChangeList)[abs(geneChangeList) >1] 
 all_genes <- as.character(resOrdered_WK2_aggregate_NSC_ens$ens_gene)

enrichGOResult_1 <- enrichGO(gene = geneChangeList, OrgDb = org.Hs.eg.db, keyType = 'ENSEMBL', ont = "BP", pAdjustMethod = "BH", universe=all_genes, readable = T)

```



```{r, eval=F}
#GO BP over-representation test
scorePlot <- RScorePlot_v2(enrichGOResult_1, resOrdered_WK2_aggregate_NSC_ens, showCategory = 15, textSize = 9, title = "" ) + theme(title = element_text(size=8))
plot(scorePlot)
```



```{r, eval=F}
### Reactome Pathways
library(ReactomePA)
# only takes entrez id
geneChangeList <- resOrdered_aggregate_NSC_ens_sig$entrez
#geneChangeList <- sort(geneChangeList, decreasing=TRUE)
#desiredGeneChangeList <- names(geneChangeList)[abs(geneChangeList) >1] 
 all_genes <- as.character(resOrdered_WK2_aggregate_NSC_ens$entrez)
enrich_Reactome <-  enrichPathway(gene = geneChangeList, pAdjustMethod = "BH", universe=all_genes, readable = T, organism = "human")
scorePlot <- RScorePlot_v2(enrich_Reactome, resOrdered_WK2_aggregate_NSC_ens, showCategory = 25, textSize = 9, title = "" ) + theme(title = element_text(size=8))
plot(scorePlot)
```

```{r,echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE}
library(fgsea)
gsea_res_WK2_PD_NSC <- resOrdered_WK2_PD_NSC_ens %>% dplyr::select(symbol,stat) %>% na.omit() %>% distinct() %>% group_by(symbol) %>% summarize(stat=mean(stat))
# dim(gsea_res)
# head(gsea_res)

# fast Gene Set Enrichment Analysis
ranks <- deframe(gsea_res_WK2_PD_NSC)

```

### GSEA Reactome Pathways

```{r}
#pathways.reactome <- gmtPathways("./genesets/c2.cp.reactome.v7.1.symbols.gmt")
fgsea_reactome <- fgsea(pathways=pathways.reactome, stats=ranks, nperm=10000, maxSize = 500, minSize = 30)
# convert to tibble, sort by NES and select columns
fgsea_reactome_tidy <- fgsea_reactome %>% as_tibble() %>% arrange(padj) %>% dplyr::select(-pval, -ES, -nMoreExtreme)
# Show in a nice table:
fgsea_reactome_tidy %>% DT::datatable()
```



### Top 15 up and down regulated Reactome pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowd pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_reactome_up <- fgsea_reactome[ES > 0][size < 250][order(padj,-NES),pathway][1:15]
top_reactome_dn <- fgsea_reactome[ES < 0][size < 250][order(padj,NES),pathway][1:15]
top_reactome <- c(top_reactome_up, rev(top_reactome_dn))
plotGseaTable(pathways.reactome[top_reactome], ranks, fgsea_reactome, gseaParam = 0.5)
fgsea_reactome_tidy_top <- fgsea_reactome_tidy %>% filter(pathway %in% top_reactome)
```


```{r, fig.width=10}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_reactome_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down Reactome pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=7))+theme(plot.title = element_text(size=7))
p1

```

### Enrichments plots for top Reactome hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.reactome[[top_reactome_up[i]]], ranks) + labs(title=top_reactome_up[i]))
}
```



### Leading Edge heatmaps for top Reactome hits

Heatmap of row normalised rld regularised leg transformed size factor normalised read counts

```{r, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
norm_counts <- as.data.frame(assay(rld))
norm_counts <- norm_counts %>% rownames_to_column(var="gene")
norm_counts_Ens <- merge(norm_counts, t2g_genes[,c(4,9)], by.all="gene")
ens2symbol <- AnnotationDbi::select(org.Hs.eg.db, key=norm_counts_Ens$ens_gene, columns="SYMBOL", keytype="ENSEMBL", multiVals="first") %>% distinct()
ens2symbol$gene <- paste(ens2symbol$ENSEMBL,"-",ens2symbol$SYMBOL,sep="")
ens2symbol <- as_tibble(ens2symbol)
norm_counts_Ens <- norm_counts_Ens %>% column_to_rownames(var= "ens_gene") %>% dplyr::select(-gene)
norm_counts_Ens_WK2 <- norm_counts_Ens %>%  dplyr::select(starts_with("WK2_"))

```

```{r}
top_reactome_up_full <- fgsea_reactome[ES > 0][size < 250][order(padj,-NES),][1:5]

for (i in 1:5) {
  # Full pathway
  # print(pathways.reactome[[top_reactome_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_reactome_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens_WK2[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens_WK2)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  print(pheatmap(gene_counts_rownorm, col = colors, main=top_reactome_up_full[i,pathway]))
 }
  
```

### GSEA KEGG Pathways

```{r}
#pathways.kegg <- gmtPathways("./genesets/c2.cp.kegg.v7.1.symbols.gmt")
fgsea_kegg <- fgsea(pathways=pathways.kegg, stats=ranks, nperm=10000, maxSize = 500, minSize = 30)
# convert to tibble, sort by NES and select columns
fgsea_kegg_tidy <- fgsea_kegg %>% as_tibble() %>% arrange(padj) %>% dplyr::select(-pval, -ES, -nMoreExtreme)
# Show in a nice table:
fgsea_kegg_tidy %>% DT::datatable()
```





### Top 15 up and down regulated KEGG pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowd pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_kegg_up <- fgsea_kegg[ES > 0][size < 250][order(padj,-NES),pathway][1:15]
top_kegg_dn <- fgsea_kegg[ES < 0][size < 250][order(padj,NES),pathway][1:15]
top_kegg <- c(top_kegg_up, rev(top_kegg_dn))
plotGseaTable(pathways.kegg[top_kegg], ranks, fgsea_kegg, gseaParam = 0.5)
fgsea_kegg_tidy_top <- fgsea_kegg_tidy %>% filter(pathway %in% top_kegg)
```


```{r, fig.width=10}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_kegg_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.25)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down KEGG pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=8))+theme(plot.title = element_text(size=7))
p1

```

### Enrichments plots for top KEGG hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.kegg[[top_kegg_up[i]]], ranks) + labs(title=top_kegg_up[i]))
}
```




### Leading Edge heatmaps for top KEGG hits

Heatmap of row noemalised rld regularised leg transformed size factor normalised read counts

```{r, echo=FALSE, message=FALSE, warning=FALSE}
norm_counts <- as.data.frame(assay(rld))
norm_counts <- norm_counts %>% rownames_to_column(var="gene")
norm_counts_Ens <- merge(norm_counts, t2g_genes[,c(4,9)], by.all="gene")
ens2symbol <- AnnotationDbi::select(org.Hs.eg.db, key=norm_counts_Ens$ens_gene, columns="SYMBOL", keytype="ENSEMBL", multiVals="first") %>% distinct()
ens2symbol$gene <- paste(ens2symbol$ENSEMBL,"-",ens2symbol$SYMBOL,sep="")
ens2symbol <- as_tibble(ens2symbol)
norm_counts_Ens <- norm_counts_Ens %>% column_to_rownames(var= "ens_gene") %>% dplyr::select(-gene)
norm_counts_Ens_WK2 <- norm_counts_Ens %>%  dplyr::select(starts_with("WK2_"))
```

```{r,fig.height=6}
top_kegg_up_full <- fgsea_kegg[ES > 0][size < 250][order(padj,-NES),][1:5]

for (i in 1:5) {
  # Full pathway
   #print(pathways.kegg[[top_kegg_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_kegg_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens_WK2[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens_WK2)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  print(pheatmap(gene_counts_rownorm, col = colors, main=top_kegg_up_full[i,pathway]))
 }
  
```




### Top 15 up and down regulated GOBP pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowd pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_gobp_up <- fgsea_gobp[ES > 0][size < 250][order(padj,-NES),pathway][1:15]
top_gobp_dn <- fgsea_gobp[ES < 0][size < 250][order(padj,NES),pathway][1:15]
top_gobp <- c(top_gobp_up, rev(top_gobp_dn))
plotGseaTable(pathways.gobp[top_gobp], ranks, fgsea_gobp, gseaParam = 0.5)
fgsea_gobp_tidy_top <- fgsea_gobp_tidy %>% filter(pathway %in% top_gobp)
```


```{r, fig.width=10}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_gobp_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down GO-BP pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=8))+theme(plot.title = element_text(size=7))
p1

```

### Enrichments plots for top GOBP hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.gobp[[top_gobp_up[i]]], ranks) + labs(title=top_gobp_up[i]))
}
```




### Leading Edge heatmaps for top GOBP hits

Heatmap of row noemalised rld regularised leg transformed size factor normalised read counts

```{r, echo=FALSE, message=FALSE, warning=FALSE}
norm_counts <- as.data.frame(assay(rld))
norm_counts <- norm_counts %>% rownames_to_column(var="gene")
norm_counts_Ens <- merge(norm_counts, t2g_genes[,c(4,9)], by.all="gene")
ens2symbol <- AnnotationDbi::select(org.Hs.eg.db, key=norm_counts_Ens$ens_gene, columns="SYMBOL", keytype="ENSEMBL", multiVals="first") %>% distinct()
ens2symbol$gene <- paste(ens2symbol$ENSEMBL,"-",ens2symbol$SYMBOL,sep="")
ens2symbol <- as_tibble(ens2symbol)
norm_counts_Ens <- norm_counts_Ens %>% column_to_rownames(var= "ens_gene") %>% dplyr::select(-gene)
norm_counts_Ens_WK2 <- norm_counts_Ens %>%  dplyr::select(starts_with("WK2_"))

```

```{r}
top_gobp_up_full <- fgsea_gobp[ES > 0][size < 250][order(padj,-NES),][1:5]

for (i in 1:5) {
  # Full pathway
  # print(pathways.gobp[[top_gobp_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_gobp_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens_WK2[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens_WK2)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  print(pheatmap(gene_counts_rownorm, col = colors, main=top_gobp_up_full[i,pathway]))
 }
  
```




# Overlap of DEG: WK1 vs WK2


```{r, echo=FALSE, eval=FALSE}
  
  d <- " Agregate vs NSC ( WK1 vs WK2)"
res_print_WK1_aggregate_NSC <- as.data.frame(res_print_WK1_aggregate_NSC)
rownames(res_print_WK1_aggregate_NSC) <- res_print_WK1_aggregate_NSC$ens_gene

res_print_WK2_aggregate_NSC <- as.data.frame(res_print_WK2_aggregate_NSC)
rownames(res_print_WK2_aggregate_NSC) <- res_print_WK2_aggregate_NSC$ens_gene

  ## Venn Diagram: DEGs for all 3 pairwise comparisons
  sig_WK1_up <- rownames(res_print_WK1_aggregate_NSC[res_print_WK1_aggregate_NSC$fc == "up", ])
  sig_WK1_down <- rownames(res_print_WK1_aggregate_NSC[res_print_WK1_aggregate_NSC$fc == "down", ])
  sig_WK2_up <- rownames(res_print_WK2_aggregate_NSC [res_print_WK2_aggregate_NSC$fc == "up", ])
  sig_WK2_down <- rownames(res_print_WK2_aggregate_NSC[res_print_WK2_aggregate_NSC$fc == "down", ])
  
 # tiff(filename = "./DEG_genes_WK1_WK2_aggregate_vs_NSC_Venn_diagram.tiff", height = 4, width=6, units = "in", res=300)
 
 # cairo_ps("./DEG_genes_Venn_diagram.eps", height = 4, width = 5, onefile = F)
   venn.plot <- venn.diagram(x=list(S1=as.matrix(sig_WK1_up), S2=as.matrix(sig_WK1_down), S3=as.matrix(sig_WK2_up), S4=as.matrix(sig_WK2_down)), fill = c("red", "cyan3", "green3","yellow"), alpha=c(0.5, 0.5, 0.5,0.5), cex=0.6, cat.cex=0.55, fontfamily="sans", cat.fontfamily="sans", main.fontfamily = "sans", cat.dist=c(0.2,0.2,0.1,0.1),  filename=NULL, euler.d=F, scaled=F, print.mode=c("percent", "raw"), sigdigs = 2, category.names=paste0(c("Week1 UP", "Week1 Down","Week2 UP","Week2 Down"), "\n", c(length(sig_WK1_up), length(sig_WK1_down), length(sig_WK2_up), length(sig_WK2_down))), main = d, main.cex = 0.7)
  
  grid.newpage()
  grid.draw(venn.plot)
  dev.off()

```



# Heatmap of Top DEG in Week 1 and Week2

```{r,fig.height=10, fig.width= 8,echo=F, eval=FALSE}
library(pheatmap)
top_genes <- 15

 #prnt table of up and down regulated genes from DEG
    res_print_WK1_aggregate_NSC <- print_DESeq_table(res_WK1_aggregate_NSC, t2g_info = t2g_genes, alpha_level = alpha_cutoff)

    plot_up_genes_WK1 <- res_print_WK1_aggregate_NSC[fc == "up", target_id][1:top_genes]
    plot_up_genes_WK1 <- plot_up_genes_WK1[!(is.na(plot_up_genes_WK1))] # if there are not top_genes DEGs, NA values will be returned
    plot_down_genes_WK1 <- res_print_WK1_aggregate_NSC[fc == "down", target_id][1:top_genes]
    plot_down_genes_WK1 <- plot_down_genes_WK1[!(is.na(plot_down_genes_WK1))]

    res_print_WK2_aggregate_NSC <- print_DESeq_table(res_WK2_aggregate_NSC, t2g_info = t2g_genes, alpha_level = alpha_cutoff)
    
    
    plot_up_genes_WK2 <- res_print_WK2_aggregate_NSC[fc == "up", target_id][1:top_genes]
    plot_up_genes_WK2 <- plot_up_genes_WK2[!(is.na(plot_up_genes_WK2))] # if there are not top_genes DEGs, NA values will be returned
    plot_down_genes_WK2 <- res_print_WK2_aggregate_NSC[fc == "down", target_id][1:top_genes]
    plot_down_genes_WK2 <- plot_down_genes_WK2[!(is.na(plot_down_genes_WK2))]
    
    plot_down_genes_WK1 <- data.frame(plot_down_genes_WK1)
   # plot_down_genes_KO$group <- "down_TREM2_KO"
    
    plot_up_genes_WK1 <- data.frame(plot_up_genes_WK1)
   # plot_up_genes_KO$group <- "up_TREM2_KO"
    
    plot_down_genes_WK2 <- data.frame(plot_down_genes_WK2)
   # plot_down_genes_R47H$group <- "down_TREM2_R47H"
    
    plot_up_genes_WK2 <- data.frame(plot_up_genes_WK2)
    #plot_up_genes_R47H$group <- "up_TREM2_R47H"
    
    #control_genes <- data.frame(control_genes)
    #control_genes$group <- "relevant_genes"

    colnames(plot_up_genes_WK1)[1] <- "gene"
    colnames(plot_up_genes_WK2)[1] <- "gene"
    colnames(plot_down_genes_WK1)[1] <- "gene"
    colnames(plot_down_genes_WK2)[1] <- "gene"
    #colnames(control_genes)[1] <- "gene"
    
  heatmap_genes <- rbind(plot_up_genes_WK1,plot_down_genes_WK1, plot_up_genes_WK2,plot_down_genes_WK2)
  annotation_row <- heatmap_genes
  norm_counts_symbol <- merge(norm_counts, ens2symbol, by.x="gene",by.y= "gene")
  
rlog_heatmap <- norm_counts_symbol %>% filter(norm_counts_symbol$gene %in% heatmap_genes$gene)

# remove ACAT2 duplicate
drop_gene <- c("ACTA2 - ENSG00000107796")
rlog_heatmap <- rlog_heatmap %>% filter(!gene %in% drop_gene)

rownames(rlog_heatmap) <- rlog_heatmap$SYMBOL
rlog_heatmap <- rlog_heatmap[,-c(1,26:27)]

#rlog_heatmap  <- rlog_heatmap - rowMeans(rlog_heatmap) # scale using the heatmap function to get better scaling



#vsd <- vst(dds,blind=T)
#vsd_ens <- as.data.frame(assay(vsd))
#vsd_symbol <- vsd_ens %>% rownames_to_column(var = "gene") %>% inner_join(.,y = ens2symbol,by="gene")
#vsd_heatmap <- vsd_symbol %>% filter(vsd_symbol$gene %in% heatmap_genes$gene)
#vsd_heatmap <- vsd_heatmap %>% filter(!gene %in% drop_gene)

#rownames(vsd_heatmap) <- vsd_heatmap$SYMBOL
#vsd_heatmap <- vsd_heatmap[,-c(1,26:27)]

#vsd_heatmap  <- vsd_heatmap - rowMeans(vsd_heatmap) # scale using the heatmap function to get better scaling

```

```{r, fig.height= 4, fig.width=6,echo=F, eval=FALSE}
library(pheatmap)

#write.table(annotation_row, file="./heatmap_age_controlled_annotation_row.txt", sep="\t",quote=F)
anno <- as.data.frame(colData(rld)[, c("Group2","Replicate","Treatment")])
 #anno$Group <- mapvalues(anno$Group, from = c("Parent_control", "KO_control","R47H_control"), to = c("WT", "TREM2_KO","TREM2_R47H"))
 anno$Group2 <- factor(anno$Group2, levels = c("WK1_NSC", "WK1_aggregate", "WK2_NSC","WK2_aggregate"))
 colnames(anno)[1] <- "Group"
 anno_order <- c("Replicate", "Treatment", "Group")
 anno <- anno[, anno_order]
##annotation_row_1 <- read.table(file="./heatmap_age_controlled_annotation_row.txt", sep="\t", header=T)
#rownames(annotation_row_1) <- annotation_row_1$gene
#annotation_row_1$gene <- ""
#colnames(annotation_row_1)[1] <- ""
#colnames(annotation_row_1)[2] <- "Gene_group"

#ann_colors = list(
 #   Gene_group = c(down_TREM2_KO = "darkblue", down_TREM2_R47H = "deepskyblue4", down_TREM2_KO_R47H = "darkcyan", down_TREM2_R47H_KO ="cyan4", up_TREM2_KO="firebrick4", up_TREM2_R47H="darkorange",up_TREM2_KO_down_R47H="darksalmon", up_TREM2_KO_R47H="indianred1", up_TREM2_R47H_KO="indianred2",relevant_genes="black"),
  #  Group = c(WT = "darkgrey", TREM2_R47H = "darkorange3",TREM2_KO = "mediumorchid4")
#)
 ann_colors = list(
   Group = c(WK1_NSC = "#7FBFF5", WK1_aggregate = "navyblue", WK2_NSC = "grey79", WK2_aggregate = "grey23") ,
   Treatment = c(NSC ="slategrey", PD = "darkorange3", MSA = "mediumorchid4", Fibrils ="cyan4"),
   Replicate = c(R1 = "white", R2 = "white", R3 = "white")
 )
 
 
 
 
col_order <- c("WK1_R1_NSC", "WK1_R2_NSC", "WK1_R3_NSC","WK1_R1_FIB","WK1_R2_FIB","WK1_R3_FIB","WK1_R1_PD","WK1_R2_PD","WK1_R3_PD",
               "WK1_R1_MSA","WK1_R2_MSA","WK1_R3_MSA","WK2_R1_NSC", "WK2_R2_NSC", "WK2_R3_NSC","WK2_R1_FIB","WK2_R2_FIB","WK2_R3_FIB","WK2_R1_PD","WK2_R2_PD","WK2_R3_PD",
               "WK2_R1_MSA","WK2_R2_MSA","WK2_R3_MSA")

rlog_heatmap <- rlog_heatmap[, col_order]

#vsd_heatmap <- vsd_heatmap[, col_order]

DEG_heatmap <-pheatmap(rlog_heatmap, annotation_col = anno[,c("Group","Treatment", "Replicate")], fontsize = 8, fontsize_row = 8, cluster_rows = T, cutree_cols = 4, cutree_rows = 4, cluster_cols = F, clustering_method = "ward.D2", scale = "row", treeheight_row = 10,show_colnames = F, annotation_colors = ann_colors, annotation_legend = T)
DEG_heatmap



#grid::grid.newpage()
  #grid::grid.draw(DEG_heatmap$gtable)
#DEG_heatmap_2 <- as_grob(DEG_heatmap)
  
  
  
  
save_pheatmap_png <- function(x, filename, width=1200, height=1000, res = 300) {
  png(filename, width = width, height = height, res = res, units = "in")
  grid::grid.newpage()
  grid::grid.draw(x$gtable)
  dev.off()
}
 
save_pheatmap_png(DEG_heatmap, "Top15_DEG_heatmap_pooled_treatment_wardd2.png",height = 5, width=6)

cairo_ps("Top15_DEG_heatmap_pooled_treatment_wardd2.eps", height = 5, width = 6, onefile = F)
DEG_heatmap
dev.off()
```



# Pathway transiston from WK1 to WK2 in Aggregate vs NSC

## Top GSEA KEGG pathway transistion


```{r, eval=FALSE}
fgsea_kegg_tidy_top_WK1_agg_NSC$Group <- "WK1"
fgsea_kegg_tidy_top_WK2_agg_NSC$Group <- "WK2"



fgsea_kegg_tidy_top_WK1_WK2 <- rbind(fgsea_kegg_tidy_top_WK1_agg_NSC, fgsea_kegg_tidy_top_WK2_agg_NSC)

# Remove pathways that George doesnt want
drop_kegg <- c("KEGG_NON_SMALL_CELL_LUNG_CANCER","KEGG_CHRONIC_MYELOID_LEUKEMIA","KEGG_PANCREATIC_CANCER",
"KEGG_ARRHYTHMOGENIC_RIGHT_VENTRICULAR_CARDIOMYOPATHY_ARVC","KEGG_FC_EPSILON_RI_SIGNALING_PATHWAY","KEGG_LEUKOCYTE_TRANSENDOTHELIAL_MIGRATION"
,"KEGG_VASCULAR_SMOOTH_MUSCLE_CONTRACTION","KEGG_HEDGEHOG_SIGNALING_PATHWAY","KEGG_VIBRIO_CHOLERAE_INFECTION","KEGG_VASOPRESSIN_REGULATED_WATER_REABSORPTION","KEGG_COMPLEMENT_AND_COAGULATION_CASCADES","KEGG_RENAL_CELL_CARCINOMA","KEGG_ADHERENS_JUNCTION","KEGG_OLFACTORY_TRANSDUCTION",
"KEGG_PROGESTERONE_MEDIATED_OOCYTE_MATURATION","KEGG_LEISHMANIA_INFECTION","KEGG_PROSTATE_CANCER")

fgsea_kegg_top_WK1_WK2_keep <- fgsea_kegg_tidy_top_WK1_WK2 %>% filter(!pathway %in% drop_kegg)

kegg_keep <- unique(fgsea_kegg_top_WK1_WK2_keep$pathway)

kegg_plot_WK1 <- fgsea_kegg_tidy_WK1_agg_NSC %>% filter(pathway %in% kegg_keep)
kegg_plot_WK1$Group <- "WK1"

kegg_plot_WK2 <- fgsea_kegg_tidy_WK2_agg_NSC %>% filter(pathway %in% kegg_keep)
kegg_plot_WK2$Group <- "WK2"

kegg_plot_WK1_WK2 <- rbind(kegg_plot_WK1,kegg_plot_WK2)
kegg_plot_WK1_WK2_red <- kegg_plot_WK1_WK2 %>%  dplyr::select(pathway, NES, Group, padj)
# make NES values For WEEK  1 and Week2 as seperate columns
kegg_plot_WK1_WK2_wide <- kegg_plot_WK1_WK2 %>% pivot_wider( names_from = "Group", values_from = 2:6)
kegg_plot_WK1_WK2_wide$group <- ifelse(kegg_plot_WK1_WK2_wide$pathway %in% fgsea_kegg_tidy_top_WK1_agg_NSC$pathway, "WK1", "WK2")
kegg_plot_WK1_WK2_wide$Direction <- ifelse(kegg_plot_WK1_WK2_wide$group == "WK1" & kegg_plot_WK1_WK2_wide$NES_WK1 > 0,"UP",
                                           ifelse(kegg_plot_WK1_WK2_wide$group == "WK2"& kegg_plot_WK1_WK2_wide$NES_WK2>0, "UP","DOWN"
                                           ))
kegg_plot_WK1_WK2_wide$label <- paste(kegg_plot_WK1_WK2_wide$group,"-",kegg_plot_WK1_WK2_wide$Direction,sep="")
```


+ A geom_segment plot to show the change in GSEA  NES score for the same pathways between Week1 and Week2


```{r, fig.height=6, fig.width= 10, eval=FALSE}
library(viridis)
 p <- ggplot(kegg_plot_WK1_WK2_wide, aes( y= reorder(pathway, NES_WK1))) + geom_segment(aes(x = kegg_plot_WK1_WK2_wide$NES_WK1, y=pathway,                     xend= kegg_plot_WK1_WK2_wide$NES_WK2, yend=pathway),size=0.5) + xlab("Normalized Enirchment Score ") + ylab("Top KEGG pathways")
p <- p + geom_point(aes(x=kegg_plot_WK1_WK2_wide$NES_WK1, shape ="WK1", color = padj_WK1), size=3) + geom_point(aes(x = kegg_plot_WK1_WK2_wide$NES_WK2, shape="WK2", color= padj_WK2),size=3) + theme(axis.text.y = element_text(size=6), axis.text.x = element_text(size=6)) + labs (shape= "Treatment")
p <- p + scale_fill_discrete(name = "Group") + scale_color_viridis(direction = -1, "P.adj", option="D") +facet_wrap( .~label , scales = "free") + theme(strip.background = element_blank(), strip.text = element_text(size=7),legend.title = element_text(size=7), axis.title = element_text(size=6),
legend.text = element_text(size=7))
p
ggsave(filename = "./Pooled_NSC_aggregated_WK1_Wk2_top_KEGG_GSEA.pdf",width = 9,height=6, units = "in")
```

## Top GSEA GOBP pathway transistion


```{r, eval=FALSE}
fgsea_gobp_tidy_top_WK1_agg_NSC$Group <- "WK1"
fgsea_gobp_tidy_top_WK1_agg_NSC_up <- fgsea_gobp_tidy_top_WK1_agg_NSC %>% filter(NES >0)
fgsea_gobp_tidy_top_WK2_agg_NSC$Group <- "WK2"
fgsea_gobp_tidy_top_WK2_agg_NSC_up <- fgsea_gobp_tidy_top_WK2_agg_NSC %>% filter(NES >0)


fgsea_gobp_tidy_top_WK1_WK2 <- rbind(fgsea_gobp_tidy_top_WK1_agg_NSC_up, fgsea_gobp_tidy_top_WK2_agg_NSC_up)

# Remove pathways that George doesnt want
drop_gobp <- c("GO_LEUKOCYTE_HOMEOSTASIS","GO_REGULATION_OF_LAMELLIPODIUM_ORGANIZATION","GO_LYMPHOCYTE_HOMEOSTASIS",
               "GO_CILIUM_OR_FLAGELLUM_DEPENDENT_CELL_MOTILITY","GO_MALE_SEX_DIFFERENTIATION","GO_RESPONSE_TO_CORTICOSTEROID","GO_MUSCLE_CELL_MIGRATION",
               "GO_SMOOTH_MUSCLE_CELL_MIGRATION","GO_INTRACILIARY_TRANSPORT","GO_PLATELET_DERIVED_GROWTH_FACTOR_RECEPTOR_SIGNALING_PATHWAY",
               "GO_POSITIVE_REGULATION_OF_CELL_CYCLE_G1_S_PHASE_TRANSITION","GO_REGULATION_OF_INTRACELLULAR_ESTROGEN_RECEPTOR_SIGNALING_PATHWAY",
"GO_REGULATION_OF_SMOOTHENED_SIGNALING_PATHWAY","GO_CONNECTIVE_TISSUE_DEVELOPMENT","GO_ACTOMYOSIN_STRUCTURE_ORGANIZATION")

fgsea_gobp_top_WK1_WK2_keep <- fgsea_gobp_tidy_top_WK1_WK2 %>% filter(!pathway %in% drop_gobp)

drop_gobp_2 <- c("GO_POSITIVE_REGULATION_OF_PROTEIN_LOCALIZATION_TO_CELL_PERIPHERY","GO_REGULATION_OF_PROTEIN_LOCALIZATION_TO_CELL_PERIPHERY","GO_REGULATION_OF_PROTEIN_LOCALIZATION_TO_MEMBRANE","GO_POSITIVE_REGULATION_OF_PROTEIN_LOCALIZATION_TO_MEMBRANE","GO_POSITIVE_REGULATION_OF_CELLULAR_PROTEIN_LOCALIZATION","GO_PIGMENTATION","GO_FC_RECEPTOR_MEDIATED_STIMULATORY_SIGNALING_PATHWAY","GO_SMOOTHENED_SIGNALING_PATHWAY","GO_PROTEIN_CONTAINING_COMPLEX_LOCALIZATION")

fgsea_gobp_top_WK1_WK2_keep_v2 <- fgsea_gobp_top_WK1_WK2_keep %>% filter(!pathway %in% drop_gobp_2)

gobp_keep <- unique(fgsea_gobp_top_WK1_WK2_keep_v2$pathway)

gobp_plot_WK1 <- fgsea_gobp_tidy_WK1_agg_NSC %>% filter(pathway %in% gobp_keep)
gobp_plot_WK1$Group <- "WK1"


gobp_plot_WK2 <- fgsea_gobp_tidy_WK2_agg_NSC %>% filter(pathway %in% gobp_keep)
gobp_plot_WK2$Group <- "WK2"

gobp_plot_WK1_WK2 <- rbind(gobp_plot_WK1,gobp_plot_WK2)
gobp_plot_WK1_WK2$pathway <- reorder(gobp_plot_WK1_WK2$pathway,gobp_plot_WK1_WK2$NES)

# make NES values For WEEK  1 and Week2 as seperate columns
gobp_plot_WK1_WK2_wide <- gobp_plot_WK1_WK2 %>% pivot_wider( names_from = "Group", values_from = 2:6)
gobp_plot_WK1_WK2_wide$group <- ifelse(gobp_plot_WK1_WK2_wide$pathway %in% fgsea_gobp_tidy_top_WK1_agg_NSC$pathway, "WK1", "WK2")


#gobp_plot_WK1_WK2_wide$Direction <- ifelse(gobp_plot_WK1_WK2_wide$group == "WK1" & gobp_plot_WK1_WK2_wide$NES_WK1 > 0,"UP",
#                                           ifelse(gobp_plot_WK1_WK2_wide$group == "WK2"& gobp_plot_WK1_WK2_wide$NES_WK2>0, "UP","DOWN"
 #                                          ))
gobp_plot_WK1_WK2_wide$label <- paste("GSEA-",gobp_plot_WK1_WK2_wide$group,":","Aggregate vs NSC",sep="")
gobp_plot_WK1_WK2_wide$order <- ifelse(gobp_plot_WK1_WK2_wide$group == "WK1", gobp_plot_WK1_WK2_wide$NES_WK1, gobp_plot_WK1_WK2_wide$NES_WK2)
```


+ A geom_segment plot to show the change in GSEA  NES score for the same pathways between Week1 and Week2


```{r, fig.height=6, fig.width= 9, eval=FALSE}
library(viridis)
 p <- ggplot(gobp_plot_WK1_WK2_wide, aes( y=reorder(pathway, -order))) + geom_segment(aes(x = gobp_plot_WK1_WK2_wide$NES_WK1, y=pathway,                     xend= gobp_plot_WK1_WK2_wide$NES_WK2, yend=pathway),size=0.5) + xlab("Normalized Enirchment Score ") + ylab("Top GO-BP Terms")
p <- p + geom_point(aes(x=gobp_plot_WK1_WK2_wide$NES_WK1, shape ="WK1", color = padj_WK1), size=3) + geom_point(aes(x = gobp_plot_WK1_WK2_wide$NES_WK2, shape="WK2", color= padj_WK2),size=3) + theme(axis.text.y = element_text(size=7, face="bold"), axis.text.x = element_text(size=6), axis.title = element_text(size=10)) + labs (shape= "Treatment")
p <- p + scale_fill_discrete(name = "Group") + scale_color_viridis(direction = -1, "P.adj", option="D") +facet_wrap( .~label , scales = "free", ncol = 1) + theme(strip.background = element_blank(), strip.text = element_text(size=7), legend.title = element_text(size=7), axis.title = element_text(size=6),
 legend.text = element_text(size=7)) +xlim(-1.2,2.0)
p
ggsave(filename = "./Pooled_NSC_aggregated_WK1_Wk2_top_GOBP_GSEA_v2.pdf",width = 7.2,height=6, units = "in")
```

```{r, fig.width = 7, eval=F}
WK1_gobp_gt <- shake_fgseaResult(fgsea_gobp_WK1_agg_NSC)
WK2_gobp_gt <- shake_fgseaResult(fgsea_gobp_WK2_agg_NSC)
gs_summary_overview_pair(res_enrich = WK1_gobp_gt, res_enrich2 = WK2_gobp_gt,p_value_column = "gs_adj_pvalue")

anno_df_wk1 <- t2g_genes[,c(9,7)]
colnames(anno_df_wk1)[1] <- "gene_id"
colnames(anno_df_wk1)[1] <- "gene_name"

gs_summary_overview_pair(res_enrich = WK1_gobp_gt, res_enrich2 = WK2_gobp_gt,p_value_column = "gs_adj_pvalue", color_by = "gs_NES")
```


# Functional links in PPI to PD Risk Genes

+ to test if DEG genes in WK1 and WK2 have higher than expected direct links with PD risk genes in PPIs in humans
+ PD risk genes are from META5 PD risk study (NALLS 2019)
+ These PD risk genes are putative causal genes , and often are the nearest gene to the relevant risk variant in SNPS
+ Only 70 out of the 90 variants have identified putative causal gene in the META5 result
+ 85 unique PD risk genes

```{r, eval=FALSE}
# get max CDS for t2g genes  from biomart
mart <- biomaRt::useMart(biomart = "ENSEMBL_MART_ENSEMBL", dataset = "hsapiens_gene_ensembl", host="www.ensembl.org")
cds <- biomaRt::getBM(attributes = c("ensembl_transcript_id","ensembl_gene_id", "cds_length"), mart = mart)
cds <- cds %>% drop_na()
cds_gene <- cds %>% group_by(ensembl_gene_id) %>% summarise(max_length = max(cds_length), mean_length = mean(cds_length)) 
setnames(cds_gene, c("ensembl_gene_id"), c("gene"))
```

```{r, eval=FALSE}
pd_genes <- read.table(file= "./PD_genes_Nalls_2019.txt", sep="\t", header=T)
pd_genes_ens <- merge(pd_genes, t2g_genes[,c(4,7)],by.x ="Gene", by.y="ext_gene")
pd_genes_unique <- unique(pd_genes_ens$ens_gene)
```



```{r, eval=FALSE}
ppi_net <- fread(file = "./PPImerged_Jimena2017_score")
setnames(ppi_net, c("gene1","gene2","score"))
## how many simulations/randomisations
n_sim <- 10000
```


```{r, eval=FALSE}
WK1_DEG <- resOrdered_WK1_aggregate_NSC_ens %>% filter(padj < alpha_cutoff) %>% dplyr::select(ens_gene)
WK1_DEG <- WK1_DEG$ens_gene
WK1_universe <- resOrdered_WK1_aggregate_NSC_ens %>% filter(!is.na(padj)) %>% select(ens_gene) %>% drop_na()
WK1_universe <- WK1_universe$ens_gene
WK2_DEG <- resOrdered_WK2_aggregate_NSC_ens %>% filter(padj < alpha_cutoff) %>% dplyr:: select(ens_gene)
WK2_DEG <- WK2_DEG$ens_gene
WK2_universe <- resOrdered_WK2_aggregate_NSC_ens %>% filter(!is.na(padj)) %>% select(ens_gene) %>% drop_na
WK2_universe <- WK2_universe$ens_gene
```

## WK1 Aggregate vs NSC DEG overlap

```{r, eval=FALSE}
WK1_overlap <- test_enrich_two_sets_avi(input_net = ppi_net ,input_cds = cds_gene,input_list_1 = WK1_DEG , input_list_2 = pd_genes_unique,input_universe = WK1_universe,n_rand = 10000 )
```

## WK2 Aggregate vs NSC DEG overlap

```{r, eval=FALSE}
WK2_overlap <- test_enrich_two_sets_avi(input_net = ppi_net ,input_cds = cds_gene,input_list_1 = WK2_DEG , input_list_2 = pd_genes_unique,input_universe = WK2_universe,n_rand = 10000 )
```


```{r}
sessionInfo()
```


---
title: "George_Tofaris_iPSC_pooled_ALL_treatments_NSC version 2"
author: "Devika Agarwal"
date: 'Last update: `r date()`'
output:
  html_document:
    theme: cerulean
    number_sections: true
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: yes
      toc_depth: 8
---
<style type="text/css">

body{ /* Normal  */
      font-size: 12px;
  }
td {  /* Table  */
  font-size: 12px;
}
h1.title {
  font-size: 18px;
  color: DarkRed;
}
h1 { /* Header 1 */
  font-size: 16px;
  color: DarkBlue;
}
h2 { /* Header 2 */
    font-size: 14px;
  color: DarkBlue;
}
h3 { /* Header 3 */
  font-size: 12px;
  font-family: "Times New Roman", Times, serif;
  color: DarkBlue;
}

h4 { /* Header 4 */
  font-size: 12px;
  font-family: "Times New Roman", Times, serif;
  color: DarkBlue;
}
code.r{ /* Code block */
    font-size: 12px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 14px;
}
</style>
```{r setup, include=F, message=F, warning=FALSE}
knitr::opts_chunk$set(echo=FALSE,message=FALSE,warning=FALSE, cache=TRUE)
#rm(list=ls())
#biocLite("sva") #install sva
#install.packages("DT")
#install.packages("png")
library(knitr)
library(sva)
library(DT)
library(png)
library(grid)
library(plyr)
#biocLite("biomaRt")
library(biomaRt)
library(tidyverse)
library(corrr)
#install.packages("gplots")
library(gplots)
#install.packages("dendextend")
library(dendextend)
library(ggplot2)
#biocLite("oligo")
#library(oligo)
#install.packages("data.table")
library(data.table)
#source("https://bioconductor.org/biocLite.R")
#biocLite("limma")
#library(limma)
#source("https://bioconductor.org/biocLite.R")
#biocLite("DESeq2")
library(DESeq2)
#install.packages("stringr")
library(stringr)
#install.packages("RColorBrewer")
library(RColorBrewer)
#library(scater)
library(tximport) # here only needed to get and report effective gene lengths
library(readr) # used by tximport for faster import
library(VennDiagram)
library(ggrepel)
library(clusterProfiler)
library(GeneTonic)
library(viridis)
library(splitstackshape) 
library(RUVSeq)
# for splitting data table columns
#library(tximeta)


futile.logger::flog.threshold(futile.logger::ERROR, name = "VennDiagramLogger")

## white background theme for all plots
theme_set(theme_bw())
multicoreParam <- MulticoreParam(workers = 6)
multicoreParam
```


```{r functions}
# Vector to colours
Vector2Colour <- function(clase, ucol2 = c("red", "blue"), alfa = .8, Pal = "Blues"){
  colores <- vector(length = length(clase))
  if(is.numeric(clase)){
    pal1 <- colorRampPalette(brewer.pal(n = 9, name = Pal)[3:9], space = "Lab")
    ucol <- pal1(length(unique(clase)))
    rk <- rank(clase)
    rku <- unique(rk)
    rku <- rku[order(rku)]
    for (i in c(1:length(ucol))){
      colores[which(rank(clase) == rku[i])] <- ucol[i]    
    }
  } else {
    if(length(unique(clase)) == 2){
      ucol <- ucol2
      for (i in c(1:length(ucol))){
        colores[which(clase == unique(clase)[i])] <- ucol[i]    
      }
    } else {
      if(length(unique(clase)) < 9){
        pal1 <- brewer.pal(9, "Set1")[-6] # Remove yellow
        ucol <- pal1[1:length(unique(clase))]
        for (i in c(1:length(ucol))){
          colores[which(clase == unique(clase)[i])] <- ucol[i]    
        }
      } else {
        if(length(unique(clase)) > 8){
          pal1 <- colorRampPalette(brewer.pal(n = 7, name = "Dark2"), space = "Lab")
          ucol <- pal1(length(unique(clase)))
          for (i in c(1:length(ucol))){
            colores[which(clase == unique(clase)[i])] <- ucol[i]    
          }
        }
      }
    }  
  }
  colores <- alpha(colores, alpha = alfa)
  return(colores)
}


# From_Jimena
# Hyperlinks to ensembl 
ens_links <- function(geneids){
  genelinks <- vector()
  for (i in c(1:length(geneids))){
  genelinks[i] <- paste('<a href="', paste("http://www.ensembl.org/Mus_musculus/Gene/Summary?g=", geneids[i], sep = ""),'">', geneids[i], '</a>', sep = "")   }
  return(genelinks)
}  

ensembl_url <- "<a href=\"http://www.ensembl.org/Homo_sapiens/Gene/Summary?g="

# From_Frank
# create hyperlinks in tables printed with the DT package
set_hyperlinks <- function(DT, col_names, url_strings) {
  DT_out <- copy(DT)  
  for (i in 1:length(col_names)){
    ## DT_out[, (col_names[i]) := paste0(url_strings[i], get(col_names[i]),"\">", get(col_names[i]),"</a>")]
    DT_out[(col_names[i]) != '', (col_names[i]) := paste0(url_strings[i], get(col_names[i]),"\">", get(col_names[i]),"</a>")]
  }
  DT_out
}

# From Jimena
# TPM_matrix from tx object #
TPM_from_tx <- function(tx_import_object){
  countsbylength <- tx_import_object$counts/tx_import_object$length
  total_countsbylength <- colSums(countsbylength)
  data_TPM <- t(apply(countsbylength, 1, function(x) x / total_countsbylength * 1000000))
  colnames(data_TPM) <- colnames(tx_import_object$counts)
  return(data_TPM)
}

## re-format DESeq2 results table


print_DESeq_table <- function(A, alpha_level = 0.05, t2g_info = t2g_genes, merge_column = "gene", logfcthreshold=0){
  
  A_2 <- as.data.table(A)
  A_2 <- A_2[, target_id := rownames(A)]
  A_2 <- A_2[order(pvalue)]
  A_2 <- A_2[log2FoldChange < (-logfcthreshold), fc := "down"]
  A_2[log2FoldChange < (-logfcthreshold) & !is.na(padj), rank := 1:sum(log2FoldChange < (-logfcthreshold))]
  A_2 <- A_2[log2FoldChange > logfcthreshold, fc := "up"]
  A_2[log2FoldChange > logfcthreshold & !is.na(padj), rank := 1:sum(log2FoldChange > logfcthreshold)]
  
  A_2 <- A_2[padj < alpha_level, ]
  
  A_2[,c("lfcSE") := NULL]
  
  C <- merge(A_2, t2g_info[, .(gene, ens_gene, gene_type, ext_gene, desc)], by.x="target_id", by.y=merge_column, all.x=T)
  ### C <- C[, target_id := NULL] ## keep for now, for look-up
  
  setcolorder(C, c("target_id", "ext_gene", "ens_gene", "log2FoldChange","pvalue", "padj", "fc", "rank", "baseMean", "gene_type", "desc"))
  
  C[, c("log2FoldChange","pvalue","padj") := list(signif(log2FoldChange, 3), signif(pvalue, 3), signif(padj, 3))]
  C[, baseMean := round(baseMean, digits=1)]
  setnames(C, c("log2FoldChange"), c("log2FC"))
  C[order(pvalue)]
}




## create table to combine results from 3 concentrations
print_DESeq_union_table <- function(L, M, H, alpha_level = 0.05, t2g_info = t2g_genes, merge_column = "target_id"){
  
  setnames(L, c("target_id", paste0(colnames(L)[-1], "_L")))
  setnames(M, c("target_id", paste0(colnames(M)[-1], "_M")))
  setnames(H, c("target_id", paste0(colnames(H)[-1], "_H")))
  
  C <- merge(L[, .(target_id, log2FoldChange_L, padj_L)], M[, .(target_id, log2FoldChange_M, padj_M)], by="target_id")
  C <- merge(C, H[, .(target_id, log2FoldChange_H, padj_H)], by="target_id")
  
  C <- C[log2FoldChange_L < 0, fc_L := "down"]
  C <- C[log2FoldChange_L > 0, fc_L := "up"]
  C <- C[log2FoldChange_M < 0, fc_M := "down"]
  C <- C[log2FoldChange_M > 0, fc_M := "up"]
  C <- C[log2FoldChange_H < 0, fc_H := "down"]
  C <- C[log2FoldChange_H > 0, fc_H := "up"]
  
  C <- C[, sig_num := sum(padj_L < alpha_cutoff, padj_M < alpha_cutoff, padj_H < alpha_cutoff, na.rm = T), by="target_id"]
  C <- C[padj_L < alpha_cutoff, L := "L"]
  C <- C[padj_M < alpha_cutoff, M := "M"]
  C <- C[padj_H < alpha_cutoff, H := "H"]
  
  C <- merge(C, t2g_info[, .(target_id, ens_gene, ext_gene, desc)], by.x="target_id", by.y=merge_column, all.x=T)
  C <- C[, target_id := NULL]
  
  setcolorder(C, c("ext_gene", "ens_gene", "sig_num", c("L","M","H"), paste0("fc_", c("L","M","H")), paste0("log2FoldChange_", c("L","M","H")), paste0("padj_", c("L","M","H")), "desc"))
  
  C[, c(paste0("log2FoldChange_", c("L","M","H")), paste0("padj_", c("L","M","H"))) := list(signif(log2FoldChange_L, 3), signif(log2FoldChange_M, 3), signif(log2FoldChange_H, 3), signif(padj_L, 3), signif(padj_M, 3), signif(padj_H, 3))]
  
  setnames(C, paste0("log2FoldChange_", c("L","M","H")), paste0("l2fc_", c("L","M","H")))
  C[order(-sig_num)]
}


## print top DEGs
# get data from DESeq2 plotCounts function
# counts data is normalized 
# from `DESeq2::counts`: normalized: logical indicating whether or not to divide the counts by the size factors or normalization factors before returning (normalization factors always preempt size factors)
my_plot_counts <- function(obj, plot_genes=NULL, intgroup_vec=c("Treatment_time", "Group"), t2g_info=NULL, n_ncol=4, n_nrow =6, title=NULL){

  # collect data for each gene
  plot_data_all <- as.data.table(plotCounts(obj, gene = plot_genes[1], intgroup_vec, returnData=TRUE,transform = F))
  plot_data_all[, gene := plot_genes[1]]
  plot_data_all[, gene_idx := formatC(1,width=2,flag='0')]
  
  if (length(plot_genes) >= 2){
    for (i in 2:length(plot_genes)){
      
      plot_data <- as.data.table(plotCounts(obj, gene = plot_genes[i], intgroup_vec, returnData=TRUE,transform = F))
      plot_data[, gene := plot_genes[i]]
      plot_data[, gene_idx := formatC(i,width=2,flag='0')]
      plot_data_all <- rbind(plot_data_all, plot_data)
    }
  }
  
  plot_data_all <- merge(plot_data_all, t2g_info[, .(gene, ext_gene)], by.x="gene", by.y="gene")
  # plot_data_all[, gene_print := paste0(gene_idx, "  ", gene, "  ", ext_gene)]
  # plot_data_all[, gene_print := paste0(gene_idx, "  ", gene)]
  plot_data_all[, gene_print := paste0(gene_idx, "  ", ext_gene)] ## use only gene symbol as facet title
  
  p <- ggplot(data = plot_data_all, aes(x=Group, y=log2(count+1), colour=Treatment_time))
  p <- p + geom_violin(aes(group=Group), alpha = 0, colour = "gray60", scale="width")
  ## p <- p + ggbeeswarm::geom_quasirandom(alpha = 0.6, size = 3, groupOnX = TRUE)
  p <- p + geom_point(position = position_jitterdodge(), size=5, alpha=0.6)
  p <- p + xlab(NULL)
  p <- p + facet_wrap(~gene_print, ncol=n_ncol, scales="free_y",nrow = n_nrow)
  p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
  p <- p + ylab("log2(normalised count + 1)") + theme(legend.position="top")
  p <- p + theme(axis.text.x=element_text(angle=90, hjust=1, size=10)) + theme(axis.text.y = element_text(size=8))
  p <- p + ggtitle(title)
  p
}


getRScore <- function(geneIDs, DEGs) {
  pathgenes <- str_split(geneIDs, "/") %>% unlist()
  deRes <- as.data.frame(DEGs)
  deRes <- subset(deRes,deRes$symbol %in% pathgenes)
  up <- deRes %>% dplyr::filter(log2FoldChange > 0) %>% nrow()
  down <- deRes %>% dplyr::filter(log2FoldChange < 0) %>% nrow()
  
  #score <- (up - down) / nrow(deRes)
  score <- (up - down) /sqrt(up + down)
  
  return(score)
}

getRScore_v2 <- function(geneIDs, DEGs) {
  pathgenes <- str_split(geneIDs, "/") %>% unlist()
  deRes <- as.data.frame(DEGs)
  deRes <- subset(deRes,deRes$entrez %in% pathgenes)
  up <- deRes %>% dplyr::filter(log2FoldChange > 0) %>% nrow()
  down <- deRes %>% dplyr::filter(log2FoldChange < 0) %>% nrow()
  
  #score <- (up - down) / nrow(deRes)
  score <- (up - down) /sqrt(up + down)
  
  return(score)
}
RScorePlot <- function(enrichObj, DESeqRes, showCategory = 25, textSize = 10, title = NULL) {
  df <- enrichObj@result %>% 
    separate(GeneRatio, c("obs_hits", "obs_total"), "/") %>% 
    separate(BgRatio, c("exp_hits", "exp_total"), "/")
  df$Rscore <- map_dbl(enrichObj@result$geneID, getRScore, DESeqRes)
  df <- df %>% 
    mutate_at(3:6, as.numeric) %>% 
    dplyr::mutate(enrichScore = (obs_hits/obs_total)/(exp_hits/exp_total)) %>% 
    as.data.frame() %>% 
    dplyr::arrange(p.adjust) %>% 
    dplyr::slice(1:showCategory)

  p <- df %>% 
    ggplot(aes(x = reorder(Description, -log10(p.adjust)), y = -log10(p.adjust))) +
    geom_point(aes(col = Rscore, size = enrichScore)) +
    coord_flip() +
    scale_color_distiller(limits = c(-1, 1), type = "div", palette = "RdBu", direction = 1 ) +
    ylab("adjusted p-value (-log10)") +
    xlab(NULL) +
    ggtitle(title) +
    theme_bw() +
    theme(text = element_text(size = textSize))
  return(p)
}


RScorePlot_v2 <- function(enrichObj, DESeqRes, showCategory = 25, textSize = 10, title = NULL) {
  df <- enrichObj@result %>% 
    separate(GeneRatio, c("obs_hits", "obs_total"), "/") %>% 
    separate(BgRatio, c("exp_hits", "exp_total"), "/")
  df$Rscore <- map_dbl(enrichObj@result$geneID, getRScore, DESeqRes)
  df <- df %>% 
    dplyr::filter(Count >=10 & pvalue < 0.05) %>%
    mutate_at(3:6, as.numeric) %>% 
    dplyr::mutate(enrichScore = (obs_hits/obs_total)/(exp_hits/exp_total)) %>% 
    as.data.frame() %>% 
    dplyr::arrange(p.adjust) %>% 
    dplyr::slice(1:showCategory)

  p <- df %>% 
    ggplot(aes(x = reorder(Description, -log10(p.adjust)), y = -log10(p.adjust))) +
    geom_point(aes(fill = Rscore, size =Count), stroke=0.5, shape=21) +
    coord_flip() +
    scale_fill_gradient2(low=("darkblue"),mid="white",high =("darkred")) +
    #scale_color_distiller(limits = c(-1, 1), type = "div", palette = "RdBu", direction = -1 ) +
    ylab("adjusted p-value (-log10)") +
    xlab(NULL) +
    ggtitle(title) +
    theme_bw() +
    theme(text = element_text(size = textSize))
  return(p)
}

RScorePlot_v3 <- function(enrichObj, DESeqRes, showCategory = 25, textSize = 10, title = NULL) {
  df <- enrichObj@result %>% 
    separate(GeneRatio, c("obs_hits", "obs_total"), "/") %>% 
    separate(BgRatio, c("exp_hits", "exp_total"), "/")
  df$Rscore <- map_dbl(enrichObj@result$geneID, getRScore, DESeqRes)
  df <- df %>% 
    mutate_at(3:6, as.numeric) %>% 
    dplyr::mutate(enrichScore = (obs_hits/obs_total)/(exp_hits/exp_total)) %>% 
    as.data.frame() %>% 
    dplyr::arrange(p.adjust) %>% 
    dplyr::slice(1:showCategory)

  p <- df %>% 
    ggplot(aes(x = reorder(Description, -log10(p.adjust)), y = -log10(p.adjust))) +
    geom_point(aes(fill = Rscore, size =Count),stroke=0.5, shape=21) +
    coord_flip() +
    scale_fill_gradient2(low=("darkblue"),mid="white",high =("darkred")) +
    #scale_color_distiller(limits = c(-1, 1), type = "div", palette = "RdBu", direction = 1 ) +
    ylab("adjusted p-value (-log10)") +
    xlab(NULL) +
    ggtitle(title) +
    theme_bw() +
    theme(text = element_text(size = textSize))
  return(p)
}

RScorePlot_v4 <- function(enrichObj, DESeqRes, showCategory = 25, textSize = 10, title = NULL) {
  df <- enrichObj@result %>% 
    separate(GeneRatio, c("obs_hits", "obs_total"), "/") %>% 
    separate(BgRatio, c("exp_hits", "exp_total"), "/")
  df$Rscore <- map_dbl(enrichObj@result$geneID, getRScore_v2, DESeqRes)
  df <- df %>% 
    dplyr::filter(Count >=10 & pvalue < 0.05) %>%
    mutate_at(3:6, as.numeric) %>% 
    dplyr::mutate(enrichScore = (obs_hits/obs_total)/(exp_hits/exp_total)) %>% 
    as.data.frame() %>% 
    dplyr::arrange(p.adjust) %>% 
    dplyr::slice(1:showCategory)

  p <- df %>% 
    ggplot(aes(x = reorder(Description, -log10(p.adjust)), y = -log10(p.adjust))) +
    geom_point(aes(fill = Rscore, size =Count), stroke=0.5, shape=21) +
    coord_flip() +
    scale_fill_gradient2(low=("darkblue"),mid="white",high =("darkred")) +
    #scale_color_distiller(limits = c(-1, 1), type = "div", palette = "RdBu", direction = -1 ) +
    ylab("Adjusted p-value (-log10)") +
    xlab(NULL) +
    ggtitle(title) +
    theme_bw() +
    theme(text = element_text(size = textSize))
  return(p)
}


pcaCorrPlot <- function(counts, ntop = 2000, metadata, returnData = FALSE) {
  #pca
  rv <- rowVars(assay(counts))
  rowSel <- order(rv, decreasing = T)[seq_len(ntop)]
  pca <- prcomp(t(assay(counts)[rowSel, ]))
  percentVar <- pca$sdev^2 / sum(pca$sdev^2)

  #attach PCs to metadata
  pc.df <- pca$x %>% 
    as.data.frame() %>% 
    rownames_to_column(var = "sample")
  meta <- metadata %>% 
    mutate(joinName = paste(sample, treatment, sep = "."))
  meta <- inner_join(meta, pc.df, by = c( "joinName" = "sample"))
  meta <- meta %>% 
    dplyr::select(-disease, -joinName, -fastq, -mapped)

  #column names by variable type
  facCols <- meta %>% 
    dplyr::select_if(is.factor) %>%
    colnames()

  pcCols <- meta %>%
    dplyr::select(starts_with("PC")) %>%
    colnames()

  #factor correlations
  facCor.df <- expand.grid(pcCols, facCols) 

  rsquared <- facCor.df %>%
    apply(1, function(x) reformulate(x[2], x[1])) %>%
    lapply(., lm, data = meta) %>%
    map(summary) %>%
    map_dbl("r.squared")

  facCor.df$corr <- sqrt(rsquared)

  facCor.df <- facCor.df %>%
    dplyr::rename(PC = Var1, covariate = Var2) %>%
    mutate(type = "lm")

  #numeric correlations
  numCor.df <- meta %>%
    dplyr::select_if(is.numeric) %>%
    correlate(method = "kendall") %>%
    focus(-matches("^PC")) %>%
    gather(variable, corr, 2:7) %>%
    mutate(type = "kendall") %>%
    dplyr::rename(PC = rowname, covariate = variable)

  #combine
  pcaBar <- bind_rows(numCor.df, facCor.df)

  #filter sample and sex
  pcaBar <- pcaBar %>%
    filter( ! (covariate %in% c("sample", "sex")))

  #add percent variation
  pcs <- paste("PC", 1:8, sep = "")
  pvar <- data.frame( PC = pcs, perVar = paste(pcs, " (", sprintf("%.2f", percentVar * 100), "%)", sep = ""))
  pcaBar <- inner_join(pcaBar, pvar)

  #arrange
  pcaBar <- pcaBar %>%
    group_by(PC) %>%
    arrange(corr) %>%
    unite("pcvar", PC, covariate, sep = "_", remove = F) %>%
    data.frame() %>%
    mutate(pcvar = factor(pcvar, levels = pcvar))

  #return data
  if (returnData) {
    return(pcaBar)
  }

  #plot
  pcaBar %>%
    group_by(PC) %>%
    ggplot(aes(x = pcvar, y = corr)) +
    geom_col(aes(fill = type)) +
    coord_flip() + 
    facet_wrap( ~ perVar, scale = "free_y") +
    xlab("metadata") +
    ylab("correlation") +
    scale_x_discrete(breaks = pcaBar$pcvar, labels = pcaBar$covariate) +
    scale_y_continuous(limits = c(-1, 1)) +
    scale_fill_manual(values = c("darkorange", "dodgerblue")) +
    theme_bw()

}

plotPCA_higher_2_3 <- function(object, intgroup = "condition", ntop=1000, returnData = FALSE) {
        rv <- rowVars(assay(object))
        select <- order(rv, decreasing = TRUE)[seq_len(min(ntop,
            length(rv)))]
        pca <- prcomp(t(assay(object)[select, ]))
        percentVar <- pca$sdev^2/sum(pca$sdev^2)
        if (!all(intgroup %in% names(colData(object)))) {
            stop("the argument 'intgroup' should specify columns of colData(dds)")
        }
        intgroup.df <- as.data.frame(colData(object)[, intgroup,
            drop = FALSE])
        group <- if (length(intgroup) > 1) {
            factor(apply(intgroup.df, 1, paste, collapse = ":"))
        }
        else {
            colData(object)[[intgroup]]
        } 
        d <- data.frame(PC2 = pca$x[, 2], PC3 = pca$x[, 3], group = group,
            intgroup.df, name = colnames(object))
        if (returnData) {
            attr(d, "percentVar") <- percentVar[2:3]
            return(d)
        }
        g<-ggplot(data = d, aes_string(x = "PC2", y = "PC3", color = "group")) +
            geom_point(size = 3) + xlab(paste0("PC2: ", round(percentVar[2] *
            100,2), "%")) + ylab(paste0("PC3: ", round(percentVar[3] *
            100,2), "%")) + coord_fixed()
        return(g)
}


plotPCA_higher_3_4 <- function(object, intgroup = "condition", ntop=1000, returnData = FALSE) {
        rv <- rowVars(assay(object))
        select <- order(rv, decreasing = TRUE)[seq_len(min(ntop,
            length(rv)))]
        pca <- prcomp(t(assay(object)[select, ]))
        percentVar <- pca$sdev^2/sum(pca$sdev^2)
        if (!all(intgroup %in% names(colData(object)))) {
            stop("the argument 'intgroup' should specify columns of colData(dds)")
        }
        intgroup.df <- as.data.frame(colData(object)[, intgroup,
            drop = FALSE])
        group <- if (length(intgroup) > 1) {
            factor(apply(intgroup.df, 1, paste, collapse = ":"))
        }
        else {
            colData(object)[[intgroup]]
        } 
        d <- data.frame(PC3 = pca$x[, 3], PC4 = pca$x[, 4], group = group,
            intgroup.df, name = colnames(object))
        if (returnData) {
            attr(d, "percentVar") <- percentVar[3:4]
            return(d)
        }
        g<-ggplot(data = d, aes_string(x = "PC3", y = "PC4", color = "group")) +
            geom_point(size = 3) + xlab(paste0("PC3: ", round(percentVar[3] *
            100,2), "%")) + ylab(paste0("PC4: ", round(percentVar[4] *
            100,2), "%")) + coord_fixed()
        return(g)
}

plotPCA_higher_4_5 <- function(object, intgroup = "condition", ntop=1000, returnData = FALSE) {
        rv <- rowVars(assay(object))
        select <- order(rv, decreasing = TRUE)[seq_len(min(ntop,
            length(rv)))]
        pca <- prcomp(t(assay(object)[select, ]))
        percentVar <- pca$sdev^2/sum(pca$sdev^2)
        if (!all(intgroup %in% names(colData(object)))) {
            stop("the argument 'intgroup' should specify columns of colData(dds)")
        }
        intgroup.df <- as.data.frame(colData(object)[, intgroup,
            drop = FALSE])
        group <- if (length(intgroup) > 1) {
            factor(apply(intgroup.df, 1, paste, collapse = ":"))
        }
        else {
            colData(object)[[intgroup]]
        } 
        d <- data.frame(PC4 = pca$x[, 4], PC5 = pca$x[, 5], group = group,
            intgroup.df, name = colnames(object))
        if (returnData) {
            attr(d, "percentVar") <- percentVar[4:5]
            return(d)
        }
        g<-ggplot(data = d, aes_string(x = "PC4", y = "PC5", color = "group")) +
            geom_point(size = 3) + xlab(paste0("PC4: ", round(percentVar[4] *
            100,2), "%")) + ylab(paste0("PC5: ", round(percentVar[5] *
            100,2), "%")) + coord_fixed()
        return(g)
}

plotPCA_higher_5_6 <- function(object, intgroup = "condition", ntop=1000, returnData = FALSE) {
        rv <- rowVars(assay(object))
        select <- order(rv, decreasing = TRUE)[seq_len(min(ntop,
            length(rv)))]
        pca <- prcomp(t(assay(object)[select, ]))
        percentVar <- pca$sdev^2/sum(pca$sdev^2)
        if (!all(intgroup %in% names(colData(object)))) {
            stop("the argument 'intgroup' should specify columns of colData(dds)")
        }
        intgroup.df <- as.data.frame(colData(object)[, intgroup,
            drop = FALSE])
        group <- if (length(intgroup) > 1) {
            factor(apply(intgroup.df, 1, paste, collapse = ":"))
        }
        else {
            colData(object)[[intgroup]]
        } 
        d <- data.frame(PC5 = pca$x[, 5], PC6 = pca$x[, 6], group = group,
            intgroup.df, name = colnames(object))
        if (returnData) {
            attr(d, "percentVar") <- percentVar[5:6]
            return(d)
        }
        g<-ggplot(data = d, aes_string(x = "PC5", y = "PC6", color = "group")) +
            geom_point(size = 3) + xlab(paste0("PC5: ", round(percentVar[5] *
            100,2), "%")) + ylab(paste0("PC6: ", round(percentVar[6] *
            100,2), "%")) + coord_fixed()
        return(g)
}

test_enrich_two_sets_avi <- function(input_net, input_cds, input_list_1, input_list_2, input_universe, n_rand){
  ## restrict to universe
  input_net <- input_net[gene1 %in% input_universe & gene2 %in% input_universe, ]
  cat("  \n* Links in PPI network within gene universe: ", nrow(input_net), fill=T)
  ## sum of scores for each gene in network
  ## for PPI this is equivalent to the number of PPIs/links to other genes
  net_melt <- melt(input_net, id.vars = c("score"))
  net_genes_scores <- net_melt[, sum(score), by = "value"]
  setnames(net_genes_scores, c("gene", "score"))
  
  ## consider only those genes that are in the network AND have CDS length info
  info_table <- merge(net_genes_scores, input_cds, by="gene")
  
  ## consider only genes from input lists that are in input network and have CDS length info
  input_list_1 <- intersect(input_list_1, info_table[, gene])
  input_list_2 <- intersect(input_list_2, info_table[, gene])

  ## 'Avi'-like binning approach
  ## the same as in GeneNet Toolbox using 'scott' method
  n_bins_score <- nclass.scott(info_table[, score])
  n_bins_cds <-  nclass.scott(info_table[, max_length])
  
  ## print(n_bins_score)
  ## print(n_bins_cds)
  
  ## prepare data: get unique overall bins/groups based on score AND cds and number of input genes within each of those bins
  ## this will determine how many genes to pick from each bin/group
  
  x <- copy(info_table)
  x$group_score <- as.factor(cut(x$score, n_bins_score, labels=F))
  x$group_cds <- as.factor(cut(x$max_length, n_bins_cds, labels=F))
  ## combine the two bins to get 'unique bins' for both gene attributes
  x <- x[, group := as.numeric(as.factor(paste0(group_score, "_", group_cds)))]
  
  ## in which bins/groups do the input genes fall:
  x <- x[, n_list_1 := 0]
  x <- x[gene %in% input_list_1, n_list_1 := 1]
  x <- x[, n_list_2 := 0]
  x <- x[gene %in% input_list_2, n_list_2 := 1]
  
  ## number of genes to draw per group i.e. number of input genes in each group
  n_list_1_per_group <- x[n_list_1 == 1, list(n_list_1 = .N), by="group"]
  n_list_2_per_group <- x[n_list_2 == 1, list(n_list_2 = .N), by="group"]
  
  ## number of candidate genes per group, across all groups
  n_size_per_group <- x[, list(bin_size = .N),by="group"]
  
  ## 2 look-up tables: list all genes within the unique bins
  ## 1 table for each input gene list
  
  bin_table_1 <- merge(n_list_1_per_group, n_size_per_group, by="group")
  bin_table_1 <- bin_table_1[, idx_in_group := paste(1:bin_size, collapse = ','), by="group"]
  genes_bins_table_1 <- cSplit(bin_table_1, splitCols = "idx_in_group", sep = ",", direction = "long")[order(group, idx_in_group)]
  bin_table_1 <- bin_table_1[, idx_in_group := NULL]
  genes_bins_table_1 <- cbind(genes_bins_table_1[, group := NULL], x[group %in% bin_table_1[, group], .(gene, group, score, max_length)][order(group, gene)])
  
  bin_table_2 <- merge(n_list_2_per_group, n_size_per_group, by="group")
  bin_table_2 <- bin_table_2[, idx_in_group := paste(1:bin_size, collapse = ','), by="group"]
  genes_bins_table_2 <- cSplit(bin_table_2, splitCols = "idx_in_group", sep = ",", direction = "long")[order(group, idx_in_group)]
  bin_table_2 <- bin_table_2[, idx_in_group := NULL]
  genes_bins_table_2 <- cbind(genes_bins_table_2[, group := NULL], x[group %in% bin_table_2[, group], .(gene, group, score, max_length)][order(group, gene)])

  ### scores_rand <- data.table(overlap_with_list_1 = numeric(length=n_rand), overlap_with_list_2 = numeric(length=n_rand), score = numeric(length=n_rand))
  scores_rand <- matrix(nrow = n_rand + 1, ncol = 3)

  ## create reverse table, speed up  
  input_net_reverse <- copy(input_net)
  setnames(input_net_reverse, c("gene2", "gene1", "score"))
  setcolorder(input_net_reverse, c("gene1", "gene2", "score"))
  input_net_reverse <- rbind(input_net, input_net_reverse)
  keycols = c("gene1", "gene2")
  setkeyv(input_net_reverse, keycols)
  
  for (k in 1:n_rand) {
    
    ## from each bin/group get random genes
    rand_set_1 <- bin_table_1[, sample(1:bin_size, n_list_1), by="group"] ## get random index set
    setnames(rand_set_1, "V1", "idx_in_group")
    rand_set_1 <- merge(genes_bins_table_1, rand_set_1, by=c("group", "idx_in_group"))
    
    rand_set_2 <- bin_table_2[, sample(1:bin_size, n_list_2), by="group"] ## get random index set
    setnames(rand_set_2, "V1", "idx_in_group")
    rand_set_2 <- merge(genes_bins_table_2, rand_set_2, by=c("group", "idx_in_group"))
    
    links_across <- input_net_reverse[(gene1 %chin% rand_set_1[, gene] & gene2 %chin% rand_set_2[, gene]), ] ## rather slow
    scores_rand[k,] <- c(length(intersect(rand_set_1[, gene], input_list_1)), length(intersect(rand_set_2[, gene], input_list_2)), sum(links_across[, score]))
  }
  
  ## sum of scores for original two gene sets
  links_across <- input_net_reverse[(gene1 %chin% input_list_1 & gene2 %chin% input_list_2), ]
  scores_rand[n_rand + 1, ] <- c(length(input_list_1), length(input_list_2), sum(links_across[, score]))
  
  scores_rand <- as.data.table(scores_rand)
  setnames(scores_rand, c("Overlap_1", "Overlap_2", "Score"))

  ## write summary
  ## average length of randomised sets
  # cat("Length of list 1: ", scores_rand[n_rand+1, Overlap_1], fill=T)
  # cat("Average overlap of random sets with list 1: ", round(mean(scores_rand[1:n_rand, Overlap_1])), fill=T)
  # cat("Length of list 2: ", scores_rand[n_rand+1, Overlap_2], fill=T)
  # cat("Average overlap of random sets with list 2: ", round(mean(scores_rand[1:n_rand, Overlap_2])), fill=T)
  # 
  # cat("Number of simulations: ", n_rand, fill=T)
  # cat("Score for gene lists tested: ", scores_rand[n_rand+1, Score], fill=T)
  # cat("Average score for random gene lists: ", round(mean(scores_rand[1:n_rand, Score])), fill=T)
  # 
  # n_as_good <- sum(scores_rand[1:n_rand, Score] >= scores_rand[n_rand+1, Score])
  # cat("Number of times random sets have the same or higher score: ", n_as_good, fill=T)
  # if (n_as_good == 0){
  #   cat("Empirical p-value: <", 1/n_rand, fill=T)
  # } else {
  #   cat("Empirical p-value: ", n_as_good/n_rand, fill=T)
  # }
  
  
  cat("  \n* Length of list 1: ", scores_rand[n_rand+1, Overlap_1], fill=T)
  cat("  \n* Average overlap of random sets with list 1: ", round(mean(scores_rand[1:n_rand, Overlap_1])), fill=T)
  cat("  \n* Length of list 2: ", scores_rand[n_rand+1, Overlap_2], fill=T)
  cat("  \n* Average overlap of random sets with list 2: ", round(mean(scores_rand[1:n_rand, Overlap_2])), fill=T)
  
  cat("  \n* Number of simulations: ", n_rand, fill=T)
  cat("  \n* Score for gene lists tested: ", scores_rand[n_rand+1, Score], fill=T)
  cat("  \n* Average score for random gene lists: ", round(mean(scores_rand[1:n_rand, Score])), fill=T)
  
  n_as_good <- sum(scores_rand[1:n_rand, Score] >= scores_rand[n_rand+1, Score])
  cat("  \n* Number of times random sets have the same or higher score: ", n_as_good, fill=T)
  if (n_as_good == 0){
    cat("  \n* Empirical p-value: <", 1/n_rand, fill=T)
  } else {
    cat("  \n* Empirical p-value: ", n_as_good/n_rand, fill=T)
  }
  
  scores_rand
}


```



+ Samples: 48 samples in total
+ Genotype : SNCA triplication (clone 3)
+ Stimulation : Non-seeded control(NSC),PD , FIB and MSA, n= 9 each for PD and NSC and n=3 for MSA and FIB
+ Stimulation time : Week1, Week2
+ Differentiation Age post treatment : DIV 52 (Week1) , DIV 59 (Week 2)
+ generate cDNA : Novaseq 6000 and PolyA library prep
+ generate libraries : 
+ Organism: Homo_sapiens
+ Tissue & Cell: iPSC-derived dopinamergic neurons
+ read_type : paired, 150 bp
+ Fragment Library type :IU (Inward Unstranded, an unstranded paired-end library where the reads face each other)
+ Pseudoalignment : Kallisto (v0.46.2)
+ Reference Genome: Ensemble  Release 102
+ Pooled differential analysis for 15 treated samples and 9 NSC iPSC DaN samples
+ DEG comparisons : WK2 Agg vs Agg PD , WK2 NSC vs WK1 NSC and comparisons of common and unique genesets
+ using ComBat-Seq for batch correction for PCA with rlog and blind =FALSE


```{r files, include=FALSE}
setwd("~/Documents/George_tofaris_manuscripts/2021_June_DaNs_coC_mic/DaNs_treated_PD/")
## Salmon using Mouse ensembl GRCm38 reference
#quant_dir <- "./kallisto3/abundance/"


# Salmon or Kallisto for abundance data
# in_type <- "Kallisto"
in_type <- "kallisto"

# samples metadata
samples_file <- "./June_Jan_21_DaN_treated_metadata_alltreated_aggregated.csv"

# transcript to gene mapping
# generated from headers of fasta file used as transcriptome reference
# contains version numbers for ensembl transcript and gene IDs (v102)
ens_annot_file <- "../genome_v102/Homo_sapiens.GRCh38.cdna.all_genemap.txt"

#salmon_duplicates_file <- "~/Documents//Hazel_ipsc/Homo_sapiens.GRCh38.v95.cdna.all.ncrna_index/duplicate_clusters.tsv"
## number of components for plots e.g. PCA
n_comp <- 6

# n_comp <- 4

## theme size for scater plots
t_size <- 14

## seed to make some plots reproducible
n_seed <- 12

## DESeq2 settings

pre_filter_type <- "counts"
# pre_filter_type <- "tpm"

# minimum expression of a gene - pre-filtering step
# if counts are used: a rowsum-threshold 
# expression_cutoff <- 0 # at least one sample has to have an estimated count of 1
expression_cutoff <- 10 # at least 2 counts across all samples, i.e. remove genes with only 0 or 1 read across all samples
#expression_cutoff <- 15 # at 10 counts across all samples , 
# expression_cutoff <- -1 # no filtering
# if fpkms are used: each gene has at least 1 sample with FPKM > expression_cutoff

# adjusted alpha value
alpha_cutoff <- 0.05

# how many genes with lowest adjusted pvalue to print
top_genes <- 20


## make use of multiple cores
register(MulticoreParam(6))
```

```{r print_setting}

cat("Quantification data from: ", in_type, fill=T)

```

```{r set_annotation}
t2g <- fread(ens_annot_file, header=F)
setnames(t2g, c("target_id", "seqtype", "location", "ens_gene", "gene_type", "tx_type", "ext_gene", "desc"))

# remove version number from ensembl gene IDs
t2g <- t2g[, ens_gene := gsub('\\..*', '', ens_gene, perl=T)]

# combine external gene symbol with ensembl ID
t2g <- t2g[, gene := paste0(ext_gene, ' - ', ens_gene)]

# remove duplicates identified by Salmon index
#salmon_duplicates <- fread(salmon_duplicates_file)
#t2g <- t2g[!(target_id %in% salmon_duplicates[, DuplicateTxp]), ]

###############################################
## consider only protein coding genes
t2g <- t2g[gene_type == "protein_coding", ]
###############################################

# unique ensembl gene IDs
t2g_genes <- unique(t2g, by="ens_gene")
# setnames(t2g_genes, c("target_id", "ens_gene"), c("tx_id", "target_id")) # ensembl ID as target_id
setnames(t2g_genes, c("target_id", "gene"), c("tx_id", "target_id")) # gene symbol + esnembl ID as new target_id


# unique ensembl gene IDs
t2g_genes <- unique(t2g, by="ens_gene")
## setnames(t2g_genes, c("target_id", "ens_gene"), c("tx_id", "target_id"))
## setnames(t2g_genes, c("target_id", "gene"), c("tx_id", "target_id"))

```

```{r setup_samples}

samples_meta <- read_csv(file = samples_file, locale = locale(encoding = "Latin1"))

#samples_meta <- samples_meta[, Condition := factor(Condition, levels=c( "ND", "AD","PD"))]
#samples_meta <- samples_meta[, sample.time := factor(sample.time, levels=c(2,4,6,8))]
samples_meta$Sample_ID <- as.character(samples_meta$Sample_ID)
#samples_meta$Sample_name  <- as.factor(samples_meta$Sample_name)
samples_meta$Replicate <- as.factor(samples_meta$Replicate)
samples_meta$Replicate_2 <- as.factor(samples_meta$Replicate_2)
samples_meta$Treatment_time <- as.factor(samples_meta$Treatment_time)
samples_meta$Treatment_time <- relevel(samples_meta$Treatment_time, ref ="WK1")
samples_meta$Batch <- as.factor(samples_meta$Batch)
samples_meta$Treatment <- as.factor(samples_meta$Treatment)
samples_meta$Treatment <- relevel(samples_meta$Treatment, ref="NSC")
samples_meta$Group <- paste(samples_meta$Treatment_time,"_",samples_meta$Treatment,sep="")
#samples_meta$Differentiation_Age <- as.factor(samples_meta$Differentiation_Age)
samples_meta$Stimulation <- as.factor(samples_meta$Stimulation)
samples_meta$Stimulation <- relevel(samples_meta$Stimulation, ref="NSC")
samples_meta$Group_2 <- as.factor(samples_meta$Group_2)#
samples_meta$Group_2 <- relevel(samples_meta$Group_2, ref="WK1_NSC")

#quant_dirs <- list.dirs(quant_dir, full.names = TRUE, recursive = FALSE)
#quant_dirs_short <- list.dirs(quant_dir, full.names = FALSE, recursive = FALSE)

#quant_dirs_table <- data.table(Sample=quant_dirs_short, path=quant_dirs)
#quant_files_table <- data.table(Sample=quant_dirs_short, path=file_path)

#samples_meta_merged <- merge(samples_meta, quant_dirs_table, by.x="Sample_name", by.y= "Sample", all.x=T)

#samples_meta <- samples_meta_merged

```

-------------------------------

# Samples metadata

---------------------------------
```{r samples_overview, echo=FALSE, cache=T}
#samples_meta_merged <- as.data.frame(samples_meta_merged)
samples_meta_print <- subset.data.frame(samples_meta,select = c(Sample_ID,Replicate_2,Batch,Group,Group_2, Stimulation, Treatment_time))
#samples_meta_print <- samples_meta_print[, .(sample.id, sample.group_name,sample.genotype, sample.time,sample.gender, sample.rin, sample.3pbias)]
samples_meta_print %>% DT::datatable(caption="iPSC DaNS", escape=F)
#kable(samples_meta_print, caption =" LCM microglia and astrocytes SN of Control, AD and PD patients", escape = T, format="markdown", padding=2)
```

# Import Expression Data

* use tximport to import Kallisto counts for transcripts summarised as genes in to DESEQ2

* after aggregation of transcripts to genes, remove those genes with zero variance - i.e. no expression at all across samples


```{r test_t2g, eval=FALSE}

cat("Unique ensembl genes provided in transcript to gene mapping file: ", length(unique(t2g[, ens_gene])), fill=T)

```

```{r tximport_setup_1, include=F, eval=F}

if (in_type == "kallisto"){
  files_tximport <- paste0(samples_meta$path, "/", "abundance.h5")
} else {
  files_tximport <- paste0(samples_meta$path, "/", "quant.sf")
}
#only included protein coding genes
names(files_tximport) <- samples_meta[, "Sample_name"]
## txi <- tximport(files_tximport, type = tolower(in_type), tx2gene = t2g[, .(target_id, ens_gene)], reader = read_tsv)
txi <- tximport(files_tximport, type = in_type, tx2gene = t2g_genes[, .(target_id, gene)], txOut = F, countsFromAbundance = "no", ignoreTxVersion = F)

#txi_2 <- tximport(files_tximport, type = "salmon", tx2gene = t2g[, .(target_id, gene)], txOut = T, countsFromAbundance = "no")
#saveRDS(txi, file="tximport_kallisto3.rds")
```


# Import data into DESeq2

* Remove genes with less than 10 counts across atleast 3 samples (the total number of replicates per group)

```{r tximport_merge, echo=FALSE, eval=T, results='hide'}
txi_1 = readRDS(file="./tximport_kallisto.rds")
txi_1$infReps <- NULL
txi_2 = readRDS(file="./tximport_kallisto3.rds")

abundance_temp <- txi_2$abundance
#keep <- c("WK1_R1_NSC","WK1_R2_NSC","WK1_R3_NSC", "WK1_R1_PD","WK1_R2_PD","WK1_R3_PD","WK2_R1_NSC","WK2_R2_NSC","WK2_R3_NSC","WK2_R1_PD","WK2_R2_PD","WK2_R3_PD")

#abundance_temp <- abundance_temp[,keep]
abundance_temp <- as.data.frame(abundance_temp)
setnames(abundance_temp, c("WK1_R1_NSC","WK1_R2_NSC","WK1_R3_NSC", "WK1_R1_PD","WK1_R2_PD","WK1_R3_PD","WK2_R1_NSC","WK2_R2_NSC","WK2_R3_NSC","WK2_R1_PD","WK2_R2_PD","WK2_R3_PD"), c("WK1_R7_NSC","WK1_R8_NSC","WK1_R9_NSC", "WK1_R7_PD","WK1_R8_PD","WK1_R9_PD","WK2_R7_NSC","WK2_R8_NSC","WK2_R9_NSC","WK2_R7_PD","WK2_R8_PD","WK2_R9_PD"))

abundance_temp <- as.matrix(abundance_temp)

txi_2$abundance <- abundance_temp

counts_temp <- txi_2$counts
#keep <- c("WK1_R1_NSC","WK1_R2_NSC","WK1_R3_NSC", "WK1_R1_PD","WK1_R2_PD","WK1_R3_PD","WK2_R1_NSC","WK2_R2_NSC","WK2_R3_NSC","WK2_R1_PD","WK2_R2_PD","WK2_R3_PD")

#counts_temp <- counts_temp[,keep]
counts_temp <- as.data.frame(counts_temp)
setnames(counts_temp, c("WK1_R1_NSC","WK1_R2_NSC","WK1_R3_NSC", "WK1_R1_PD","WK1_R2_PD","WK1_R3_PD","WK2_R1_NSC","WK2_R2_NSC","WK2_R3_NSC","WK2_R1_PD","WK2_R2_PD","WK2_R3_PD"), c("WK1_R7_NSC","WK1_R8_NSC","WK1_R9_NSC", "WK1_R7_PD","WK1_R8_PD","WK1_R9_PD","WK2_R7_NSC","WK2_R8_NSC","WK2_R9_NSC","WK2_R7_PD","WK2_R8_PD","WK2_R9_PD"))

counts_temp <- as.matrix(counts_temp)

txi_2$counts <- counts_temp


length_temp <- txi_2$length
#keep <- c("WK1_R1_NSC","WK1_R2_NSC","WK1_R3_NSC", "WK1_R1_PD","WK1_R2_PD","WK1_R3_PD","WK2_R1_NSC","WK2_R2_NSC","WK2_R3_NSC","WK2_R1_PD","WK2_R2_PD","WK2_R3_PD")

#length_temp <- length_temp[,keep]
length_temp <- as.data.frame(length_temp)
setnames(length_temp, c("WK1_R1_NSC","WK1_R2_NSC","WK1_R3_NSC", "WK1_R1_PD","WK1_R2_PD","WK1_R3_PD","WK2_R1_NSC","WK2_R2_NSC","WK2_R3_NSC","WK2_R1_PD","WK2_R2_PD","WK2_R3_PD"), c("WK1_R7_NSC","WK1_R8_NSC","WK1_R9_NSC", "WK1_R7_PD","WK1_R8_PD","WK1_R9_PD","WK2_R7_NSC","WK2_R8_NSC","WK2_R9_NSC","WK2_R7_PD","WK2_R8_PD","WK2_R9_PD"))

length_temp <- as.matrix(length_temp)

txi_2$length <- length_temp

txi_all <- Map(cbind,txi_1,txi_2)
rm(abundance_temp,length_temp,counts_temp,txi_1,txi_2)

saveRDS(txi_all, file = "Jan_Jun_21_NSC_all_treatment_tximport_kallisto.rds")


txi_all <- readRDS(file="./Jan_Jun_21_NSC_all_treatment_tximport_kallisto.rds")
samples_meta <- as.data.frame(samples_meta)
rownames(samples_meta) <- (samples_meta$Sample_ID)
samples_meta[ order(match(rownames(samples_meta), colnames(txi_all$counts))), ]

counts <- as.data.frame(txi_all$counts)


setcolorder(counts, rownames(samples_meta))

txi_all$counts <- as.matrix(counts)

abundance <- as.data.frame(txi_all$abundance)
setcolorder(abundance, rownames(samples_meta))

txi_all$abundance <- as.matrix(abundance)

length <- as.data.frame(txi_all$length)
setcolorder(length, rownames(samples_meta))
txi_all$length <- as.matrix(length)
saveRDS(txi_all, file = "Jan_Jun_21_NSC_all_treatment_tximport_kallisto.rds")

rm(abundance,length)
```


```{r deseq_setup, echo=FALSE}


txi_all <- readRDS(file="./Jan_Jun_21_NSC_all_treatment_tximport_kallisto.rds")


## if only protein coding genes are used:
## "transcripts missing genes: 56393"
stopifnot(all.equal(colnames(txi_all$counts), rownames(samples_meta)))
samples_meta$Batch <- as.factor(samples_meta$Batch)
samples_meta$Group_2 <- as.factor(samples_meta$Group_2)
samples_meta$Stimulation <- as.factor(samples_meta$Stimulation)
samples_meta$Treatment_time <- as.factor(samples_meta$Treatment_time)
dds <- DESeqDataSetFromTximport(txi_all, samples_meta, design = ~ Batch + Treatment_time + Stimulation + Treatment_time:Stimulation )
# using counts and average transcript lengths from tximport
# dds is now ready for DESeq() see DESeq2 vignette
# stores the rounded integers from txi$counts and tx lengths
# 2 assays: counts and avgTxLength
# NOTE: if tximport was run with countsFromAbundance as "scaledTPM" or "lengthScaledTPM", then only the counts are imported

cat("Assay names of DESeq dataset: ", assayNames(dds), fill=T)
cat("Number of genes and samples: ", dim(dds), fill=T)
cat("Number of genes with no read (estimated count) in any sample: ", sum(rowSums(counts(dds)) == 0), fill=T)
cat("Number of genes with exactly a count of 1 in a single sample (genes with row sum of 1): ", sum(rowSums(counts(dds)) == 1), fill=T)

## pre-filtering for low expression
cat("Expression threshold for exclusion of genes: ", expression_cutoff, fill=T)

if (pre_filter_type == "counts"){
  cat("Number of genes excluded: ", sum(rowSums(counts(dds) <= expression_cutoff ) <= 3), fill=T)
  keep <- rowSums(counts(dds) >= expression_cutoff) >= 3
  dds <- dds[keep, ]
} else if (pre_filter_type == "fpkm"){
  # Robust normalization is not used if average transcript lengths are present, which is the case here!
  # hence, raw counts are used here, and this is the basic calculation performed in fpm function:
  ## k <- counts(dds)
  ## library.sizes <- colSums(k)
  ## fpm_my <- 1e+06 * sweep(k, 2, library.sizes, "/")
  ## all.equal(fpm_test, fpm_my) # TRUE
  fpkm_robust <- DESeq2::fpkm(dds)
  cat("Number of genes excluded with less than 10 reads across a minimum of 3 samples: ", rowSums(fpkm_robust > expression_cutoff) < 3, fill=T)
  dds <- dds[rowSums(fpkm_robust > expression_cutoff) >= 3, ]
} else { stop("Unknown pre-filter type!")}


cat("Number of genes and samples after filtering: ", dim(dds), fill=T)

#expression_cutoff value =1 and to filter genes based on that based on RNA_seq workflow
# removing rows of the DESeqDataSet that have no counts, or only a single count across all samples
# DESEQ2 vignette suggests to use rowsums of counts >= 10 to keep

#dds <- dds[ rowSums(counts(dds)) >= 10, ]
#dim(dds)


dds <- estimateSizeFactors(dds)
sample_counts_norm <- counts(dds, normalized=T)
#colnames(sample_counts_norm) <- samples_meta$Sample_geo_accession
write.table(sample_counts_norm, file="Tofaris_Jan_June21_iPSC_DaNS_DESEQ2_counts_normalised_allsamples.txt", sep="\t", quote=F)
#sample_fpkm_robust <- DESeq2::fpkm(dds, robust = T)
#sample_fpkm_robust_log2_1 <- (log2(sample_fpkm_robust+1))
#write.table(sample_fpkm_robust_log2_1, file= "All_dis_chall_RNAseq_DESEQ2_microglia_fpkm_log2_1.txt", sep="\t",quote=F)
#write.table(samples_meta, file="GSE75431_sample_microglia_metadata.txt", sep="\t", quote=F)

```

# Exploratory Data analysis 1

+ Rlog transformation tends to works well on small datasets (n<30) and for datasets with veyr different sequencing depth across samples, using Blind=FALSE 
+ Corrected for Batch effect (June vs Jan study ) by usingComBat, with reference batch 
+ plot heatmaps and PCA plots on ComBat batch corrected rld data and preserving changes between samples by including Group as variable in the design matrix

```{r rlog_transform, include=FALSE}
# The function rlog returns an object based on the SummarizedExperiment class that contains the rlog-transformed values in its assay slot.
## slow
 rld <- rlogTransformation(dds, blind=FALSE)

# correct for batch effect

mm <- model.matrix(~ (Group) , colData(rld))
#limma_rld <- limma::removeBatchEffect(rlog_matrix, batch = rld$Batch,design = mm)

rlog_matrix <- assay(rld)

#mm <- model.matrix(~Group , colData(rld))
combat_rld <- sva::ComBat(rlog_matrix, batch = rld$Batch, mod =  mm, par.prior = T, prior.plots = F, ref.batch = 1)

assay(rld) <-combat_rld


#assay(rld) <-limma_rld
```

## Sample Clustering


```{r sample_distances, echo=FALSE}
sampleDists <- dist(t(combat_rld))
#sampleDists
```

### Heatmap (Rlog transformation)

 

```{r sample_clustering_1, echo=FALSE, fig.height=6}
library("pheatmap")
library("RColorBrewer")
sampleDistMatrix <- as.matrix( sampleDists )
rownames(sampleDistMatrix) <- paste(rld$Group_2,"_", rld$Batch, sep="")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         col = colors,clustering_method = "ward.D2")
```

### Heatmap (Poisson Distance)

* This measure of dissimilarity between counts also takes the inherent variance structure of counts into consideration when calculating the distances between samples. 
```{r poison_distance, echo=FALSE}
library("PoiClaClu")
poisd <- PoissonDistance(t(combat_rld))
```


```{r Poisson_clustering_2, echo=FALSE, fig.height=5}
samplePoisDistMatrix <- as.matrix( poisd$dd )
rownames(samplePoisDistMatrix) <- paste( dds$Group_2,"_",dds$Batch, sep="" )
colnames(samplePoisDistMatrix) <- NULL
pheatmap(samplePoisDistMatrix,
         clustering_distance_rows = poisd$dd,
         clustering_distance_cols = poisd$dd,
         col = colors, clustering_method = "ward.D2")
```


## PCA plots with Rlog transformation 

+ ComBat corrected data for Batch effect
+ Top 500 & Top 100 most variable genes and all genes


```{r PCA_rlog, fig.height=5,fig.width=8}

plot_data <- DESeq2::plotPCA(rld, intgroup =c("Replicate_2", "Group_2","Batch","Stimulation","Sample_ID"), returnData = T,ntop=500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by RLog transformation + ComBat corrected data:")
p <- ggplot(data = plot_data, aes(x=PC1, y=PC2, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC1 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC2 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p


col_vector <-  c("WK1" ="#7FBFF5","WK2"="#061B29" )

#rld$Group <- factor(rld$Group, levels = c("WK1_NSC", "WK1_PD", "WK1_MSA","WK1_Fibrils", "WK2_NSC","WK2_PD","WK2_MSA","WK2_Fibrils"))
plot_data <- DESeq2::plotPCA(rld, intgroup =c("Replicate_2", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T,ntop=1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by RLog transformation + ComBat corrected data :")
p <- ggplot(data = plot_data, aes(x=PC1, y=PC2, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.9, size=6, position = "jitter")  + scale_shape(solid = FALSE)
#p <- p + scale_color_manual(values = col_vector) + scale_shape_manual(values=c(1, 0, 2,5))
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5, point.padding = 0.5)
p <- p + xlab(paste0("PC1 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC2 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by RLog transformation") 
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p <- p + theme(axis.title = element_text(size=12, face="bold"))
p
#ggsave(filename = "PCA_1_2_top1000_HVG_v3.pdf",width = 5, height = 4)



cat("all genes by Rlog + Combat correction: ", dim(dds)[1])
plot_data <- DESeq2::plotPCA(rld, intgroup =c("Replicate", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

p <- ggplot(data = plot_data, aes(x=PC1, y=PC2, color=Group_2, shape= Batch))
p <- p + geom_point(alpha = 0.6, size=8, position = "jitter") 
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5, point.padding = 0.5)
p <- p + xlab(paste0("PC1 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC2 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p



```

## PCA plots PC 2-3

+ Top 500 & Top 100 most variable genes and all genes

```{r}
 plot_data <- plotPCA_higher_2_3(object = rld, intgroup =c("Replicate_2", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T, ntop = 500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC2, y=PC3, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=6)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC2 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC3 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p


col_vector <-  c("WK1" ="#7FBFF5","WK2"="#061B29" )

plot_data <- plotPCA_higher_2_3(object = rld, intgroup =c("Replicate", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T, ntop = 1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC2, y=PC3, color= Group_2, shape= Batch )) ## size = ?
p <- p + geom_point(alpha = 0.9, size=6, position="jitter") 
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5, point.padding = 0.5) 
#+ scale_shape_manual(values=c(1, 0, 2,5))
#p <- p + scale_color_manual(values = col_vector)
p <- p + xlab(paste0("PC2 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC3 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p <- p + theme(axis.title = element_text(size=12, face="bold"))
p
#ggsave(filename = "PCA_2_3_top1000_HVG_v3.pdf",width = 5, height = 4)




plot_data <- plotPCA_higher_2_3(object = rld, intgroup =c("Replicate", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("All genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC2, y=PC3, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=6)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC2 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC3 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p
```


## PCA plots PC 3-4


```{r}
 plot_data <- plotPCA_higher_3_4(object = rld, intgroup =c("Replicate_2", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T, ntop = 500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC3, y=PC4, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=6)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC3 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC4 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_3_4(object = rld, intgroup =c("Replicate_2", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T, ntop = 1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC3, y=PC4, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=6)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC3 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC4 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_3_4(object = rld, intgroup =c("Replicate_2", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("All genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC3, y=PC4, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=6)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC3 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC4 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p
```


## PCA plots PC 5-6


```{r}
plot_data <- plotPCA_higher_5_6(object = rld, intgroup =c("Replicate_2", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T, ntop = 500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC5, y=PC6, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=6)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC5 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC6 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_5_6(object = rld, intgroup =c("Replicate_2", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T, ntop = 1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC5, y=PC6, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=6)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC5 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC6 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_5_6(object = rld, intgroup =c("Replicate_2", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("All genes by RLog transformation:")
p <- ggplot(data = plot_data, aes(x=PC5, y=PC6, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=6)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC5 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC6 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p
```



# Exploratory Data analysis 2

+ VST transformation tends to works well on large datasets (n>30) 
+ Corrected for Batch effect (June vs Jan study ) by using ComBat from the sva package witth Group_2 in the design matrix and reference batch as group 1
+ plot heatmaps and PCA plots on ComBat batch corrected rlog transformed data as vst transformation doesnt correct for batch as well as rlog does

```{r , include=T}
library(sva)
# The function rlog returns an object based on the SummarizedExperiment class that contains the rlog-transformed values in its assay slot.
## slow
#design(dds) <- formula(~Batch + Group)
 vsd <- vst(dds, blind= FALSE)

# correct for batch effect
vst_matrix <- assay(vsd)
mm <- model.matrix(~Group , colData(vsd))
combat_vsd <- sva::ComBat(vst_matrix, batch = vsd$Batch, mod =  mm, ref.batch = 1)

assay(vsd) <-combat_vsd
```

## Sample Clustering


```{r , echo=FALSE}
sampleDists <- dist(t(combat_vsd))
#sampleDists
```

### Heatmap (vst transformation)

 

```{r sample_clustering_2, echo=FALSE, fig.height=6}
library("pheatmap")
library("RColorBrewer")
sampleDistMatrix <- as.matrix( sampleDists )
rownames(sampleDistMatrix) <- paste(vsd$Group_2,"_", vsd$Batch, sep="")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         col = colors,clustering_method = "ward.D2")
```

### Heatmap (Poisson Distance)

* This measure of dissimilarity between counts also takes the inherent variance structure of counts into consideration when calculating the distances between samples. 
```{r poison_distance_2, echo=FALSE}
library("PoiClaClu")
poisd <- PoissonDistance(t(combat_vsd))
```


```{r Poisson_clustering_3, echo=FALSE, fig.height=5}
samplePoisDistMatrix <- as.matrix( poisd$dd )
rownames(samplePoisDistMatrix) <- paste( dds$Group_2,"_",dds$Batch, sep="" )
colnames(samplePoisDistMatrix) <- NULL
pheatmap(samplePoisDistMatrix,
         clustering_distance_rows = poisd$dd,
         clustering_distance_cols = poisd$dd,
         col = colors, clustering_method = "ward.D2")
```


## PCA plots with vst transformation 

+ sva::Combat corrected data for Batch effect

+ Top 500 & Top 100 most variable genes and all genes


```{r PCA_vst, fig.height=5,fig.width=8}

plot_data <- DESeq2::plotPCA(vsd, intgroup =c("Replicate", "Group_2","Batch","Stimulation","Sample_ID"), returnData = T,ntop=500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by VST transformation:")
p <- ggplot(data = plot_data, aes(x=PC1, y=PC2, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC1 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC2 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by VST transformation + Combat correction ")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p


col_vector <-  c("WK1" ="#7FBFF5","WK2"="#061B29" )

#rld$Group <- factor(rld$Group, levels = c("WK1_NSC", "WK1_PD", "WK1_MSA","WK1_Fibrils", "WK2_NSC","WK2_PD","WK2_MSA","WK2_Fibrils"))
plot_data <- DESeq2::plotPCA(vsd, intgroup =c("Replicate", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T,ntop=1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by VST transformation:")
p <- ggplot(data = plot_data, aes(x=PC1, y=PC2, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.9, size=6, position = "jitter")  + scale_shape(solid = FALSE)
#p <- p + scale_color_manual(values = col_vector) + scale_shape_manual(values=c(1, 0, 2,5))
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5, point.padding = 0.5)
p <- p + xlab(paste0("PC1 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC2 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by VST transformation + Combat Correction") 
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p <- p + theme(axis.title = element_text(size=12, face="bold"))
p
#ggsave(filename = "PCA_1_2_top1000_HVG_v3.pdf",width = 5, height = 4)



cat("all genes: ", dim(dds)[1])
plot_data <- DESeq2::plotPCA(vsd, intgroup =c("Replicate", "Group_2","Sample_ID","Stimulation","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

p <- ggplot(data = plot_data, aes(x=PC1, y=PC2, color=Group_2, shape= Batch))
p <- p + geom_point(alpha = 0.6, size=8, position = "jitter") 
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC1 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC2 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by VST transformation + Combat correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p



```



## PCA plots PC 2-3

+ Top 500 & Top 100 most variable genes and all genes

```{r}
 plot_data <- plotPCA_higher_2_3(object = vsd, intgroup =c("Replicate", "Group_2","Sample_ID","Treatment","Batch"), returnData = T, ntop = 500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by vst transformation + ComBat correction :")
p <- ggplot(data = plot_data, aes(x=PC2, y=PC3, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC2 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC3 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by vst transformation + Combat Correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p


col_vector <-  c("WK1" ="#7FBFF5","WK2"="#061B29" )

plot_data <- plotPCA_higher_2_3(object = vsd, intgroup =c("Replicate", "Group_2","Sample_ID","Treatment","Batch"), returnData = T, ntop = 1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by vst transformation + ComBat correction:")
p <- ggplot(data = plot_data, aes(x=PC2, y=PC3, color= Group_2, shape= Batch )) ## size = ?
p <- p + geom_point(alpha = 0.9, size=6, position="jitter") 
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5, point.padding = 0.5) 
#+ scale_shape_manual(values=c(1, 0, 2,5))
#p <- p + scale_color_manual(values = col_vector)
p <- p + xlab(paste0("PC2 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC3 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by vst transformation + ComBat correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p <- p + theme(axis.title = element_text(size=12, face="bold"))
p
#ggsave(filename = "PCA_2_3_top1000_HVG_v3.pdf",width = 5, height = 4)




plot_data <- plotPCA_higher_2_3(object = vsd, intgroup =c("Replicate", "Group_2","Sample_ID","Treatment","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("All genes by vsd transformation + ComBat correction:")
p <- ggplot(data = plot_data, aes(x=PC2, y=PC3, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC2 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC3 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by vst transformation + ComBat Correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p
```


## PCA plots PC 3-4


```{r}
 plot_data <- plotPCA_higher_3_4(object = vsd, intgroup =c("Replicate", "Group_2","Sample_ID","Treatment","Batch"), returnData = T, ntop = 500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by vst transformation + ComBat correction:")
p <- ggplot(data = plot_data, aes(x=PC3, y=PC4, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC3 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC4 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by RLog transformation")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_3_4(object = vsd, intgroup =c("Replicate", "Group_2","Sample_ID","Treatment","Batch"), returnData = T, ntop = 1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by vst transformation + ComBat Correction:")
p <- ggplot(data = plot_data, aes(x=PC3, y=PC4, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC3 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC4 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by vst transformation + Combat correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_3_4(object = vsd, intgroup =c("Replicate", "Group_2","Sample_ID","Treatment","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("All genes by vst transformation + ComBat correction:")
p <- ggplot(data = plot_data, aes(x=PC3, y=PC4, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC3 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC4 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by vst transformation + ComBat correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p
```


## PCA plots PC 5-6


```{r}
plot_data <- plotPCA_higher_5_6(object = vsd, intgroup =c("Replicate", "Group_2","Sample_ID","Treatment","Batch"), returnData = T, ntop = 500)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 500 most variable genes by vst transformation + ComBat correction:")
p <- ggplot(data = plot_data, aes(x=PC5, y=PC6, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC5 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC6 (", percent_var[2], "%)"))
p <- p + ggtitle("top 500 most variable genes by vst transformation + Combat Correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_5_6(object = vsd, intgroup =c("Replicate", "Group_2","Sample_ID","Treatment","Batch"), returnData = T, ntop = 1000)
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("top 1000 most variable genes by vst transformation + ComBat correction:")
p <- ggplot(data = plot_data, aes(x=PC5, y=PC6, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC5 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC6 (", percent_var[2], "%)"))
p <- p + ggtitle("top 1000 most variable genes by vst transformation + ComBat correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p

plot_data <- plotPCA_higher_5_6(object = vsd, intgroup =c("Replicate", "Group_2","Sample_ID","Treatment","Batch"), returnData = T, ntop = dim(dds)[1])
percent_var <- round(100 * attr(plot_data, "percentVar"), 2)

cat("All genes by vst transformation + ComBat Correction:")
p <- ggplot(data = plot_data, aes(x=PC5, y=PC6, color= Group_2, shape= Batch)) ## size = ?
p <- p + geom_point(alpha = 0.6, size=8)
p <- p + geom_text_repel(aes(label=Sample_ID), size=2.5)
p <- p + xlab(paste0("PC5 (", percent_var[1], "%)"))
p <- p + ylab(paste0("PC6 (", percent_var[2], "%)"))
p <- p + ggtitle("All genes by vst transformation + ComBat Correction")
p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
p
```

## PCA correlation with covariates 

 + correlation of PCAs with multiple metadata covariates
 + using  ComBat batch corrected Rlog transformed data (as better in correcting batche effect than vst)  and top 1000 HVG
 
```{r, fig.height=6, fig.width=10}



  ntop = 1000
  rv <- rowVars(assay(rld))
  rowSel <- order(rv, decreasing = T)[seq_len(ntop)]
  pca <- prcomp(t(assay(rld)[rowSel, ]))
  percentVar <- pca$sdev^2 / sum(pca$sdev^2)
   #attach PCs to metadata
  pc.df <- pca$x %>% 
    as.data.frame() %>% 
    rownames_to_column(var = "sample")
  samples_meta <- inner_join(samples_meta, pc.df, by = c( "Sample_ID" = "sample"))
  meta <- samples_meta %>% 
    dplyr::select( -Clone, -Species, -Tissue_type,-Group, -Group_2,-Replicate_2)
  
  #column names by variable type
  facCols <- meta %>% 
    dplyr::select_if(is.factor) %>%
    colnames()

  pcCols <- meta %>%
    dplyr::select(starts_with("PC")) %>%
    colnames()

  #factor correlations
  facCor.df <- expand.grid(pcCols, facCols) 

  rsquared <- facCor.df %>%
    apply(1, function(x) reformulate(x[2], x[1])) %>%
    lapply(., lm, data = meta) %>%
    map(summary) %>%
    map_dbl("r.squared")

  facCor.df$corr <- sqrt(rsquared)

  facCor.df <- facCor.df %>%
    dplyr::rename(PC = Var1, covariate = Var2) %>%
    mutate(type = "lm")

  #numeric correlations
  numCor.df <- meta %>%
    dplyr::select_if(is.numeric) %>%
    correlate(method = "kendall") %>%
    focus(-matches("^PC")) %>%
    gather(variable, corr, 2:4) %>%
    mutate(type = "kendall") %>%
    dplyr::rename(PC = term, covariate = variable)

   #combine
  pcaBar <- bind_rows(numCor.df, facCor.df)

  #filter sample and sex
  #pcaBar <- pcaBar %>%
   # filter( ! (covariate %in% c("sample", "sex")))

  #add percent variation
  pcs <- paste("PC", 1:6, sep = "")
  percentVar <- percentVar[1:6]
  pvar <- data.frame( PC = pcs, perVar = paste(pcs, " (", sprintf("%.2f", percentVar * 100), "%)", sep = ""))
  pcaBar <- inner_join(pcaBar, pvar)

  #arrange
  pcaBar <- pcaBar %>%
    group_by(PC) %>%
    arrange(corr) %>%
    unite("pcvar", PC, covariate, sep = "_", remove = F) %>%
    data.frame() %>%
    mutate(pcvar = factor(pcvar))

```
 

### PCA correlation bar plot

 
```{r, fig.height= 5, fig.width=9 }
 # PCA correlation barplot
  pcaBar %>%
    group_by(PC) %>%
    ggplot(aes(x = pcvar, y = corr)) +
    geom_col(aes(fill = type)) +
    coord_flip() + 
    facet_wrap( ~ perVar, scale = "free_y") +
    xlab("metadata") +
    ylab("correlation") +
    scale_x_discrete(breaks = pcaBar$pcvar, labels = pcaBar$covariate) +
    scale_y_continuous(limits = c(-1, 1)) +
    scale_fill_manual(values = c("darkorange", "dodgerblue")) 
```

### PCA correlation heatmap

```{r,fig.height=4, fig.width=6}
pcaBar %>%
    ggplot(aes(x = covariate, y = perVar, fill=corr)) +
    geom_tile() + scale_fill_distiller(direction=-1, palette = "RdYlBu", limits= c(min(pcaBar$corr),1))+theme(axis.text.x =  element_text(angle = 45, vjust = 1, hjust = 1)) + ylab("") + xlab("") +  labs(fill='correlation') 
#ggsave(filename="PCA_covariates_corrleation_heatmap.tiff", width=6,height = 4, units = "in", dpi = 300)
```


## PCA plot using Generalised PCA
+ takes raw count matrix and number of latent dimensions (2 dimensions)
+ We can see that without ComBat batch correction, the PCA is driven by batch seperation

```{r}
library(glmpca)
gpca <- glmpca(counts(dds), L=2)
gpca.dat <- gpca$factors
gpca.dat$Treatment <- dds$Treatment
gpca.dat$Treatment_time <- dds$Treatment_time
gpca.dat$Group_2 <- dds$Group_2
gpca.dat$Batch <- dds$Batch
gpca.dat$Sample_name <- dds$Sample_ID
```

```{r, fig.height=4, fig.width =7}
ggplot(gpca.dat, aes(x = dim1, y = dim2, color = Group_2, shape = Batch)) + geom_text_repel(aes(label=Sample_name), size=2.5) +
  geom_point(size =3) + ggtitle("glmpca - Generalized PCA") + coord_fixed()
```





# Differential Expression : WK2 Aggregate vs WK1 Aggregate

* design " ~ Batch + Group_2
* DEG log2FC threshold = 0.50 and FDR 5%

```{r}
## Week1: Treatments vs NSC
design(dds) <- formula(~ Batch + Group_2)
dds <- DESeq(dds, parallel = T,betaPrior = FALSE, test = "Wald") # calculate LFC shrink afterwards using lfcshrink
#res_diffage <- results(dds)
#res_diffage
#mcols(res_diffage)
resultsNames(dds) 
# Will have to relevel Group to "WK2_NSC" for Week2 compariosns
```




```{r}

res_WK2Agg_WK1Agg <- results(object=dds ,contrast = c("Group_2", "WK2_Aggregate","WK1_Aggregate") , lfcThreshold = 0.50, alpha=0.05)
 mcols(res_WK2Agg_WK1Agg)$description
 res_summary <- capture.output(summary(res_WK2Agg_WK1Agg))
 cat(res_summary, sep="  \n* ")
 
 # number of differentially expressed genes based on cut off
 
 num_DEG <- sum(res_WK2Agg_WK1Agg$padj < alpha_cutoff & abs(res_WK2Agg_WK1Agg$log2FoldChange) >= 0.50, na.rm=TRUE)
    cat("  \n* Genes with adjusted P-value not NA (universe of genes): ", sum(!is.na(res_WK2Agg_WK1Agg$padj)))
    cat("  \n* Differentially expressed genes with log2FC >= 0.50 & p.adjusted <0.05: ", num_DEG, "  \n")
resOrdered_WK2Agg_WK1Agg <- res_WK2Agg_WK1Agg[order(res_WK2Agg_WK1Agg$padj),]
resOrdered_WK2Agg_WK1Agg<- as.data.frame(resOrdered_WK2Agg_WK1Agg )
#write.table(as.data.frame(resOrdered_WK1_PD_NSC), file = paste0("deseq2_results_","WK1_PD_vs._NSC",".txt"), sep="\t", quote=F)
```

## MA-plot

```{r}
res_WK2Agg_WK1Agg_LFCshrink <- lfcShrink(dds = dds ,contrast = c("Group_2", "WK2_Aggregate","WK1_Aggregate") ,type="ashr")
DESeq2::plotMA(res_WK2Agg_WK1Agg_LFCshrink, ylim = c(-20,20))
resOrdered_WK2Agg_WK1Agg_LFCshrink <- res_WK2Agg_WK1Agg_LFCshrink[order(res_WK2Agg_WK1Agg_LFCshrink$padj),]
resOrdered_WK2Agg_WK1Agg_LFCshrink  <- as.data.frame(resOrdered_WK2Agg_WK1Agg_LFCshrink )
```

## Dispersion plot

```{r, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
plotDispEsts(dds)
```


## Table of DEG

```{r}
top_genes <- 20

 #prnt table of up and down regulated genes from DEG
    
res_print_WK2Agg_WK1Agg <- print_DESeq_table(resOrdered_WK2Agg_WK1Agg_LFCshrink, t2g_info = t2g_genes, alpha_level = alpha_cutoff,logfcthreshold = 0.50)


    
    plot_up_genes <- res_print_WK2Agg_WK1Agg[fc == "up", target_id][1:top_genes]
    plot_up_genes <- plot_up_genes[!(is.na(plot_up_genes))] # if there are not top_genes DEGs, NA values will be returned
    plot_down_genes <-res_print_WK2Agg_WK1Agg[fc == "down", target_id][1:top_genes]
    plot_down_genes <- plot_down_genes[!(is.na(plot_down_genes))]
  
    
    
  res_print_WK2Agg_WK1Agg <- res_print_WK2Agg_WK1Agg[, gene_type := NULL] ## only protein coding genes
   res_print_WK2Agg_WK1Agg <- res_print_WK2Agg_WK1Agg[, target_id := NULL] ## remove "symbol - ensembl_ID"
    
    setnames(res_print_WK2Agg_WK1Agg, "desc", "___________long_gene_description___________")
   res_print_WK2Agg_WK1Agg <- res_print_WK2Agg_WK1Agg %>% drop_na()
```



```{r, fig.height=6}
res_print_WK2Agg_WK1Agg %>% DT::datatable(caption=" WK2 Aggregate vs WK1 Aggregate", escape=F, extensions = 'Buttons', options = list(dom = 'Blfrtip', buttons = list('colvis', list(extend = 'copy', exportOptions = list(columns=':visible')), list(extend = 'csv', exportOptions = list(columns=':visible')), list(extend = 'excel', exportOptions = list(columns=':visible')))))
```


## Count Plots of Top genes


+ plot normalised counts for DEG for different groups

```{r, echo=F}
my_plot_counts <- function(obj, plot_genes=NULL, intgroup_vec=c("Group_2", "Replicate", "Treatment"), t2g_info=NULL, n_ncol=4, n_nrow =6, title=NULL){

  # collect data for each gene
  plot_data_all <- as.data.table(plotCounts(obj, gene = plot_genes[1], intgroup_vec, returnData=TRUE,transform = F, replaced = T))
  plot_data_all[, gene := plot_genes[1]]
  plot_data_all[, gene_idx := formatC(1,width=2,flag='0')]
  
  if (length(plot_genes) >= 2){
    for (i in 2:length(plot_genes)){
      
      plot_data <- as.data.table(plotCounts(obj, gene = plot_genes[i], intgroup_vec, returnData=TRUE,transform = F))
      plot_data[, gene := plot_genes[i]]
      plot_data[, gene_idx := formatC(i,width=2,flag='0')]
      plot_data_all <- rbind(plot_data_all, plot_data)
    }
  }
  
  plot_data_all <- merge(plot_data_all, t2g_info[, .(gene, ext_gene)], by.x="gene", by.y="gene")
  # plot_data_all[, gene_print := paste0(gene_idx, "  ", gene, "  ", ext_gene)]
  # plot_data_all[, gene_print := paste0(gene_idx, "  ", gene)]
  plot_data_all[, gene_print := paste0(gene_idx, "  ", ext_gene)] ## use only gene symbol as facet title
  plot_data_all <- plot_data_all %>% filter(Group_2 %in% c("WK1_Aggregate","WK2_Aggregate"))
  
  
  p <- ggplot(data = plot_data_all, aes(x=Group_2, y=log2(count+1), colour=Group_2, shape=Treatment))
  p <- p + geom_violin(aes(group=Group_2), alpha = 0, colour = "gray60", scale="width")
  ## p <- p + ggbeeswarm::geom_quasirandom(alpha = 0.6, size = 3, groupOnX = TRUE)
  p <- p + geom_point(position = position_jitterdodge(), size=5, alpha=0.6)
  p <- p + xlab(NULL)
  p <- p + facet_wrap(~gene_print, ncol=n_ncol, scales="free_y",nrow = n_nrow)
  p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
  p <- p + ylab("log2(normalised count + 1)") + theme(legend.position="top")
  p <- p + theme(axis.text.x=element_text(angle=90, hjust=1, size=10)) + theme(axis.text.y = element_text(size=8))
  p <- p + ggtitle(title)
  p
}

```


```{r, echo=FALSE, fig.height=10, fig.width=10}
p <- my_plot_counts(dds, plot_genes = plot_up_genes,title="upregulated genes in WK2 Agg vs WK1 Agg", t2g_info = t2g_genes, n_ncol = 5)
p
```

```{r, echo=FALSE, fig.height=9, fig.width=10}
my_plot_counts(dds, plot_genes = plot_down_genes,title="downregulated genes in WK2: Agg vs WK1:Agg", t2g_info = t2g_genes, n_ncol=5)
```

*  PD genes that are significant

```{r,echo=FALSE, fig.height=4, fig.width=9}
control_genes <- c("OPA1 - ENSG00000198836","MFN1 - ENSG00000171109","TOMM20 - ENSG00000173726","DNM1L - ENSG00000087470","TFAM - ENSG00000108064","NRF1 - ENSG00000106459","NFE2L2 - ENSG00000116044","MTOR - ENSG00000198793","HIF1A - ENSG00000100644","ARNT - ENSG00000143437","SNCA - ENSG00000145335","PARK7 - ENSG00000116288","OMA1 - ENSG00000162600","MFN1 - ENSG00000171109")

#t2g_genes_control <- t2g_genes %>% filter(gene %in% control_genes) %>% select(gene)
control_genes_sig <- resOrdered_WK2Agg_WK1Agg_LFCshrink %>% filter(rownames(.) %in% control_genes & padj<0.05 )
my_plot_counts(dds, plot_genes = rownames(control_genes_sig),title="interesting significant PD genes", t2g_info = t2g_genes)
#PGC-1alpha = ENSG00000109819
# OMA1 - ENSG00000162600
# OPA1 - ENSG00000198836
# MFN1 - ENSG00000171109
# TOM20 - ENSG00000173726
# DNM1L - ENSG00000087470
# TFAM - ENSG00000108064
# NRF1 - ENSG00000106459
# NFE2L2 -  ENSG00000116044
# TFEB - ENSG00000112561
# MTOR - ENSG00000198793
# HIF1a - ENSG00000100644
# HIF1b -  ENSG00000143437
#SNCA - ENSG00000145335
# PARK7 - ENSG00000116288
```

### PD GWAS genes UP (NALLS 2019 & Chang 2017) 



```{r, eval=T}
Nalls_pd_genes <- read.table(file= "./PD_genes_Nalls_2019.txt", sep="\t", header=T)
Nalls_pd_genes_ens <- merge(Nalls_pd_genes, t2g_genes[,c(4,7,9)],by.x ="Gene", by.y="ext_gene")
Nalls_pd_genes_unique <- unique(Nalls_pd_genes_ens$gene)

Chang_2017 <- read.table(file="./Chang_2017_PD_riskgenes.txt", sep="\t",header=T)
Chang_2017_ens <- merge(Chang_2017, t2g_genes[,c(4,7,9)],by.x ="Gene_symbol", by.y="ext_gene")
Chang_2017_unique <- unique(Chang_2017_ens$gene)

PD_risk_genes <- unique(c(Nalls_pd_genes_unique, Chang_2017_unique))



```

```{r}
PD_risk_genes_ens <- unique(c(Nalls_pd_genes_ens$ens_gene, Chang_2017_ens$ens_gene))
```





```{r, fig.height =5, fig.widht=10}
pdgwas_genes_sig <- resOrdered_WK2Agg_WK1Agg_LFCshrink %>% filter(rownames(.) %in% PD_risk_genes & padj<0.05 & log2FoldChange >0.5 )
my_plot_counts(dds, plot_genes = rownames(pdgwas_genes_sig),title=" GWAS PD genes UP at 5% FDR & LogFC > 0.5", t2g_info = t2g_genes, n_ncol=4)
```


### PD GWAS genes Down (NALLS 2019 & Chang 2017) 


```{r, fig.height =8, fig.width=10}
pdgwas_genes_sig <- resOrdered_WK2Agg_WK1Agg_LFCshrink %>% filter(rownames(.) %in% PD_risk_genes & padj<0.05 & log2FoldChange < -0.5 )
my_plot_counts(dds, plot_genes = rownames(pdgwas_genes_sig),title=" GWAS PD genes Down at 5% FDR and LogFC < -0.5", t2g_info = t2g_genes, n_ncol=4)
```




```{r,echo=FALSE}

# Get ENSEMBLE IDS

resOrdered_WK2Agg_WK1Agg_LFCshrink$gene <- rownames(resOrdered_WK2Agg_WK1Agg_LFCshrink)
resOrdered_WK2Agg_WK1Agg_LFCshrink_ens <- merge(resOrdered_WK2Agg_WK1Agg_LFCshrink, t2g_genes, by.all ="gene")
rownames(resOrdered_WK2Agg_WK1Agg_LFCshrink_ens) <- resOrdered_WK2Agg_WK1Agg_LFCshrink_ens$ens_gene
rm(resOrdered_WK2Agg_WK1Agg_LFCshrink)
resOrdered_WK2Agg_WK1Agg_LFCshrink_ens <- resOrdered_WK2Agg_WK1Agg_LFCshrink_ens[,c(1:7,11)]

# get rid of NAs for clusterprofiler
#library(tidyr)
resOrdered_WK2Agg_WK1Agg_LFCshrink_ens <- resOrdered_WK2Agg_WK1Agg_LFCshrink_ens %>% drop_na()

# map ids using annotation db
library(org.Hs.eg.db)
library(AnnotationDbi)

resOrdered_WK2Agg_WK1Agg_LFCshrink_ens$entrez <- mapIds(org.Hs.eg.db, keys= rownames(resOrdered_WK2Agg_WK1Agg_LFCshrink_ens), column = "ENTREZID", keytype = "ENSEMBL", multiVals = "first")
resOrdered_WK2Agg_WK1Agg_LFCshrink_ens$symbol <- mapIds(org.Hs.eg.db, keys= rownames(resOrdered_WK2Agg_WK1Agg_LFCshrink_ens), column = "SYMBOL", keytype = "ENSEMBL", multiVals = "first")
write.table(resOrdered_WK2Agg_WK1Agg_LFCshrink_ens, file="deseq2_results_Jan_Jun21_WK2_Agg_vs WK1_Agg_v2.txt", sep="\t", quote=F)


```




##  Overlap of DEG : a-synuclein interacting proteins & PD GWAS genes



 59  a-synuclein interacting proteins based on mass spec overlap with upregulated genes 

 57 a-synuclein interacting proteins based on mass spec overlap with downregulated genes 


```{r}
async_int_proteins <- read.table("../../Protein_data/proteins_interacting_with_alpha_synuclein.txt", sep="\t", header=F)
async_int_proteins_ens <- merge(async_int_proteins, t2g_genes[,c(4,7,9)],by.x ="V1", by.y="ext_gene")
async_int_proteins_ens_v <- async_int_proteins_ens$ens_gene
```


```{r, echo=FALSE, eval=T}
  
  d <- "Overlap of WK2 Agg vs WK1 Agg DEG with PD related genes"
res_print_WK2Agg_WK1Agg <- as.data.frame(res_print_WK2Agg_WK1Agg)
rownames(res_print_WK2Agg_WK1Agg) <- res_print_WK2Agg_WK1Agg$ens_gene



  ## Venn Diagram: DEGs for all 3 pairwise comparisons
  sig_Agg_up <- unique(rownames(res_print_WK2Agg_WK1Agg[res_print_WK2Agg_WK1Agg$fc == "up", ]))
  sig_Agg_down <- unique(rownames(res_print_WK2Agg_WK1Agg[res_print_WK2Agg_WK1Agg$fc == "down", ]))
  
 
 # tiff(filename = "./DEG_genes_WK1_WK2_aggregate_vs_NSC_Venn_diagram.tiff", height = 4, width=6, units = "in", res=300)
 
 # cairo_ps("./DEG_genes_Venn_diagram.eps", height = 4, width = 5, onefile = F)
   venn.plot <- venn.diagram(x=list(S1=as.matrix(sig_Agg_up), S2=as.matrix(sig_Agg_down), S3=as.matrix(PD_risk_genes_ens), S4=as.matrix(async_int_proteins_ens_v)), fill = c("red", "cyan3", "green3","yellow"), alpha=c(0.5, 0.5, 0.5,0.5), cex=0.6, cat.cex=0.55, fontfamily="sans", cat.fontfamily="sans", main.fontfamily = "sans", cat.dist=c(0.2,0.2,0.1,0.1),  filename=NULL, euler.d=F, scaled=F, print.mode=c("percent", "raw"), sigdigs = 2, category.names=paste0(c("WK2 Agg UP", "WK2 Agg Down","PD GWAS genes","a-synuclein interacting proteins"), "\n", c(length(sig_Agg_up), length(sig_Agg_down), length(PD_risk_genes_ens), length(async_int_proteins_ens_v))), main = d, main.cex = 0.7)
  
  grid.newpage()
  grid.draw(venn.plot)
  #dev.off()

```

 Test significance of overlap between the various sets by using fishers exact

 heatmap showing Odds ratio as colours and pvalue significance as *  at 5% FDR or NS

 OR > 1 = strong association between categories 

 Overlap between alpha-synuclein interacting proteins and Upregulated proteins in WK2 AGG vs WK1 AGG  is NOT significant

```{r, warning=FALSE}
library(GeneOverlap)
deg_list <- list("WK2_Agg_vs_WK1_Agg_UP" = sig_Agg_up , "WK2_Agg_vs_WK1_Agg_DN" = sig_Agg_down)
pd_gene_l <- list("PD_GWAS_genes" = PD_risk_genes_ens, "a-sync_int_proteins" = async_int_proteins_ens_v)
gs.RNAseq =  as.numeric(length(rownames(resOrdered_WK2Agg_WK1Agg_LFCshrink_ens)))

go.obj <- newGOM(gsetA = deg_list, gsetB =   pd_gene_l, genome.size = gs.RNAseq)
#go.obj

```

```{r}

gom_results_pval <- getMatrix(go.obj, name = "pval")
gom_results_pval_log10 <- -log10(gom_results_pval)
gom_results_num <- getMatrix(go.obj, name="intersection")
gom_results_or <- getMatrix(go.obj, name="odds.ratio")
```



```{r}
library(pheatmap)
pheatmap::pheatmap(mat = as.matrix(gom_results_or),display_numbers = as.matrix(ifelse(gom_results_pval < 0.05, "*", "NS"), nrow(gom_results_pval)), cluster_rows = F,cluster_cols = F,fontsize_number = 14 , color = colorRampPalette((brewer.pal(9,"Purples")) )(255))
```



## Volcano plot 

```{r, fig.height=5, fig.width=7}
library(EnhancedVolcano)
 Vol <- EnhancedVolcano(resOrdered_WK2Agg_WK1Agg_LFCshrink_ens,
    lab = resOrdered_WK2Agg_WK1Agg_LFCshrink_ens$symbol,
    x = 'log2FoldChange',
    y = 'pvalue', subtitle = "", title = "WK2:Agg vs WK1:Agg", xlim = c(-29,25), labSize =3, FCcutoff = 1.0, axisLabSize = 6, titleLabSize = 8, legendLabSize = 6, pCutoff = 0.05,pCutoffCol = 'padj', drawConnectors = F, captionLabSize = 6,
    widthConnectors = 0.2, colConnectors = 'grey30',caption = "Log2FC cutoff = 1.0; p-value cutoff= 0.05" )
 #Vol <-   Vol +  ggplot2::coord_cartesian(xlim=c(-10, 8))  + ggplot2::scale_x_continuous(breaks=seq(-10,8, 2))
 Vol
```
## over-representation pathway analyses



```{r, eval=T}

 
 # Done all DEG with p.adj <0.05 , no logFC threshold applied

library(clusterProfiler)

resOrdered_WK2Agg_WK1Agg_LFCshrink_ens_sig <- resOrdered_WK2Agg_WK1Agg_LFCshrink_ens %>% filter(padj < 0.05 & abs(log2FoldChange) >= 0.5) 

#geneChangeList <- resOrdered_Parent_stim_control_LFCshrink_ens_sig$log2FoldChange
geneChangeList <- unique(rownames(resOrdered_WK2Agg_WK1Agg_LFCshrink_ens_sig))
#geneChangeList <- sort(geneChangeList, decreasing=TRUE)
#desiredGeneChangeList <- names(geneChangeList)[abs(geneChangeList) >1] 
 all_genes <- as.character(unique(rownames(resOrdered_WK2Agg_WK1Agg_LFCshrink_ens)))

enrichGOResult_1 <- enrichGO(gene = geneChangeList, OrgDb = org.Hs.eg.db, keyType = 'ENSEMBL', ont = "BP", pAdjustMethod = "BH", universe=all_genes, readable = T)
enrichGOResult_1_s <- simplify(enrichGOResult_1, cutoff=0.8)
```


### GO BP over-representation test

+ GO Biological Process
+ genes used : p.adj < 0.05 and log2FC >= 0.5

```{r, eval=T}

scorePlot <- RScorePlot_v2(enrichGOResult_1, resOrdered_WK2Agg_WK1Agg_LFCshrink_ens, showCategory = 25, textSize = 9, title = "" ) + theme(title = element_text(size=8), axis.text = element_text(size=8)) + ggtitle("GO BP terms for WK2:Agg vs WK1:Agg")
plot(scorePlot)
```

### Reactome Pathways

```{r, eval=T}

library(ReactomePA)
# only takes entrez id
geneChangeList <- unique(resOrdered_WK2Agg_WK1Agg_LFCshrink_ens_sig$entrez)
#geneChangeList <- sort(geneChangeList, decreasing=TRUE)
#desiredGeneChangeList <- names(geneChangeList)[abs(geneChangeList) >1] 
 all_genes <- as.character(unique(resOrdered_WK2Agg_WK1Agg_LFCshrink_ens$entrez))
enrich_Reactome <-  enrichPathway(gene = geneChangeList, pAdjustMethod = "BH", universe=all_genes, readable = T, organism = "human")
scorePlot <- RScorePlot_v2(enrich_Reactome, resOrdered_WK2Agg_WK1Agg_LFCshrink_ens, showCategory = 25, textSize = 9, title = "" ) + theme(title = element_text(size=8)) +ggtitle("Reactome terms for WK2:Agg vs WK1:Agg")
plot(scorePlot)
```


```{r, echo=FALSE, message=FALSE, warning=FALSE}
# from https://stephenturner.github.io/deseq-to-fgsea/
# symbol here comes from map ids. it is possible that 2 ensgs map to the same symbol! this creates duplicates in the stat data frame and is removed using distinct
library(fgsea)
gsea_res_WK2Agg_WK1Agg <- resOrdered_WK2Agg_WK1Agg_LFCshrink_ens %>% dplyr::select(symbol,log2FoldChange) %>% na.omit() %>% distinct() %>% group_by(symbol) %>% summarize(log2FoldChange=mean(log2FoldChange))
# dim(gsea_res)
# head(gsea_res)

# fast Gene Set Enrichment Analysis
ranks<- deframe(gsea_res_WK2Agg_WK1Agg)

```

## GSEA Reactome Pathways

```{r}
pathways.reactome <- gmtPathways("../genesets/c2.cp.reactome.v7.4.symbols.gmt")
fgsea_reactome <- fgseaMultilevel(pathways=pathways.reactome, stats=ranks, nPermSimple = 20000, maxSize = 500, minSize = 30)
# convert to tibble, sort by NES and select columns
fgsea_reactome_tidy <- fgsea_reactome %>% as_tibble() %>% arrange(padj) %>% dplyr::select(-pval, -ES)
# Show in a nice table:
fgsea_reactome_tidy %>% DT::datatable()
```





### Top 15 up and down regulated Reactome pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowd pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_reactome_up <- fgsea_reactome[ES > 0][size < 300][order(padj,-NES),pathway][1:15]
top_reactome_dn <- fgsea_reactome[ES < 0][size < 300][order(padj,NES),pathway][1:15]
top_reactome <- c(top_reactome_up, rev(top_reactome_dn))
plotGseaTable(pathways.reactome[top_reactome], ranks, fgsea_reactome, gseaParam = 0.5)
fgsea_reactome_tidy_top <- fgsea_reactome_tidy %>% filter(pathway %in% top_reactome)
```


```{r, fig.width=12}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_reactome_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down Reactome pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=8))+theme(plot.title = element_text(size=7))
p1

```

### Enrichments plots for top Reactome hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.reactome[[top_reactome_up[i]]], ranks) + labs(title=top_reactome_up[i]))
}
```


### Leading Edge heatmaps for top Reactome hits

Heatmap of row normalised rld regularised leg transformed size factor normalised read counts

```{r, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
norm_counts <- as.data.frame(assay(rld))
norm_counts <- norm_counts %>% rownames_to_column(var="gene")
norm_counts_Ens <- merge(norm_counts, t2g_genes[,c(4,9)], by.all="gene")
ens2symbol <- AnnotationDbi::select(org.Hs.eg.db, key=norm_counts_Ens$ens_gene, columns="SYMBOL", keytype="ENSEMBL", multiVals="first") %>% distinct()
ens2symbol$gene <- paste(ens2symbol$ENSEMBL,"-",ens2symbol$SYMBOL,sep="")
ens2symbol <- as_tibble(ens2symbol)
norm_counts_Ens <- norm_counts_Ens %>% column_to_rownames(var= "ens_gene") %>% dplyr::select(-gene)
norm_counts_Ens_Agg <- norm_counts_Ens %>%  dplyr::select(!ends_with("NSC"))

```

```{r, eval=T, fig.height=8, fig.width=10}
top_reactome_up_full <- fgsea_reactome[ES > 0][size < 250][order(padj,-NES),][1:5]

for (i in 1:5) {
  # Full pathway
  # print(pathways.reactome[[top_reactome_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_reactome_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens_Agg[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens_Agg)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  pheatmap(gene_counts_rownorm, col = colors, main=top_reactome_up_full[i,pathway])
 }
  
```


## GSEA KEGG Pathways

```{r}
pathways.kegg <- gmtPathways("../genesets/c2.cp.kegg.v7.4.symbols.gmt")
fgsea_kegg <- fgseaMultilevel(pathways=pathways.kegg, stats=ranks, nPermSimple = 10000, maxSize = 500, minSize = 30)
# convert to tibble, sort by NES and select columns
fgsea_kegg_tidy <- fgsea_kegg %>% as_tibble() %>% arrange(padj) %>% dplyr::select(-pval, -ES)
# Show in a nice table:
fgsea_kegg_tidy %>% DT::datatable()
```




### Top 15 up and down regulated KEGG pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowd pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_kegg_up <- fgsea_kegg[ES > 0][size < 250][order(padj,-NES),pathway][1:15]
top_kegg_dn <- fgsea_kegg[ES < 0][size < 250][order(padj,NES),pathway][1:15]
top_kegg <- c(top_kegg_up, rev(top_kegg_dn))
plotGseaTable(pathways.kegg[top_kegg], ranks, fgsea_kegg, gseaParam = 0.5)
fgsea_kegg_tidy_top <- fgsea_kegg_tidy %>% filter(pathway %in% top_kegg)
```


```{r, fig.width=10}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_kegg_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down KEGG pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=8))+theme(plot.title = element_text(size=7), legend.title = element_text(size=10))
p1

```

### Enrichments plots for top KEGG hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.kegg[[top_kegg_up[i]]], ranks) + labs(title=top_kegg_up[i]))
}
```




### Leading Edge heatmaps for top KEGG hits

Heatmap of row noemalised rld regularised leg transformed size factor normalised read counts



```{r, eval=T, fig.height=9}
top_kegg_up_full <- fgsea_kegg[ES > 0][size < 250][order(padj,-NES),][1:6]

for (i in 1:6) {
  # Full pathway
   #print(pathways.kegg[[top_kegg_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_kegg_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens_Agg[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens_Agg)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  pheatmap(gene_counts_rownorm, col = colors, main=top_kegg_up_full[i,pathway])
 }
  
```




## GSEA GO BP Terms

```{r}
pathways.gobp <- gmtPathways("../genesets/c5.go.bp.v7.4.symbols.gmt")
fgsea_gobp <- fgseaMultilevel(pathways=pathways.gobp, stats=ranks, nPermSimple = 10000, maxSize = 500, minSize = 30)
# convert to tibble, sort by NES and select columns
fgsea_gobp_tidy <- fgsea_gobp %>% as_tibble() %>% arrange(padj) %>% dplyr::select(-pval, -ES)
# Show in a nice table:
fgsea_gobp_tidy %>% DT::datatable()
```





### Top 15 up and down regulated GOBP pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowed pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_gobp_up <- fgsea_gobp[ES > 0][size < 250][order(padj,-NES),pathway][1:15]
top_gobp_dn <- fgsea_gobp[ES < 0][size < 250][order(padj,NES),pathway][1:15]
top_gobp <- c(top_gobp_up, rev(top_gobp_dn))
plotGseaTable(pathways.gobp[top_gobp], ranks, fgsea_gobp, gseaParam = 0.5)
fgsea_gobp_tidy_top <- fgsea_gobp_tidy %>% filter(pathway %in% top_gobp)
```


```{r, fig.width=10}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_gobp_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down GO-BP pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=8))+theme(plot.title = element_text(size=7), legend.title = element_text(size=10))
p1

```

### Enrichments plots for top GOBP hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.gobp[[top_gobp_up[i]]], ranks) + labs(title=top_gobp_up[i]))
}
```




### Leading Edge heatmaps for top GOBP hits

Heatmap of row normalised rld regularised leg transformed size factor normalised read counts


```{r, eval=T, fig.height=10}
top_gobp_up_full <- fgsea_gobp[ES > 0][size < 250][order(padj,-NES),][1:5]

for (i in 1:5) {
  # Full pathway
  # print(pathways.gobp[[top_gobp_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_gobp_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens_Agg[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens_Agg)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  pheatmap(gene_counts_rownorm, col = colors, main=top_gobp_up_full[i,pathway])
 }
  
```


# Differential Expression : Week2 NSC vs Week1 NSC

 + Lfcthreshold = 0.50
 + 
 
```{r}

res_WK2NSC_WK1NSC <- results(object=dds ,contrast = c("Group_2", "WK2_NSC","WK1_NSC") , lfcThreshold = 0.50, alpha=0.05)
 mcols(res_WK2NSC_WK1NSC)
 res_summary <- capture.output(summary(res_WK2NSC_WK1NSC))
 cat(res_summary, sep="  \n* ")
 
 # number of differentially expressed genes based on cut off
 
 num_DEG <- sum(res_WK2NSC_WK1NSC$padj < alpha_cutoff & abs(res_WK2NSC_WK1NSC$log2FoldChange) >= 0.50, na.rm=TRUE)
    cat("  \n* Genes with adjusted P-value not NA (universe of genes): ", sum(!is.na(res_WK2NSC_WK1NSC$padj)))
    cat("  \n* Differentially expressed genes with log2fc >= 0.5 & p.adjusted <0.05: ", num_DEG, "  \n")
resOrdered_WK2NSC_WK1NSC <- res_WK2NSC_WK1NSC[order(res_WK2NSC_WK1NSC$padj),]
resOrdered_WK2NSC_WK1NSC <- as.data.frame(resOrdered_WK2NSC_WK1NSC )
#write.table(as.data.frame(resOrdered_WK1_PD_NSC), file = paste0("deseq2_results_","WK1_PD_vs._NSC",".txt"), sep="\t", quote=F)
```

## MA-plot

```{r}
res_WK2NSC_WK1NSC_LFCshrink <- lfcShrink(dds = dds ,contrast = c("Group_2", "WK2_NSC","WK1_NSC") ,type="ashr")
DESeq2::plotMA(res_WK2NSC_WK1NSC_LFCshrink, ylim = c(-20,20))
resOrdered_WK2NSC_WK1NSC_LFCshrink <- res_WK2NSC_WK1NSC_LFCshrink[order(res_WK2NSC_WK1NSC_LFCshrink$padj),]
resOrdered_WK2NSC_WK1NSC_LFCshrink  <- as.data.frame(resOrdered_WK2NSC_WK1NSC_LFCshrink )
```

## Dispersion plot

```{r, echo=FALSE, message=FALSE, warning=FALSE}
plotDispEsts(dds)
```


## Table of DEG

```{r}
top_genes <- 20

 #prnt table of up and down regulated genes from DEG
    
res_print_WK2NSC_WK1NSC <- print_DESeq_table(res_WK2NSC_WK1NSC_LFCshrink, t2g_info = t2g_genes, alpha_level = alpha_cutoff,logfcthreshold = 0.5)


    
    plot_up_genes <- res_print_WK2NSC_WK1NSC[fc == "up", target_id][1:top_genes]
    plot_up_genes <- plot_up_genes[!(is.na(plot_up_genes))] # if there are not top_genes DEGs, NA values will be returned
    plot_down_genes <- res_print_WK2NSC_WK1NSC[fc == "down", target_id][1:top_genes]
    plot_down_genes <- plot_down_genes[!(is.na(plot_down_genes))]
  
    
    
   res_print_WK2NSC_WK1NSC <-res_print_WK2NSC_WK1NSC[, gene_type := NULL] ## only protein coding genes
   res_print_WK2NSC_WK1NSC <- res_print_WK2NSC_WK1NSC[, target_id := NULL] ## remove "symbol - ensembl_ID"
    
    setnames(res_print_WK2NSC_WK1NSC, "desc", "___________long_gene_description___________")
   res_print_WK2NSC_WK1NSC <- res_print_WK2NSC_WK1NSC %>% drop_na()
```



```{r}
res_print_WK2NSC_WK1NSC %>% DT::datatable(caption=" Week2 NSC vs Week1 NSC", escape=F, extensions = 'Buttons', options = list(dom = 'Blfrtip', buttons = list('colvis', list(extend = 'copy', exportOptions = list(columns=':visible')), list(extend = 'csv', exportOptions = list(columns=':visible')), list(extend = 'excel', exportOptions = list(columns=':visible')))))
```

## Count Plots of Top genes


+ plot normalised counts for DEG for different groups

```{r, echo=F}
my_plot_counts <- function(obj, plot_genes=NULL, intgroup_vec=c("Group_2", "Batch"), t2g_info=NULL, n_ncol=4, n_nrow =6, title=NULL){

  # collect data for each gene
  plot_data_all <- as.data.table(plotCounts(obj, gene = plot_genes[1], intgroup_vec, returnData=TRUE,transform = F))
  plot_data_all[, gene := plot_genes[1]]
  plot_data_all[, gene_idx := formatC(1,width=2,flag='0')]
  
  if (length(plot_genes) >= 2){
    for (i in 2:length(plot_genes)){
      
      plot_data <- as.data.table(plotCounts(obj, gene = plot_genes[i], intgroup_vec, returnData=TRUE,transform = F))
      plot_data[, gene := plot_genes[i]]
      plot_data[, gene_idx := formatC(i,width=2,flag='0')]
      plot_data_all <- rbind(plot_data_all, plot_data)
    }
  }
  
  plot_data_all <- merge(plot_data_all, t2g_info[, .(gene, ext_gene)], by.x="gene", by.y="gene")
  # plot_data_all[, gene_print := paste0(gene_idx, "  ", gene, "  ", ext_gene)]
  # plot_data_all[, gene_print := paste0(gene_idx, "  ", gene)]
  plot_data_all[, gene_print := paste0(gene_idx, "  ", ext_gene)] ## use only gene symbol as facet title
  plot_data_all <- plot_data_all %>% filter(Group_2 %in% c("WK1_NSC","WK2_NSC"))
  p <- ggplot(data = plot_data_all, aes(x=Group_2, y=log2(count+1), colour=Group_2,shape=Batch))
  p <- p + geom_violin(aes(group=Group_2), alpha = 0, colour = "gray60", scale="width")
  ## p <- p + ggbeeswarm::geom_quasirandom(alpha = 0.6, size = 3, groupOnX = TRUE)
  p <- p + geom_point(position = position_jitterdodge(), size=5, alpha=0.6)
  p <- p + xlab(NULL)
  p <- p + facet_wrap(~gene_print, ncol=n_ncol, scales="free_y",nrow = n_nrow)
  p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
  p <- p + ylab("log2(normalised count + 1)") + theme(legend.position="top")
  p <- p + theme(axis.text.x=element_text(angle=90, hjust=1, size=10)) + theme(axis.text.y = element_text(size=8))
  p <- p + ggtitle(title)
  p
}

```


```{r, echo=FALSE, fig.height=9, fig.width=10}
my_plot_counts(dds, plot_genes = plot_up_genes,title="upregulated genes in WK2 NSC vs WK1 NSC", t2g_info = t2g_genes, n_ncol = 5)
```

```{r, echo=FALSE, fig.height=9, fig.width=10}
my_plot_counts(dds, plot_genes = plot_down_genes,title="downregulated genes in WK2 NSC vs WK1 NSC", t2g_info = t2g_genes, n_ncol = 5)
```

* plot interesting genes 

```{r,echo=FALSE, fig.height=4, fig.width=8, eval=T}
control_genes <- c("OPA1 - ENSG00000198836","MFN1 - ENSG00000171109","TOMM20 - ENSG00000173726","DNM1L - ENSG00000087470","TFAM - ENSG00000108064","NRF1 - ENSG00000106459","NFE2L2 - ENSG00000116044","MTOR - ENSG00000198793","HIF1A - ENSG00000100644","ARNT - ENSG00000143437","SNCA - ENSG00000145335","PARK7 - ENSG00000116288","OMA1 - ENSG00000162600","MFN1 - ENSG00000171109")

#t2g_genes_control <- t2g_genes %>% filter(gene %in% control_genes) %>% select(gene)
control_genes_sig <- resOrdered_WK2NSC_WK1NSC_LFCshrink %>% filter(rownames(.) %in% control_genes & padj<0.05 )
my_plot_counts(dds, plot_genes = rownames(control_genes_sig),title="interesting significant PD genes", t2g_info = t2g_genes)
#PGC-1alpha = ENSG00000109819
# OMA1 - ENSG00000162600
# OPA1 - ENSG00000198836
# Mitofusin - ENSG00000171109
# TOM20 - ENSG00000173726
# DNM1L - ENSG00000087470
# TFAM - ENSG00000108064
# NRF1 - ENSG00000106459
# NFE2L2 -  ENSG00000116044
# TFEB - ENSG00000112561
# MTOR - ENSG00000198793
# HIF1a - ENSG00000100644
# HIF1b -  ENSG00000143437
#SNCA - ENSG00000145335
# PARK7 - ENSG00000116288
```

### PD GWAS genes UP (NALLS 2019 & Chang 2017) 



```{r, fig.height =8, fig.widht=10}
pdgwas_genes_sig <- resOrdered_WK2NSC_WK1NSC_LFCshrink %>% filter(rownames(.) %in% PD_risk_genes & padj<0.05 & log2FoldChange >=0.5 )
my_plot_counts(dds, plot_genes = rownames(pdgwas_genes_sig),title=" GWAS PD genes UP at 5% FDR and 0.5 Log2FC", t2g_info = t2g_genes, n_ncol=4)
```


### PD GWAS genes Down (NALLS 2019 & Chang 2017) 


```{r, fig.height =8, fig.widht=10}
pdgwas_genes_sig <- resOrdered_WK2NSC_WK1NSC_LFCshrink %>% filter(rownames(.) %in% PD_risk_genes & padj<0.05 & log2FoldChange <= -0.5 )
my_plot_counts(dds, plot_genes = rownames(pdgwas_genes_sig),title=" GWAS PD genes Down at 5% FDR & 0.5 Log2FC", t2g_info = t2g_genes, n_ncol=5)
```



```{r,eval=FALSE}
### Plot SNCA counts in Week2 samples only
 plot_data_SNCA <- plotCounts(dds = dds, gene = "SNCA - ENSG00000145335", intgroup =c("Group2", "Stimulation","Treatment_time","Replicate","Treatment"), returnData=TRUE,transform = F)
plot_data_SNCA_wk2 <- plot_data_SNCA %>% filter(Treatment_time == "WK2")

 p <- ggplot(data = plot_data_SNCA_wk2, aes(x=Group2, y=log2(count+1), colour=Stimulation))
  p <- p + geom_violin(aes(group=Group2), alpha = 0, colour = "gray60", scale="width")
  ## p <- p + ggbeeswarm::geom_quasirandom(alpha = 0.6, size = 3, groupOnX = TRUE)
  p <- p + geom_point(position = position_jitterdodge(), size=5, alpha=0.6, aes(shape = Treatment))
  p <- p + xlab(NULL)
 # p <- p + facet_wrap(~gene_print, ncol=n_ncol, scales="free_y",nrow = n_nrow)
  p <- p + guides(colour = guide_legend(override.aes = list(alpha=1)))
  p <- p + ylab("log2(normalised count + 1)") + theme(legend.position="right")
  p <- p + theme(axis.text.x=element_text(angle=90, hjust=1, size=10)) + theme(axis.text.y = element_text(size=8))
  p <- p + ggtitle("SNCA-ENSG00000145335") 
  p
 # ggsave(filename = "RNASEQ_WK2_SNCA_normalised_counts_plot.pdf",width = 5, height = 5,units = "in", dpi = 300)
```





```{r,echo=FALSE}

# Get ENSEMBLE IDS

resOrdered_WK2NSC_WK1NSC_LFCshrink$gene <- rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink)
resOrdered_WK2NSC_WK1NSC_LFCshrink_ens <- merge(resOrdered_WK2NSC_WK1NSC_LFCshrink, t2g_genes, by.all ="gene")
rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens) <- resOrdered_WK2NSC_WK1NSC_LFCshrink_ens$ens_gene
rm(resOrdered_WK2NSC_WK1NSC)
resOrdered_WK2NSC_WK1NSC_LFCshrink_ens <- resOrdered_WK2NSC_WK1NSC_LFCshrink_ens[,c(1:7,11)]

# get rid of NAs for clusterprofiler
#library(tidyr)
resOrdered_WK2NSC_WK1NSC_LFCshrink_ens <- resOrdered_WK2NSC_WK1NSC_LFCshrink_ens%>% drop_na()

# map ids using annotation db
library(org.Hs.eg.db)
library(AnnotationDbi)

resOrdered_WK2NSC_WK1NSC_LFCshrink_ens$entrez <- mapIds(org.Hs.eg.db, keys= rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens), column = "ENTREZID", keytype = "ENSEMBL", multiVals = "first")
resOrdered_WK2NSC_WK1NSC_LFCshrink_ens$symbol <- mapIds(org.Hs.eg.db, keys= rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens), column = "SYMBOL", keytype = "ENSEMBL", multiVals = "first")
write.table(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens, file="deseq2_results_Jan_Jun_21_WK2_NSC_vsWK1_NSC_all_v2.txt", sep="\t", quote=F)


```

##  Overlap of DEG : a-synuclein interacting proteins & PD GWAS genes



 157  a-synuclein interacting proteins based on mass spec overlap with upregulated genes of which 1 are also a PD GWAS gene

 132 a-synuclein interacting proteins based on mass spec overlap with downregulated genes 




```{r, echo=FALSE, eval=T}
  
  d <- "Overlap of WK2 NSC vs WK1 NSC DEG with PD related genes"
res_print_WK2NSC_WK1NSC <- as.data.frame(res_print_WK2NSC_WK1NSC)
rownames(res_print_WK2NSC_WK1NSC) <- res_print_WK2NSC_WK1NSC$ens_gene



  ## Venn Diagram: DEGs for all 3 pairwise comparisons
  sig_NSC_up <- unique(rownames(res_print_WK2NSC_WK1NSC[res_print_WK2NSC_WK1NSC$fc == "up", ]))
  sig_NSC_down <- unique(rownames(res_print_WK2NSC_WK1NSC[res_print_WK2NSC_WK1NSC$fc == "down", ]))
  
 
 # tiff(filename = "./DEG_genes_WK1_WK2_aggregate_vs_NSC_Venn_diagram.tiff", height = 4, width=6, units = "in", res=300)
 
 # cairo_ps("./DEG_genes_Venn_diagram.eps", height = 4, width = 5, onefile = F)
   venn.plot <- venn.diagram(x=list(S1=as.matrix(sig_NSC_up), S2=as.matrix(sig_NSC_down), S3=as.matrix(PD_risk_genes_ens), S4=as.matrix(async_int_proteins_ens_v)), fill = c("red", "cyan3", "green3","yellow"), alpha=c(0.5, 0.5, 0.5,0.5), cex=0.6, cat.cex=0.55, fontfamily="sans", cat.fontfamily="sans", main.fontfamily = "sans", cat.dist=c(0.2,0.2,0.1,0.1),  filename=NULL, euler.d=F, scaled=F, print.mode=c("percent", "raw"), sigdigs = 2, category.names=paste0(c("WK2 NSC UP", "WK2 NSC Down","PD GWAS genes","a-synuclein interacting proteins"), "\n", c(length(sig_NSC_up), length(sig_NSC_down), length(PD_risk_genes_ens), length(async_int_proteins_ens_v))), main = d, main.cex = 0.7)
  
  grid.newpage()
  grid.draw(venn.plot)
  #dev.off()

```

 Test significance of overlap between the various sets by using fishers exact

 heatmap showing Odds ratio as colours and pvalue signficiance at FDR 5% as * or NS

 OR > 1 = strong association between categories 

 Overlap between alpha-synuclein interacting proteins and Upregulated proteins in WK2 NSC vs WK1 NSC  is NOT significant

```{r, warning=FALSE}
deg_list <- list("WK2_NSC_vs_WK1_NSC_UP" = sig_NSC_up , "WK2_NSC_vs_WK1_NSC_DN" = sig_NSC_down)
pd_gene_l <- list("PD_GWAS_genes" = PD_risk_genes_ens, "a-sync_int_proteins" = async_int_proteins_ens_v)
gs.RNAseq =  as.numeric(length(rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens)))

go.obj <- newGOM(gsetA = deg_list, gsetB =   pd_gene_l, genome.size = gs.RNAseq)
#go.obj

```

```{r}

gom_results_pval <- getMatrix(go.obj, name = "pval")
gom_results_pval_log10 <- -log10(gom_results_pval)
gom_results_num <- getMatrix(go.obj, name="intersection")
gom_results_or <- getMatrix(go.obj, name="odds.ratio")
```



```{r}
library(pheatmap)
pheatmap::pheatmap(mat = as.matrix(gom_results_or),display_numbers = as.matrix(ifelse(gom_results_pval < 0.05, "*", "NS"), nrow(gom_results_pval)), cluster_rows = F,cluster_cols = F,fontsize_number = 14 , color = colorRampPalette((brewer.pal(9,"Purples")) )(255))
```








## Volcano plot 

```{r, fig.height=6, fig.width=8}
library(EnhancedVolcano)
 Vol <- EnhancedVolcano(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens,
    lab = resOrdered_WK2NSC_WK1NSC_LFCshrink_ens$symbol,
    x = 'log2FoldChange',
    y = 'pvalue', subtitle = "", title = "WK2:NSC vs WK1:NSC", xlim = c(-26,26), labSize =3, FCcutoff = 1.5, axisLabSize = 6, titleLabSize = 8, legendLabSize = 6, pCutoff = 0.05, pCutoffCol = "padj",   drawConnectors = F, captionLabSize = 6,
    widthConnectors = 0.2, colConnectors = 'grey30',caption = "Log2FC cutoff = 1.5; p-value cutoff=0.05" )
# Vol <-   Vol +  ggplot2::coord_cartesian(xlim=c(-28, 26))  + ggplot2::scale_x_continuous(breaks=seq(-28,23, 5))
 Vol
```

## Gene Ontology Over-representation analysis


```{r, eval=T}

 
 # Done all DEG with p.adj <0.05 , no logFC threshold applied

library(clusterProfiler)

resOrdered_WK2NSC_WK1NSC_LFCshrink_ens_sig <- resOrdered_WK2NSC_WK1NSC_LFCshrink_ens %>% filter(padj < 0.05 & abs(log2FoldChange) >= 0.50) 

#geneChangeList <- resOrdered_Parent_stim_control_LFCshrink_ens_sig$log2FoldChange
geneChangeList <- unique(rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens_sig))
#geneChangeList <- sort(geneChangeList, decreasing=TRUE)
#desiredGeneChangeList <- names(geneChangeList)[abs(geneChangeList) >1] 
 all_genes <- as.character(unique(rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens)))

enrichGOResult_2 <- enrichGO(gene = geneChangeList, OrgDb = org.Hs.eg.db, keyType = 'ENSEMBL', ont = "BP", pAdjustMethod = "BH", universe=all_genes, readable = T)
enrichGOResult_2_s <- simplify(enrichGOResult_2, cutoff=0.8)
```


### GO BP over-representation test


```{r, eval=T}

scorePlot <- RScorePlot_v2(enrichGOResult_2, resOrdered_WK2NSC_WK1NSC_LFCshrink_ens, showCategory = 25, textSize = 9, title = "" ) + theme(title = element_text(size=8))+ggtitle("GO BP terms for WK2:NSC vs WK1:NSC")
plot(scorePlot)
```

### Reactome Pathways


```{r, eval=T}

library(ReactomePA)
# only takes entrez id
geneChangeList <- unique(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens_sig$entrez)
#geneChangeList <- sort(geneChangeList, decreasing=TRUE)
#desiredGeneChangeList <- names(geneChangeList)[abs(geneChangeList) >1] 
 all_genes <- as.character(unique(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens$entrez))
enrich_Reactome_2 <-  enrichPathway(gene = geneChangeList, pAdjustMethod = "BH", universe=all_genes, readable = T, organism = "human")
scorePlot <- RScorePlot_v2(enrich_Reactome, resOrdered_WK2NSC_WK1NSC_LFCshrink_ens, showCategory = 25, textSize = 9, title = "" ) + theme(title = element_text(size=8))+ ggtitle("Reactome terms for WK2:NSC vs WK1:NSC")
plot(scorePlot)
```

```{r,echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE}
library(fgsea)
gsea_res_WK2NSC_WK1NSC <- resOrdered_WK2NSC_WK1NSC_LFCshrink_ens %>% dplyr::select(symbol,log2FoldChange) %>% na.omit() %>% distinct() %>% group_by(symbol) %>% summarize(log2FoldChange=mean(log2FoldChange))
# dim(gsea_res)
# head(gsea_res)

# fast Gene Set Enrichment Analysis
ranks <- deframe(gsea_res_WK2NSC_WK1NSC)

```

## GSEA Reactome Pathways

```{r}
#pathways.reactome <- gmtPathways("./genesets/c2.cp.reactome.v7.1.symbols.gmt")
fgsea_reactome <- fgseaMultilevel(pathways=pathways.reactome, stats=ranks, nPermSimple = 10000, maxSize = 500, minSize = 30)
# convert to tibble, sort by NES and select columns
fgsea_reactome_tidy <- fgsea_reactome %>% as_tibble() %>% arrange(padj) %>% dplyr::select(-pval, -ES)
# Show in a nice table:
fgsea_reactome_tidy %>% DT::datatable()
```



### Top 15 up and down regulated Reactome pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowd pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_reactome_up <- fgsea_reactome[ES > 0][size < 250][order(padj,-NES),pathway][1:15]
top_reactome_dn <- fgsea_reactome[ES < 0][size < 250][order(padj,NES),pathway][1:15]
top_reactome <- c(top_reactome_up, rev(top_reactome_dn))
plotGseaTable(pathways.reactome[top_reactome], ranks, fgsea_reactome, gseaParam = 0.5)
fgsea_reactome_tidy_top <- fgsea_reactome_tidy %>% filter(pathway %in% top_reactome)
```


```{r, fig.width=12}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_reactome_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down Reactome pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=8))+theme(plot.title = element_text(size=7))
p1

```

### Enrichments plots for top Reactome hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.reactome[[top_reactome_up[i]]], ranks) + labs(title=top_reactome_up[i]))
}
```



### Leading Edge heatmaps for top Reactome hits

Heatmap of row normalised rld regularised leg transformed size factor normalised read counts

```{r, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
norm_counts <- as.data.frame(assay(rld))
norm_counts <- norm_counts %>% rownames_to_column(var="gene")
norm_counts_Ens <- merge(norm_counts, t2g_genes[,c(4,9)], by.all="gene")
ens2symbol <- AnnotationDbi::select(org.Hs.eg.db, key=norm_counts_Ens$ens_gene, columns="SYMBOL", keytype="ENSEMBL", multiVals="first") %>% distinct()
ens2symbol$gene <- paste(ens2symbol$ENSEMBL,"-",ens2symbol$SYMBOL,sep="")
ens2symbol <- as_tibble(ens2symbol)
norm_counts_Ens <- norm_counts_Ens %>% column_to_rownames(var= "ens_gene") %>% dplyr::select(-gene)
norm_counts_Ens_NSC <- norm_counts_Ens %>%  dplyr::select(ends_with("NSC"))

```

```{r,fig.height=10}
top_reactome_up_full <- fgsea_reactome[ES > 0][size < 250][order(padj,-NES),][1:5]

for (i in 1:5) {
  # Full pathway
  # print(pathways.reactome[[top_reactome_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_reactome_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens_NSC[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens_NSC)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  print(pheatmap(gene_counts_rownorm, col = colors, main=top_reactome_up_full[i,pathway]))
 }
  
```

## GSEA KEGG Pathways

```{r}
#pathways.kegg <- gmtPathways("./genesets/c2.cp.kegg.v7.1.symbols.gmt")
fgsea_kegg <- fgseaMultilevel(pathways=pathways.kegg, stats=ranks, nPermSimple = 10000, maxSize = 500, minSize = 30)
# convert to tibble, sort by NES and select columns
fgsea_kegg_tidy <- fgsea_kegg %>% as_tibble() %>% arrange(padj) %>% dplyr::select(-pval, -ES)
# Show in a nice table:
fgsea_kegg_tidy %>% DT::datatable()
```





### Top 15 up and down regulated KEGG pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowd pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_kegg_up <- fgsea_kegg[ES > 0][size < 250][order(padj,-NES),pathway][1:15]
top_kegg_dn <- fgsea_kegg[ES < 0][size < 250][order(padj,NES),pathway][1:15]
top_kegg <- c(top_kegg_up, rev(top_kegg_dn))
plotGseaTable(pathways.kegg[top_kegg], ranks, fgsea_kegg, gseaParam = 0.5)
fgsea_kegg_tidy_top <- fgsea_kegg_tidy %>% filter(pathway %in% top_kegg)
```


```{r, fig.width=12}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_kegg_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down KEGG pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=8))+theme(plot.title = element_text(size=7))
p1

```

### Enrichments plots for top KEGG hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.kegg[[top_kegg_up[i]]], ranks) + labs(title=top_kegg_up[i]))
}
```




### Leading Edge heatmaps for top KEGG hits

Heatmap of row noemalised rld regularised leg transformed size factor normalised read counts



```{r,fig.height=6}
top_kegg_up_full <- fgsea_kegg[ES > 0][size < 250][order(padj,-NES),][1:5]

for (i in 1:5) {
  # Full pathway
   #print(pathways.kegg[[top_kegg_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_kegg_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens_NSC[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens_NSC)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  print(pheatmap(gene_counts_rownorm, col = colors, main=top_kegg_up_full[i,pathway]))
 }
  
```

## GSEA GO BP Terms

```{r}
pathways.gobp <- gmtPathways("../genesets/c5.go.bp.v7.4.symbols.gmt")
fgsea_gobp <- fgseaMultilevel(pathways=pathways.gobp, stats=ranks, nPermSimple = 10000, maxSize = 500, minSize = 30)
# convert to tibble, sort by NES and select columns
fgsea_gobp_tidy <- fgsea_gobp %>% as_tibble() %>% arrange(padj) %>% dplyr::select(-pval, -ES)
# Show in a nice table:
fgsea_gobp_tidy %>% DT::datatable()
```



### Top 15 up and down regulated GOBP pathways

Not all pathways necessarily significant to adjusted p-value < 0.05
Maximum allowd pathway size 250 genes

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Top 10 regardless of adjusted p-value
top_gobp_up <- fgsea_gobp[ES > 0][size < 250][order(padj,-NES),pathway][1:15]
top_gobp_dn <- fgsea_gobp[ES < 0][size < 250][order(padj,NES),pathway][1:15]
top_gobp <- c(top_gobp_up, rev(top_gobp_dn))
plotGseaTable(pathways.gobp[top_gobp], ranks, fgsea_gobp, gseaParam = 0.5)
fgsea_gobp_tidy_top <- fgsea_gobp_tidy %>% filter(pathway %in% top_gobp)
```


```{r, fig.width=10}
#Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

p1 <- ggplot(fgsea_gobp_tidy_top, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Top up and down GO-BP pathways NES from GSEA") + theme(title=element_text(size=7))+theme(axis.text.y = element_text(size=8))+theme(plot.title = element_text(size=7))
p1

```

### Enrichments plots for top GOBP hits

```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (i in 1:5) {
  print(plotEnrichment(pathways.gobp[[top_gobp_up[i]]], ranks) + labs(title=top_gobp_up[i]))
}
```




### Leading Edge heatmaps for top GOBP hits

Heatmap of row noemalised rld regularised leg transformed size factor normalised read counts


```{r, fig.height=10}
top_gobp_up_full <- fgsea_gobp[ES > 0][size < 250][order(padj,-NES),][1:5]

for (i in 1:5) {
  # Full pathway
  # print(pathways.gobp[[top_gobp_up[i]]])
  # Leading edge only
  leading_edge = data.frame(symbol=top_gobp_up_full[i]$leadingEdge[[1]])
  leading_edge_ensg = inner_join(leading_edge, ens2symbol, by=c("symbol"="SYMBOL"))
  colors <- colorRampPalette((brewer.pal(9, "Blues")) )(255)
  gene_counts = norm_counts_Ens_NSC[match(leading_edge_ensg$ENSEMBL, rownames(norm_counts_Ens_NSC)),]
  rownames(gene_counts)= pull(ens2symbol[match(rownames(gene_counts), ens2symbol$ENSEMBL),], gene)
  cal_z_score <- function(x){
    (x - mean(x)) / sd(x)
  }
  gene_counts_rownorm <- t(apply(gene_counts, 1, cal_z_score))
  print(pheatmap(gene_counts_rownorm, col = colors, main=top_gobp_up_full[i,pathway]))
 }
  
```




# Overlap of DEG: Agg DEG (WK1 vs WK2) vs NSC DEG (WK 1 vs WK2)

+ As we can see there is a 30% overlap in the genes which are changing (up or down) between week1 and week2 for NSC and Aggregate.
+ To get a Aggregage and NSC specific signal we , need to only look at the gene subsets that do not overlap.

```{r, echo=FALSE, eval=T}
  
  d <- "AGG vs NSC (WK1 vs WK2)"
res_print_WK2Agg_WK1Agg <- as.data.frame(res_print_WK2Agg_WK1Agg)
rownames(res_print_WK2Agg_WK1Agg) <- res_print_WK2Agg_WK1Agg$ens_gene

res_print_WK2NSC_WK1NSC <- as.data.frame(res_print_WK2NSC_WK1NSC)
rownames(res_print_WK2NSC_WK1NSC) <- res_print_WK2NSC_WK1NSC$ens_gene

  ## Venn Diagram: DEGs for all 3 pairwise comparisons
  sig_Agg_up <- unique(rownames(res_print_WK2Agg_WK1Agg[res_print_WK2Agg_WK1Agg$fc == "up", ]))
  sig_Agg_down <- unique(rownames(res_print_WK2Agg_WK1Agg[res_print_WK2Agg_WK1Agg$fc == "down", ]))
  sig_NSC_up <- unique(rownames(res_print_WK2NSC_WK1NSC [res_print_WK2NSC_WK1NSC$fc == "up", ]))
  sig_NSC_down <- unique(rownames(res_print_WK2NSC_WK1NSC[res_print_WK2NSC_WK1NSC$fc == "down", ]))
  
 # tiff(filename = "./DEG_genes_WK1_WK2_aggregate_vs_NSC_Venn_diagram.tiff", height = 4, width=6, units = "in", res=300)
 
 # cairo_ps("./DEG_genes_Venn_diagram.eps", height = 4, width = 5, onefile = F)
   venn.plot <- venn.diagram(x=list(S1=as.matrix(sig_Agg_up), S2=as.matrix(sig_Agg_down), S3=as.matrix(sig_NSC_up), S4=as.matrix(sig_NSC_down)), fill = c("red", "cyan3", "green3","yellow"), alpha=c(0.5, 0.5, 0.5,0.5), cex=0.6, cat.cex=0.55, fontfamily="sans", cat.fontfamily="sans", main.fontfamily = "sans", cat.dist=c(0.2,0.2,0.1,0.1),  filename=NULL, euler.d=F, scaled=F, print.mode=c("percent", "raw"), sigdigs = 2, category.names=paste0(c("Agg UP", "Agg Down","NSC UP","NSC Down"), "\n", c(length(sig_Agg_up), length(sig_Agg_down), length(sig_NSC_up), length(sig_NSC_down))), main = d, main.cex = 0.7)
  
  grid.newpage()
  grid.draw(venn.plot)
  #dev.off()

```


## Evaluate Unique Up & Downs sets for Agg (WK2 vs WK1)



```{r}
Agg_UP_unique <- setdiff(sig_Agg_up,sig_NSC_up)
Agg_DN_unique <- setdiff(sig_Agg_down, sig_NSC_down)

Agg_unique <- c(Agg_DN_unique,Agg_UP_unique)
```


### GO BP overrepresentation for unique Agg genes (WK2 vs WK1)


```{r}


 all_genes <- as.character(unique(rownames(resOrdered_WK2Agg_WK1Agg_LFCshrink_ens)))

enrichGOResult_3 <- enrichGO(gene = Agg_unique, OrgDb = org.Hs.eg.db, keyType = 'ENSEMBL', ont = "BP", pAdjustMethod = "BH", universe=all_genes, readable = T)
enrichGOResult_3_s <- simplify(enrichGOResult_3, cutoff=0.8)
```




```{r, eval=T}

scorePlot <- RScorePlot_v2(enrichGOResult_3, resOrdered_WK2Agg_WK1Agg_LFCshrink_ens, showCategory = 30, textSize = 9, title = "" ) + theme(title = element_text(size=8), axis.text = element_text(size=8)) + ggtitle("GO BP terms for unique WK2:Agg vs WK1:Agg")
plot(scorePlot)
```


### Reactome Pathways for unique Agg genes (WK2 vs WK1)


```{r, eval=T, fig.width=9}

library(ReactomePA)
# only takes entrez id
Agg_unique_entrez <- resOrdered_WK2Agg_WK1Agg_LFCshrink_ens_sig %>% filter (rownames(.) %in% Agg_unique) %>% dplyr::select("entrez") %>% drop_na() 
Agg_unique_entrez <- as.character(Agg_unique_entrez$entrez)

#geneChangeList <- sort(geneChangeList, decreasing=TRUE)
#desiredGeneChangeList <- names(geneChangeList)[abs(geneChangeList) >1] 
 all_genes <- as.character(unique(resOrdered_WK2Agg_WK1Agg_LFCshrink_ens$entrez))
enrich_Reactome_3 <-  enrichPathway(gene = Agg_unique_entrez, pAdjustMethod = "BH", universe=all_genes, readable = T, organism = "human")
scorePlot <- RScorePlot_v3(enrich_Reactome_3, resOrdered_WK2Agg_WK1Agg_LFCshrink_ens, showCategory = 30, textSize = 9, title = "" ) + theme(title = element_text(size=8)) +ggtitle("Reactome terms for unique WK2:Agg vs WK1:Agg")
plot(scorePlot)
```


### MSigDB C3: Traancription factor target genesets for Agg genes

+ Gene sets representing potential targets of regulation by transcription factors or microRNAs.
+ The sets consist of genes grouped by elements they share in their non-protein coding regions.
+ The C3 collection is divided into two sub-collections:transcription factor targets (TFT)

```{r, eval=T, fig.width=7}


# only takes entrez id
Agg_unique_entrez <- resOrdered_WK2Agg_WK1Agg_LFCshrink_ens_sig %>% filter (rownames(.) %in% Agg_unique) %>% dplyr::select("entrez") %>% drop_na() 
Agg_unique_entrez <- as.character(Agg_unique_entrez$entrez)

#geneChangeList <- sort(geneChangeList, decreasing=TRUE)
#desiredGeneChangeList <- names(geneChangeList)[abs(geneChangeList) >1] 
 all_genes <- as.character(unique(resOrdered_WK2Agg_WK1Agg_LFCshrink_ens$entrez))

 m_t2g <- msigdbr::msigdbr(species = "Homo sapiens", category = "C3", subcategory = "TFT:GTRD")%>% dplyr::select(gs_name, entrez_gene)
 
 
 
 enrich_msig_c3 <-  enricher(gene = Agg_unique_entrez, pAdjustMethod = "BH", universe=all_genes, TERM2GENE = m_t2g)



scorePlot <- RScorePlot_v4(enrich_msig_c3, resOrdered_WK2Agg_WK1Agg_LFCshrink_ens, showCategory = 30, textSize = 9, title = "" ) + theme(title = element_text(size=8), axis.text.y = element_text(size=9)) +ggtitle("MSigDB C3 Trascription factor genesets for unique WK2:Agg vs WK1:Agg")
plot(scorePlot)
```




```{r, eval=F, fig.width=7}
### TRANSFAC: Transcription factor target genesets for PD genes

#Database of eukaryotic TFs and thier genomic binding sites

# TRANSFAC wasnt significant for PD Unique genes only
library(gprofiler2)
all_genes <- as.character(unique(rownames(resOrdered_WK2Agg_WK1Agg_LFCshrink_ens)))

transfac_agg_unique <- gost(query = Agg_unique, organism = "hsapiens", domain_scope = "custom", custom_bg = all_genes, sources = "TF" , significant = T, correction_method = "g_SCS")
```






## Evaluate Unique Up & Downs sets for NSC (WK2 vs WK1)


```{r}
NSC_UP_unique <- setdiff(sig_NSC_up,sig_Agg_up)
NSC_DN_unique <- setdiff(sig_NSC_down, sig_Agg_down)

NSC_unique <- c(NSC_DN_unique,NSC_UP_unique)
```



### GO BP overrepresentation for unique NSC genes (WK2 vs WK1)


```{r}


 all_genes <- as.character(unique(rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens)))

enrichGOResult_4 <- enrichGO(gene = NSC_unique, OrgDb = org.Hs.eg.db, keyType = 'ENSEMBL', ont = "BP", pAdjustMethod = "BH", universe=all_genes, readable = T)
enrichGOResult_4_s <- simplify(enrichGOResult_4, cutoff=0.8)
```




```{r, eval=T}

scorePlot <- RScorePlot_v2(enrichGOResult_4, resOrdered_WK2NSC_WK1NSC_LFCshrink_ens, showCategory = 20, textSize = 9, title = "" ) + theme(title = element_text(size=8), axis.text = element_text(size=8)) + ggtitle("GO BP terms for unique WK2:NSC vs WK1:NSC")
plot(scorePlot)
```

### Reactome Pathways for unique NSC genes (WK2 vs WK1)


```{r, eval=T, fig.width=9}

library(ReactomePA)
# only takes entrez id
NSC_unique_entrez <- resOrdered_WK2NSC_WK1NSC_LFCshrink_ens_sig %>% filter (rownames(.) %in% NSC_unique) %>% dplyr::select("entrez") %>% drop_na() 
NSC_unique_entrez <- as.character(NSC_unique_entrez$entrez)

#geneChangeList <- sort(geneChangeList, decreasing=TRUE)
#desiredGeneChangeList <- names(geneChangeList)[abs(geneChangeList) >1] 
 all_genes <- as.character(unique(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens$entrez))
enrich_Reactome_4 <-  enrichPathway(gene = NSC_unique_entrez, pAdjustMethod = "BH", universe=all_genes, readable = T, organism = "human")
scorePlot <- RScorePlot_v2(enrich_Reactome_4, resOrdered_WK2NSC_WK1NSC_LFCshrink_ens, showCategory = 20, textSize = 9, title = "" ) + theme(title = element_text(size=8), axis.text.y = element_text(size=8)) +ggtitle("Reactome terms for unique WK2:NSC vs WK1:NSC")
plot(scorePlot)
```


### MSigDB C3: Transcription factor target genesets NSC unique

+ Gene sets representing potential targets of regulation by transcription factors or microRNAs.
+ The sets consist of genes grouped by elements they share in their non-protein coding regions.
+ The C3 collection is divided into two sub-collections:transcription factor targets (TFT)

```{r, eval=T, fig.width=7}




#geneChangeList <- sort(geneChangeList, decreasing=TRUE)
#desiredGeneChangeList <- names(geneChangeList)[abs(geneChangeList) >1] 
 all_genes <- as.character(unique(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens$entrez))

 m_t2g <- msigdbr::msigdbr(species = "Homo sapiens", category = "C3", subcategory = "TFT:GTRD")%>% dplyr::select(gs_name, entrez_gene)
 
 
 
 enrich_msig_c3_2 <-  enricher(gene = NSC_unique_entrez, pAdjustMethod = "BH", universe=all_genes, TERM2GENE = m_t2g)



scorePlot <- RScorePlot_v4(enrich_msig_c3_2, resOrdered_WK2NSC_WK1NSC_LFCshrink_ens, showCategory = 15, textSize = 9, title = "" ) + theme(title = element_text(size=8), axis.text.y = element_text(size=9)) +ggtitle("MSigDB C3 Trascription factor genesets for unique WK2:NSC vs WK1:NSC")
plot(scorePlot)
```




```{r, eval=FALSE}
### TRANSFAC: Transcription factor target genesets for NSC Unique
all_genes <- as.character(unique(rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens)))
transfac_nsc_unique <- gost(query = NSC_unique, organism = "hsapiens", domain_scope = "custom", custom_bg = all_genes, sources = "TF" , significant = F, user_threshold = 0.05)
```




## Evaluate Common Up & Downs genes from Venn diagram


+ The common up and down genes between Agg and NSC (WK2 vs WK1) probabaly signify time or age related biological change in the iPSC samples 
+ This is probably not related to the treatment

```{r}
overlapping_UP <- intersect(sig_NSC_up, sig_Agg_up)
overlapping_DN <- intersect(sig_NSC_down, sig_Agg_down)

overlapping_set <- c(overlapping_UP, overlapping_DN)
```

### GO BP overrepresentation for overlapping genes (WK2 vs WK1)


```{r}
library(org.Hs.eg.db)

 all_genes <- as.character(intersect(rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens), rownames(resOrdered_WK2Agg_WK1Agg_LFCshrink_ens)))

enrichGOResult_5 <- enrichGO(gene = overlapping_set, OrgDb = org.Hs.eg.db, keyType = 'ENSEMBL', ont = "BP", pAdjustMethod = "BH", universe=all_genes, readable = T)
enrichGOResult_5_s <- simplify(enrichGOResult_5, cutoff=0.8)
```



```{r, eval=F}
#+ plot with Rscores based on the NSC (WK1 vs WK2 DEG)
scorePlot <- RScorePlot_v2(enrichGOResult_5, resOrdered_WK2NSC_WK1NSC_LFCshrink_ens, showCategory = 20, textSize = 9, title = "" ) + theme(title = element_text(size=8), axis.text = element_text(size=8)) + ggtitle("GO BP terms for Common terms with NSC Rscore")
plot(scorePlot)
```


+ plot with Rscores based on the Agg (WK1 vs WK2 DEG)

+ I dd check the NSC based Rscores plot, and thy were almost identical

```{r, eval=T}

scorePlot <- RScorePlot_v2(enrichGOResult_5, resOrdered_WK2Agg_WK1Agg_LFCshrink_ens, showCategory = 20, textSize = 9, title = "" ) + theme(title = element_text(size=8), axis.text = element_text(size=8)) + ggtitle("GO BP terms for Common terms with Agg Rscore")
plot(scorePlot)
```





### Reactome Pathways for overlapping genes (WK2 vs WK1)

+ I plot the Rscores based on the PD (WK2 vs WK1) results but i checked the NSC Rscores, and again they were identical

```{r, eval=T, fig.width=8}

library(ReactomePA)
# only takes entrez id
overlapping_entrez <- resOrdered_WK2NSC_WK1NSC_LFCshrink_ens_sig %>% filter (rownames(.) %in% overlapping_set) %>% dplyr::select("entrez") %>% drop_na() 
overlapping_entrez <- as.character(overlapping_entrez$entrez)

#geneChangeList <- sort(geneChangeList, decreasing=TRUE)
#desiredGeneChangeList <- names(geneChangeList)[abs(geneChangeList) >1] 
 all_genes <- as.character(intersect(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens$entrez, resOrdered_WK2Agg_WK1Agg_LFCshrink_ens$entrez))
enrich_Reactome_5 <-  enrichPathway(gene = overlapping_entrez, pAdjustMethod = "BH", universe=all_genes, readable = T, organism = "human")

scorePlot <- RScorePlot_v2(enrich_Reactome_5, resOrdered_WK2Agg_WK1Agg_LFCshrink_ens, showCategory = 20, textSize = 9, title = "" ) + theme(title = element_text(size=8), axis.text.y = element_text(size=8)) +ggtitle("Reactome terms for common genes with Agg Rscore")
plot(scorePlot)

#scorePlot_v2 <- RScorePlot_v2(enrich_Reactome_5, resOrdered_WK2NSC_WK1NSC_LFCshrink_ens, showCategory = 30, textSize = 9, title = "" ) + theme(title = element_text(size=8), axis.text.y = element_text(size=8)) +ggtitle("Reactome terms for common genes with NSC Rscore")
#plot(scorePlot_v2)



```


### MSigDB C3: Traancription factor target genesets 

+ Gene sets representing potential targets of regulation by transcription factors or microRNAs.
+ The sets consist of genes grouped by elements they share in their non-protein coding regions.
+ The C3 collection is divided into two sub-collections:transcription factor targets (TFT)

```{r, eval=T, fig.width=9}




#geneChangeList <- sort(geneChangeList, decreasing=TRUE)
#desiredGeneChangeList <- names(geneChangeList)[abs(geneChangeList) >1] 
 all_genes <- as.character(intersect(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens$entrez, resOrdered_WK2Agg_WK1Agg_LFCshrink_ens$entrez))

 m_t2g <- msigdbr::msigdbr(species = "Homo sapiens", category = "C3", subcategory = "TFT:GTRD")%>% dplyr::select(gs_name, entrez_gene)
 
 
 
 enrich_msig_c3_3 <-  enricher(gene = overlapping_entrez, pAdjustMethod = "BH", universe=all_genes, TERM2GENE = m_t2g)



scorePlot <- RScorePlot_v4(enrich_msig_c3_3, resOrdered_WK2Agg_WK1Agg_LFCshrink_ens, showCategory = 20, textSize = 9, title = "" ) + theme(title = element_text(size=8), axis.text.y = element_text(size=9)) +ggtitle("MSigDB C3 Trascription factor genesets for common genes")
plot(scorePlot)
```

```{r, eval=FALSE}
### TRANSFAC: Transcription factor target genesets for NSC Unique
all_genes <- as.character(unique(rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens)))
transfac_common <- gost(query = overlapping_set, organism = "hsapiens", domain_scope = "custom_annotated", custom_bg = all_genes, sources = "TF" , significant = F, user_threshold = 0.05, correction_method = "fdr")
```






## Pathway analysis for  the 6 sets
+ As most of the enriched pathways based on the Rscore for the combined up and down unique sets show down regulation in PD and NSC , we will try doing a analysis on the 6 setts seperately to see if we pick up somethiing




```{r}
gene_list_s <- list("Agg_UP" = Agg_UP_unique, "Agg_DN"=Agg_DN_unique, "NSC_UP"= NSC_UP_unique, "NSC_DN"= NSC_DN_unique, "overlap_UP"= overlapping_UP,
                    "overlap_DN" = overlapping_DN)

Agg_UP_unique_entrez <- resOrdered_WK2Agg_WK1Agg_LFCshrink_ens_sig %>% filter (rownames(.) %in% Agg_UP_unique) %>% dplyr::select("entrez") %>% drop_na() 
Agg_UP_unique_entrez <- as.character(Agg_UP_unique_entrez$entrez)

Agg_DN_unique_entrez <- resOrdered_WK2Agg_WK1Agg_LFCshrink_ens_sig %>% filter (rownames(.) %in% Agg_DN_unique) %>% dplyr::select("entrez") %>% drop_na()
Agg_DN_unique_entrez <- as.character(Agg_DN_unique_entrez$entrez)

NSC_UP_unique_entrez <- resOrdered_WK2NSC_WK1NSC_LFCshrink_ens %>% filter(rownames(.) %in% NSC_UP_unique) %>% dplyr::select("entrez") %>% drop_na()
NSC_UP_unique_entrez <- NSC_UP_unique_entrez$entrez

NSC_DN_unique_entrez <- resOrdered_WK2NSC_WK1NSC_LFCshrink_ens %>% filter(rownames(.) %in% NSC_DN_unique) %>% dplyr::select("entrez") %>% drop_na()
NSC_DN_unique_entrez <- NSC_DN_unique_entrez$entrez

overlap_UP_entrez <- resOrdered_WK2NSC_WK1NSC_LFCshrink_ens %>% filter(rownames(.) %in% overlapping_UP)  %>% dplyr::select("entrez") %>% drop_na()
overlap_UP_entrez <- overlap_UP_entrez$entrez

overlap_DN_entrez <- resOrdered_WK2NSC_WK1NSC_LFCshrink_ens %>% filter(rownames(.) %in% overlapping_DN)  %>% dplyr::select("entrez") %>% drop_na()
overlap_DN_entrez <- overlap_DN_entrez$entrez

gene_list_entrez <- list("Agg_UP" = Agg_UP_unique_entrez, "Agg_DN"= Agg_DN_unique_entrez, "NSC_UP"= NSC_UP_unique_entrez, 
                         "NSC_DN" = NSC_DN_unique_entrez, "overlap_UP"= overlap_UP_entrez, "overlap_DN"= overlap_DN_entrez)
```


### GO BP for the 6 sets seperately


```{r}

library(org.Hs.eg.db)

 all_genes <- as.character(intersect(rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens), rownames(resOrdered_WK2Agg_WK1Agg_LFCshrink_ens)))

GO_BP_cc <- compareCluster(geneClusters = gene_list_s , OrgDb = org.Hs.eg.db, keyType = 'ENSEMBL', ont = "BP", pAdjustMethod = "BH", universe=all_genes, readable = T, fun = "enrichGO", maxGSSize=1000,)
GO_BP_cc_s <- simplify(GO_BP_cc, cutoff=0.8)
```

```{r, fig.height=8, fig.width=8, results='hide'}
p <- dotplot(GO_BP_cc_s,showCategory =10,by= "Percentage", group=F, font.size=8, size="count") + scale_color_viridis_c(guide=guide_colorbar(reverse=TRUE)) + ggtitle("Enriched GO BP terms:WK1 vs WK2") + scale_size_continuous(breaks = c(10,30,50,75,100,150)) + geom_point(shape=21,stroke=0.5) + theme(title = element_text(size=8), axis.text.x = element_text(angle=45, hjust = 1, vjust = 1))
 p
```

### Reactome for the 6 sets seperately



```{r}
library(ReactomePA)
all_genes <- as.character(intersect(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens$entrez, resOrdered_WK2Agg_WK1Agg_LFCshrink_ens$entrez))
Reactome_cc <-  compareCluster(geneClusters = gene_list_entrez, pAdjustMethod = "BH", universe=all_genes, readable = T, organism = "human" , fun = "enrichPathway", maxGSSize=1000, pvalueCutoff =0.1)
```

```{r, fig.height=6, fig.width=11, results='hide'}
p <- dotplot(Reactome_cc,showCategory =10,by= "Percentage", group=F, font.size=8, size="count") 
 p <- p + scale_color_viridis_c(guide=guide_colorbar(reverse=TRUE)) + ggtitle("Enriched Reactome terms:WK1 vs WK2") + scale_size_continuous(breaks = c(10,30,50,75,100,150)) + geom_point(shape=21,stroke=0.5) + theme(title = element_text(size=8), axis.text.x = element_text(angle=45, hjust = 1, vjust = 1))
p
```


### KEGG for the 6 sets seperately



```{r}

all_genes <- as.character(intersect(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens$entrez, resOrdered_WK2Agg_WK1Agg_LFCshrink_ens$entrez))
KEGG_cc <-  compareCluster(geneClusters = gene_list_entrez, pAdjustMethod = "BH", universe=all_genes, organism = "hsa" , fun = "enrichKEGG", maxGSSize=1000, pvalueCutoff =0.1, keyType = "ncbi-geneid")
```

```{r, fig.height=6, fig.width=6, results='hide'}
p <- dotplot(KEGG_cc,showCategory =10,by= "Percentage", group=F, font.size=8, size="count") 
 p <- p + scale_color_viridis_c(guide=guide_colorbar(reverse=TRUE)) + ggtitle("Enriched KEGG terms:WK1 vs WK2") + scale_size_continuous(breaks = c(10,30,50,75,100,150)) + geom_point(shape=21,stroke=0.5) + theme(title = element_text(size=8), axis.text.x = element_text(angle=45, hjust = 1, vjust = 1))
p
```

# Functional links in PPI for 6 sets to PD Risk Genes

+  To test if DEG genes  in WK2: WK1 comparisons for PD or NSC have higher than expected direct links with PD risk genes in PPIs in humans
+  PD risk genes are from META5 PD risk study NALLS 2019 and Chang 2017 study
+  These PD risk genes are putative causal genes , and often are the nearest gene to the relevant risk variant in SNPS
+  Only 70 out of the 90 variants have identified putative causal gene in the META5 result
+  150 unique PD risk genes

```{r, eval=TRUE}

# get max CDS for t2g genes  from biomart
mart <- biomaRt::useMart(biomart = "ENSEMBL_MART_ENSEMBL", dataset = "hsapiens_gene_ensembl", host="www.ensembl.org")
cds <- biomaRt::getBM(attributes = c("ensembl_transcript_id","ensembl_gene_id", "cds_length"),filters = "ensembl_transcript_id_version", mart = mart, values = t2g_genes$target_id)
cds <- cds %>% drop_na()
cds_gene <- cds %>% group_by(ensembl_gene_id) %>% summarise(max_length = max(cds_length), mean_length = mean(cds_length)) 
setnames(cds_gene, c("ensembl_gene_id"), c("gene"))
```



```{r, eval=T}
ppi_net <- fread(file = "./PPImerged_Jimena2017_score")
setnames(ppi_net, c("gene1","gene2","score"))
## how many simulations/randomisations
n_sim <- 10000
```




## WK2 Agg vs WK1 Agg


```{r, eval=T}

all_genes <- rownames(resOrdered_WK2Agg_WK1Agg_LFCshrink_ens)
WK2_WK1_Agg <- c(sig_Agg_up, sig_Agg_down)
```

```{r, eval=T}

WK2_WK1_Agg_pdrisk_ppi <- test_enrich_two_sets_avi(input_net = ppi_net ,input_cds = cds_gene,input_list_1 = WK2_WK1_Agg , input_list_2 =PD_risk_genes_ens  ,input_universe = all_genes,n_rand = 10000 )
```


## WK2 NSC vs WK1 NSC

```{r, eval=T}
set.seed(.Random.seed)
all_genes <- rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens)
WK2_WK1_NSC <- c(sig_NSC_up, sig_NSC_down)
```

```{r, eval=T}

WK2_WK1_NSC_pdrisk_ppi <- test_enrich_two_sets_avi(input_net = ppi_net ,input_cds = cds_gene,input_list_1 = WK2_WK1_NSC , input_list_2 =PD_risk_genes_ens  ,input_universe = all_genes,n_rand = 10000 )
```



## NSC Unique

```{r, eval=T}
all_genes <- rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens)
NSC_unique_overlap <- test_enrich_two_sets_avi(input_net = ppi_net ,input_cds = cds_gene,input_list_1 = NSC_unique , input_list_2 = PD_risk_genes_ens ,input_universe = all_genes,n_rand = 10000 )
```


## Agg Unique

```{r, eval=T}
all_genes <- rownames(resOrdered_WK2Agg_WK1Agg_LFCshrink_ens)
Agg_unique_overlap <- test_enrich_two_sets_avi(input_net = ppi_net ,input_cds = cds_gene,input_list_1 = Agg_unique , input_list_2 = PD_risk_genes_ens ,input_universe = all_genes,n_rand = 10000 )
```


## Overlapping gene set

```{r, eval=T}
all_genes <- as.character(intersect(rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens), rownames(resOrdered_WK2Agg_WK1Agg_LFCshrink_ens)))
common_geneset_overlap <- test_enrich_two_sets_avi(input_net = ppi_net ,input_cds = cds_gene,input_list_1 = overlapping_set , input_list_2 = PD_risk_genes_ens ,input_universe = all_genes,n_rand = 10000 )
```



# Functional links in PPI for DEG to a-synucelin interacting proteins

 A list of  1000 interacting proteins with a-synucelin, after aggregation was generated with Mass spectrometry for the Nature comms 2021 paper
 We have already checked to see , if there is an overlap between this list and DEG
 We are now checking to see if the DEG interact with these 1000 proteins in PPIs


## WK2 Agg vs WK1 Agg


```{r, eval=T}

all_genes <- rownames(resOrdered_WK2Agg_WK1Agg_LFCshrink_ens)
WK2_WK1_Agg <- c(sig_Agg_up, sig_Agg_down)
```

```{r, eval=T}

WK2_WK1_Agg_async_ppi <- test_enrich_two_sets_avi(input_net = ppi_net ,input_cds = cds_gene,input_list_1 = WK2_WK1_Agg , input_list_2 = async_int_proteins_ens_v  ,input_universe = all_genes,n_rand = 10000 )
```


## WK2 NSC vs WK1 NSC

```{r, eval=T}
set.seed(.Random.seed)
all_genes <- rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens)
WK2_WK1_NSC <- c(sig_NSC_up, sig_NSC_down)
```

```{r, eval=T}

WK2_WK1_NSC_async_ppi <- test_enrich_two_sets_avi(input_net = ppi_net ,input_cds = cds_gene,input_list_1 = WK2_WK1_NSC , input_list_2 = async_int_proteins_ens_v  ,input_universe = all_genes,n_rand = 10000 )
```



## NSC Unique

```{r, eval=T}
all_genes <- rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens)
NSC_unique_overlap_async <- test_enrich_two_sets_avi(input_net = ppi_net ,input_cds = cds_gene,input_list_1 = NSC_unique , input_list_2 = async_int_proteins_ens_v ,input_universe = all_genes,n_rand = 10000 )
```


## Agg Unique

```{r, eval=T}
all_genes <- rownames(resOrdered_WK2Agg_WK1Agg_LFCshrink_ens)
Agg_unique_overlap_async <- test_enrich_two_sets_avi(input_net = ppi_net ,input_cds = cds_gene,input_list_1 = Agg_unique , input_list_2 = async_int_proteins_ens_v ,input_universe = all_genes,n_rand = 10000 )
```


## Overlapping gene set

```{r, eval=T}
 all_genes <- as.character(intersect(rownames(resOrdered_WK2NSC_WK1NSC_LFCshrink_ens), rownames(resOrdered_WK2Agg_WK1Agg_LFCshrink_ens)))

common_geneset_overlap_async <- test_enrich_two_sets_avi(input_net = ppi_net ,input_cds = cds_gene,input_list_1 = overlapping_set , input_list_2 = async_int_proteins_ens_v ,input_universe = all_genes,n_rand = 10000 )
```






















```{r,fig.height=10, fig.width= 8,echo=F, eval=FALSE, include=FALSE}
# Heatmap of Top DEG in Week 1 and Week2

library(pheatmap)
top_genes <- 15

 #prnt table of up and down regulated genes from DEG
    res_print_WK1_aggregate_NSC <- print_DESeq_table(res_WK1_aggregate_NSC, t2g_info = t2g_genes, alpha_level = alpha_cutoff)

    plot_up_genes_WK1 <- res_print_WK1_aggregate_NSC[fc == "up", target_id][1:top_genes]
    plot_up_genes_WK1 <- plot_up_genes_WK1[!(is.na(plot_up_genes_WK1))] # if there are not top_genes DEGs, NA values will be returned
    plot_down_genes_WK1 <- res_print_WK1_aggregate_NSC[fc == "down", target_id][1:top_genes]
    plot_down_genes_WK1 <- plot_down_genes_WK1[!(is.na(plot_down_genes_WK1))]

    res_print_WK2_aggregate_NSC <- print_DESeq_table(res_WK2_aggregate_NSC, t2g_info = t2g_genes, alpha_level = alpha_cutoff)
    
    
    plot_up_genes_WK2 <- res_print_WK2_aggregate_NSC[fc == "up", target_id][1:top_genes]
    plot_up_genes_WK2 <- plot_up_genes_WK2[!(is.na(plot_up_genes_WK2))] # if there are not top_genes DEGs, NA values will be returned
    plot_down_genes_WK2 <- res_print_WK2_aggregate_NSC[fc == "down", target_id][1:top_genes]
    plot_down_genes_WK2 <- plot_down_genes_WK2[!(is.na(plot_down_genes_WK2))]
    
    plot_down_genes_WK1 <- data.frame(plot_down_genes_WK1)
   # plot_down_genes_KO$group <- "down_TREM2_KO"
    
    plot_up_genes_WK1 <- data.frame(plot_up_genes_WK1)
   # plot_up_genes_KO$group <- "up_TREM2_KO"
    
    plot_down_genes_WK2 <- data.frame(plot_down_genes_WK2)
   # plot_down_genes_R47H$group <- "down_TREM2_R47H"
    
    plot_up_genes_WK2 <- data.frame(plot_up_genes_WK2)
    #plot_up_genes_R47H$group <- "up_TREM2_R47H"
    
    #control_genes <- data.frame(control_genes)
    #control_genes$group <- "relevant_genes"

    colnames(plot_up_genes_WK1)[1] <- "gene"
    colnames(plot_up_genes_WK2)[1] <- "gene"
    colnames(plot_down_genes_WK1)[1] <- "gene"
    colnames(plot_down_genes_WK2)[1] <- "gene"
    #colnames(control_genes)[1] <- "gene"
    
  heatmap_genes <- rbind(plot_up_genes_WK1,plot_down_genes_WK1, plot_up_genes_WK2,plot_down_genes_WK2)
  annotation_row <- heatmap_genes
  norm_counts_symbol <- merge(norm_counts, ens2symbol, by.x="gene",by.y= "gene")
  
rlog_heatmap <- norm_counts_symbol %>% filter(norm_counts_symbol$gene %in% heatmap_genes$gene)

# remove ACAT2 duplicate
drop_gene <- c("ACTA2 - ENSG00000107796")
rlog_heatmap <- rlog_heatmap %>% filter(!gene %in% drop_gene)

rownames(rlog_heatmap) <- rlog_heatmap$SYMBOL
rlog_heatmap <- rlog_heatmap[,-c(1,26:27)]

#rlog_heatmap  <- rlog_heatmap - rowMeans(rlog_heatmap) # scale using the heatmap function to get better scaling



#vsd <- vst(dds,blind=T)
#vsd_ens <- as.data.frame(assay(vsd))
#vsd_symbol <- vsd_ens %>% rownames_to_column(var = "gene") %>% inner_join(.,y = ens2symbol,by="gene")
#vsd_heatmap <- vsd_symbol %>% filter(vsd_symbol$gene %in% heatmap_genes$gene)
#vsd_heatmap <- vsd_heatmap %>% filter(!gene %in% drop_gene)

#rownames(vsd_heatmap) <- vsd_heatmap$SYMBOL
#vsd_heatmap <- vsd_heatmap[,-c(1,26:27)]

#vsd_heatmap  <- vsd_heatmap - rowMeans(vsd_heatmap) # scale using the heatmap function to get better scaling

```

```{r, fig.height= 4, fig.width=6,echo=F, eval=FALSE}
library(pheatmap)

#write.table(annotation_row, file="./heatmap_age_controlled_annotation_row.txt", sep="\t",quote=F)
anno <- as.data.frame(colData(rld)[, c("Group2","Replicate","Treatment")])
 #anno$Group <- mapvalues(anno$Group, from = c("Parent_control", "KO_control","R47H_control"), to = c("WT", "TREM2_KO","TREM2_R47H"))
 anno$Group2 <- factor(anno$Group2, levels = c("WK1_NSC", "WK1_aggregate", "WK2_NSC","WK2_aggregate"))
 colnames(anno)[1] <- "Group"
 anno_order <- c("Replicate", "Treatment", "Group")
 anno <- anno[, anno_order]
##annotation_row_1 <- read.table(file="./heatmap_age_controlled_annotation_row.txt", sep="\t", header=T)
#rownames(annotation_row_1) <- annotation_row_1$gene
#annotation_row_1$gene <- ""
#colnames(annotation_row_1)[1] <- ""
#colnames(annotation_row_1)[2] <- "Gene_group"

#ann_colors = list(
 #   Gene_group = c(down_TREM2_KO = "darkblue", down_TREM2_R47H = "deepskyblue4", down_TREM2_KO_R47H = "darkcyan", down_TREM2_R47H_KO ="cyan4", up_TREM2_KO="firebrick4", up_TREM2_R47H="darkorange",up_TREM2_KO_down_R47H="darksalmon", up_TREM2_KO_R47H="indianred1", up_TREM2_R47H_KO="indianred2",relevant_genes="black"),
  #  Group = c(WT = "darkgrey", TREM2_R47H = "darkorange3",TREM2_KO = "mediumorchid4")
#)
 ann_colors = list(
   Group = c(WK1_NSC = "#7FBFF5", WK1_aggregate = "navyblue", WK2_NSC = "grey79", WK2_aggregate = "grey23") ,
   Treatment = c(NSC ="slategrey", PD = "darkorange3", MSA = "mediumorchid4", Fibrils ="cyan4"),
   Replicate = c(R1 = "white", R2 = "white", R3 = "white")
 )
 
 
 
 
col_order <- c("WK1_R1_NSC", "WK1_R2_NSC", "WK1_R3_NSC","WK1_R1_FIB","WK1_R2_FIB","WK1_R3_FIB","WK1_R1_PD","WK1_R2_PD","WK1_R3_PD",
               "WK1_R1_MSA","WK1_R2_MSA","WK1_R3_MSA","WK2_R1_NSC", "WK2_R2_NSC", "WK2_R3_NSC","WK2_R1_FIB","WK2_R2_FIB","WK2_R3_FIB","WK2_R1_PD","WK2_R2_PD","WK2_R3_PD",
               "WK2_R1_MSA","WK2_R2_MSA","WK2_R3_MSA")

rlog_heatmap <- rlog_heatmap[, col_order]

#vsd_heatmap <- vsd_heatmap[, col_order]

DEG_heatmap <-pheatmap(rlog_heatmap, annotation_col = anno[,c("Group","Treatment", "Replicate")], fontsize = 8, fontsize_row = 8, cluster_rows = T, cutree_cols = 4, cutree_rows = 4, cluster_cols = F, clustering_method = "ward.D2", scale = "row", treeheight_row = 10,show_colnames = F, annotation_colors = ann_colors, annotation_legend = T)
DEG_heatmap



#grid::grid.newpage()
  #grid::grid.draw(DEG_heatmap$gtable)
#DEG_heatmap_2 <- as_grob(DEG_heatmap)
  
  
  
  
save_pheatmap_png <- function(x, filename, width=1200, height=1000, res = 300) {
  png(filename, width = width, height = height, res = res, units = "in")
  grid::grid.newpage()
  grid::grid.draw(x$gtable)
  dev.off()
}
 
save_pheatmap_png(DEG_heatmap, "Top15_DEG_heatmap_pooled_treatment_wardd2.png",height = 5, width=6)

cairo_ps("Top15_DEG_heatmap_pooled_treatment_wardd2.eps", height = 5, width = 6, onefile = F)
DEG_heatmap
dev.off()
```






```{r, eval=FALSE}

# Pathway transiston from WK1 to WK2 in Aggregate vs NSC

## Top GSEA KEGG pathway transistion
fgsea_kegg_tidy_top_WK1_agg_NSC$Group <- "WK1"
fgsea_kegg_tidy_top_WK2_agg_NSC$Group <- "WK2"



fgsea_kegg_tidy_top_WK1_WK2 <- rbind(fgsea_kegg_tidy_top_WK1_agg_NSC, fgsea_kegg_tidy_top_WK2_agg_NSC)

# Remove pathways that George doesnt want
drop_kegg <- c("KEGG_NON_SMALL_CELL_LUNG_CANCER","KEGG_CHRONIC_MYELOID_LEUKEMIA","KEGG_PANCREATIC_CANCER",
"KEGG_ARRHYTHMOGENIC_RIGHT_VENTRICULAR_CARDIOMYOPATHY_ARVC","KEGG_FC_EPSILON_RI_SIGNALING_PATHWAY","KEGG_LEUKOCYTE_TRANSENDOTHELIAL_MIGRATION"
,"KEGG_VASCULAR_SMOOTH_MUSCLE_CONTRACTION","KEGG_HEDGEHOG_SIGNALING_PATHWAY","KEGG_VIBRIO_CHOLERAE_INFECTION","KEGG_VASOPRESSIN_REGULATED_WATER_REABSORPTION","KEGG_COMPLEMENT_AND_COAGULATION_CASCADES","KEGG_RENAL_CELL_CARCINOMA","KEGG_ADHERENS_JUNCTION","KEGG_OLFACTORY_TRANSDUCTION",
"KEGG_PROGESTERONE_MEDIATED_OOCYTE_MATURATION","KEGG_LEISHMANIA_INFECTION","KEGG_PROSTATE_CANCER")

fgsea_kegg_top_WK1_WK2_keep <- fgsea_kegg_tidy_top_WK1_WK2 %>% filter(!pathway %in% drop_kegg)

kegg_keep <- unique(fgsea_kegg_top_WK1_WK2_keep$pathway)

kegg_plot_WK1 <- fgsea_kegg_tidy_WK1_agg_NSC %>% filter(pathway %in% kegg_keep)
kegg_plot_WK1$Group <- "WK1"

kegg_plot_WK2 <- fgsea_kegg_tidy_WK2_agg_NSC %>% filter(pathway %in% kegg_keep)
kegg_plot_WK2$Group <- "WK2"

kegg_plot_WK1_WK2 <- rbind(kegg_plot_WK1,kegg_plot_WK2)
kegg_plot_WK1_WK2_red <- kegg_plot_WK1_WK2 %>%  dplyr::select(pathway, NES, Group, padj)
# make NES values For WEEK  1 and Week2 as seperate columns
kegg_plot_WK1_WK2_wide <- kegg_plot_WK1_WK2 %>% pivot_wider( names_from = "Group", values_from = 2:6)
kegg_plot_WK1_WK2_wide$group <- ifelse(kegg_plot_WK1_WK2_wide$pathway %in% fgsea_kegg_tidy_top_WK1_agg_NSC$pathway, "WK1", "WK2")
kegg_plot_WK1_WK2_wide$Direction <- ifelse(kegg_plot_WK1_WK2_wide$group == "WK1" & kegg_plot_WK1_WK2_wide$NES_WK1 > 0,"UP",
                                           ifelse(kegg_plot_WK1_WK2_wide$group == "WK2"& kegg_plot_WK1_WK2_wide$NES_WK2>0, "UP","DOWN"
                                           ))
kegg_plot_WK1_WK2_wide$label <- paste(kegg_plot_WK1_WK2_wide$group,"-",kegg_plot_WK1_WK2_wide$Direction,sep="")
```





```{r, fig.height=6, fig.width= 10, eval=FALSE}
#+ A geom_segment plot to show the change in GSEA  NES score for the same pathways between Week1 and Week2
library(viridis)
 p <- ggplot(kegg_plot_WK1_WK2_wide, aes( y= reorder(pathway, NES_WK1))) + geom_segment(aes(x = kegg_plot_WK1_WK2_wide$NES_WK1, y=pathway,                     xend= kegg_plot_WK1_WK2_wide$NES_WK2, yend=pathway),size=0.5) + xlab("Normalized Enirchment Score ") + ylab("Top KEGG pathways")
p <- p + geom_point(aes(x=kegg_plot_WK1_WK2_wide$NES_WK1, shape ="WK1", color = padj_WK1), size=3) + geom_point(aes(x = kegg_plot_WK1_WK2_wide$NES_WK2, shape="WK2", color= padj_WK2),size=3) + theme(axis.text.y = element_text(size=6), axis.text.x = element_text(size=6)) + labs (shape= "Treatment")
p <- p + scale_fill_discrete(name = "Group") + scale_color_viridis(direction = -1, "P.adj", option="D") +facet_wrap( .~label , scales = "free") + theme(strip.background = element_blank(), strip.text = element_text(size=7),legend.title = element_text(size=7), axis.title = element_text(size=6),
legend.text = element_text(size=7))
p
ggsave(filename = "./Pooled_NSC_aggregated_WK1_Wk2_top_KEGG_GSEA.pdf",width = 9,height=6, units = "in")
```




```{r, eval=FALSE}
## Top GSEA GOBP pathway transistion
fgsea_gobp_tidy_top_WK1_agg_NSC$Group <- "WK1"
fgsea_gobp_tidy_top_WK1_agg_NSC_up <- fgsea_gobp_tidy_top_WK1_agg_NSC %>% filter(NES >0)
fgsea_gobp_tidy_top_WK2_agg_NSC$Group <- "WK2"
fgsea_gobp_tidy_top_WK2_agg_NSC_up <- fgsea_gobp_tidy_top_WK2_agg_NSC %>% filter(NES >0)


fgsea_gobp_tidy_top_WK1_WK2 <- rbind(fgsea_gobp_tidy_top_WK1_agg_NSC_up, fgsea_gobp_tidy_top_WK2_agg_NSC_up)

# Remove pathways that George doesnt want
drop_gobp <- c("GO_LEUKOCYTE_HOMEOSTASIS","GO_REGULATION_OF_LAMELLIPODIUM_ORGANIZATION","GO_LYMPHOCYTE_HOMEOSTASIS",
               "GO_CILIUM_OR_FLAGELLUM_DEPENDENT_CELL_MOTILITY","GO_MALE_SEX_DIFFERENTIATION","GO_RESPONSE_TO_CORTICOSTEROID","GO_MUSCLE_CELL_MIGRATION",
               "GO_SMOOTH_MUSCLE_CELL_MIGRATION","GO_INTRACILIARY_TRANSPORT","GO_PLATELET_DERIVED_GROWTH_FACTOR_RECEPTOR_SIGNALING_PATHWAY",
               "GO_POSITIVE_REGULATION_OF_CELL_CYCLE_G1_S_PHASE_TRANSITION","GO_REGULATION_OF_INTRACELLULAR_ESTROGEN_RECEPTOR_SIGNALING_PATHWAY",
"GO_REGULATION_OF_SMOOTHENED_SIGNALING_PATHWAY","GO_CONNECTIVE_TISSUE_DEVELOPMENT","GO_ACTOMYOSIN_STRUCTURE_ORGANIZATION")

fgsea_gobp_top_WK1_WK2_keep <- fgsea_gobp_tidy_top_WK1_WK2 %>% filter(!pathway %in% drop_gobp)

drop_gobp_2 <- c("GO_POSITIVE_REGULATION_OF_PROTEIN_LOCALIZATION_TO_CELL_PERIPHERY","GO_REGULATION_OF_PROTEIN_LOCALIZATION_TO_CELL_PERIPHERY","GO_REGULATION_OF_PROTEIN_LOCALIZATION_TO_MEMBRANE","GO_POSITIVE_REGULATION_OF_PROTEIN_LOCALIZATION_TO_MEMBRANE","GO_POSITIVE_REGULATION_OF_CELLULAR_PROTEIN_LOCALIZATION","GO_PIGMENTATION","GO_FC_RECEPTOR_MEDIATED_STIMULATORY_SIGNALING_PATHWAY","GO_SMOOTHENED_SIGNALING_PATHWAY","GO_PROTEIN_CONTAINING_COMPLEX_LOCALIZATION")

fgsea_gobp_top_WK1_WK2_keep_v2 <- fgsea_gobp_top_WK1_WK2_keep %>% filter(!pathway %in% drop_gobp_2)

gobp_keep <- unique(fgsea_gobp_top_WK1_WK2_keep_v2$pathway)

gobp_plot_WK1 <- fgsea_gobp_tidy_WK1_agg_NSC %>% filter(pathway %in% gobp_keep)
gobp_plot_WK1$Group <- "WK1"


gobp_plot_WK2 <- fgsea_gobp_tidy_WK2_agg_NSC %>% filter(pathway %in% gobp_keep)
gobp_plot_WK2$Group <- "WK2"

gobp_plot_WK1_WK2 <- rbind(gobp_plot_WK1,gobp_plot_WK2)
gobp_plot_WK1_WK2$pathway <- reorder(gobp_plot_WK1_WK2$pathway,gobp_plot_WK1_WK2$NES)

# make NES values For WEEK  1 and Week2 as seperate columns
gobp_plot_WK1_WK2_wide <- gobp_plot_WK1_WK2 %>% pivot_wider( names_from = "Group", values_from = 2:6)
gobp_plot_WK1_WK2_wide$group <- ifelse(gobp_plot_WK1_WK2_wide$pathway %in% fgsea_gobp_tidy_top_WK1_agg_NSC$pathway, "WK1", "WK2")


#gobp_plot_WK1_WK2_wide$Direction <- ifelse(gobp_plot_WK1_WK2_wide$group == "WK1" & gobp_plot_WK1_WK2_wide$NES_WK1 > 0,"UP",
#                                           ifelse(gobp_plot_WK1_WK2_wide$group == "WK2"& gobp_plot_WK1_WK2_wide$NES_WK2>0, "UP","DOWN"
 #                                          ))
gobp_plot_WK1_WK2_wide$label <- paste("GSEA-",gobp_plot_WK1_WK2_wide$group,":","Aggregate vs NSC",sep="")
gobp_plot_WK1_WK2_wide$order <- ifelse(gobp_plot_WK1_WK2_wide$group == "WK1", gobp_plot_WK1_WK2_wide$NES_WK1, gobp_plot_WK1_WK2_wide$NES_WK2)
```




```{r, fig.height=6, fig.width= 9, eval=FALSE}
#+ A geom_segment plot to show the change in GSEA  NES score for the same pathways between Week1 and Week2

library(viridis)
 p <- ggplot(gobp_plot_WK1_WK2_wide, aes( y=reorder(pathway, -order))) + geom_segment(aes(x = gobp_plot_WK1_WK2_wide$NES_WK1, y=pathway,                     xend= gobp_plot_WK1_WK2_wide$NES_WK2, yend=pathway),size=0.5) + xlab("Normalized Enirchment Score ") + ylab("Top GO-BP Terms")
p <- p + geom_point(aes(x=gobp_plot_WK1_WK2_wide$NES_WK1, shape ="WK1", color = padj_WK1), size=3) + geom_point(aes(x = gobp_plot_WK1_WK2_wide$NES_WK2, shape="WK2", color= padj_WK2),size=3) + theme(axis.text.y = element_text(size=7, face="bold"), axis.text.x = element_text(size=6), axis.title = element_text(size=10)) + labs (shape= "Treatment")
p <- p + scale_fill_discrete(name = "Group") + scale_color_viridis(direction = -1, "P.adj", option="D") +facet_wrap( .~label , scales = "free", ncol = 1) + theme(strip.background = element_blank(), strip.text = element_text(size=7), legend.title = element_text(size=7), axis.title = element_text(size=6),
 legend.text = element_text(size=7)) +xlim(-1.2,2.0)
p
ggsave(filename = "./Pooled_NSC_aggregated_WK1_Wk2_top_GOBP_GSEA_v2.pdf",width = 7.2,height=6, units = "in")
```

```{r, fig.width = 7, eval=F}
WK1_gobp_gt <- shake_fgseaResult(fgsea_gobp_WK1_agg_NSC)
WK2_gobp_gt <- shake_fgseaResult(fgsea_gobp_WK2_agg_NSC)
gs_summary_overview_pair(res_enrich = WK1_gobp_gt, res_enrich2 = WK2_gobp_gt,p_value_column = "gs_adj_pvalue")

anno_df_wk1 <- t2g_genes[,c(9,7)]
colnames(anno_df_wk1)[1] <- "gene_id"
colnames(anno_df_wk1)[1] <- "gene_name"

gs_summary_overview_pair(res_enrich = WK1_gobp_gt, res_enrich2 = WK2_gobp_gt,p_value_column = "gs_adj_pvalue", color_by = "gs_NES")
```





```{r}
sessionInfo()
```

